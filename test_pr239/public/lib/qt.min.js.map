{"version":3,"sources":["qt.min.js","/source/qt.js","/source/qmlstructure.js","/source/qml.js","/source/QMLColor.js","/source/QMLInteger.js","/source/QMLList.js","/source/QMLProperty.js","/source/QMLVariant.js","/source/QObject.js","/source/UpdateGeometry.js","/source/QmlWeb.Dom/DomElement.js","/source/QtQml/Component.js","/source/QtQml/QtObject.js","/source/QtQuick.Controls/Button.js","/source/QtQuick.Controls/ComboBox.js","/source/QtQuick.Controls/ScrollView.js","/source/QtQuick.Controls/TextArea.js","/source/QtQuick.Controls/TextField.js","/source/QtQuick.Window/Screen.js","/source/QtQuick/Column.js","/source/QtQuick/Flow.js","/source/QtQuick/Grid.js","/source/QtQuick/Image.js","/source/QtQuick/Item.js","/source/QtQuick/Positioner.js","/source/QtQuick/PropertyChanges.js","/source/QtQuick/Rectangle.js","/source/QtQuick/Repeater.js","/source/QtQuick/Row.js","/source/QtQuick/TextEdit.js","/source/QMLBinding.js","/source/import.js","/source/AutoLoader.js","/source/jsparser.js","/source/QMLEngine.js","/source/QMLOperationState.js","/source/qrc.js","/source/signal.js","/source/QmlWeb/RestModel.js","/source/Qt.labs.settings/Settings.js","/source/QtGraphicalEffects/FastBlur.js","/source/QtMobility/GeoLocation.js","/source/QtMultimedia/Video.js","/source/QtQml/Connections.js","/source/QtQml/Qt.js","/source/QtQml/Timer.js","/source/QtQuick.Controls/Checkbox.js","/source/QtQuick/AnimatedImage.js","/source/QtQuick/Animation.js","/source/QtQuick/Behavior.js","/source/QtQuick/BorderImage.js","/source/QtQuick/Canvas.js","/source/QtQuick/DoubleValidator.js","/source/QtQuick/EasingEnum.js","/source/QtQuick/Font.js","/source/QtQuick/FontEnum.js","/source/QtQuick/FontLoader.js","/source/QtQuick/IntValidator.js","/source/QtQuick/ListElement.js","/source/QtQuick/ListModel.js","/source/QtQuick/ListView.js","/source/QtQuick/Loader.js","/source/QtQuick/MouseArea.js","/source/QtQuick/NumberAnimation.js","/source/QtQuick/ParallelAnimation.js","/source/QtQuick/PropertyAnimation.js","/source/QtQuick/RegExpValidator.js","/source/QtQuick/Rotation.js","/source/QtQuick/Scale.js","/source/QtQuick/SequentialAnimation.js","/source/QtQuick/State.js","/source/QtQuick/SystemPalette.js","/source/QtQuick/Text.js","/source/QtQuick/TextInput.js","/source/QtQuick/Transition.js","/source/QtQuick/Translate.js","/source/QtWebSockets/WebSocket.js"],"names":["global","_classCallCheck","instance","Constructor","TypeError","QMLMethod","src","this","QMLPropertyDefinition","type","value","QMLAliasDefinition","objName","propName","objectName","propertyName","QMLSignalDefinition","params","parameters","QMLMetaPropertyGroup","QMLMetaElement","onProp","$class","$children","$on","convertToEngine","tree","walk","walker","walkers","apply","slice","console","log","bindout","binding","QMLBinding","toplevel","imports","statement","item","$imports","qmlelem","elem","statements","i","name","val","$defaultProperty","push","length","qmlprop","qmlobjdef","property","qmlobj","qmlmethod","qmlpropdef","undefined","qmlaliasdef","qmlsignaldef","qmldefaultprop","num","string","String","array","a","isList","hasBinding","parseQML","file","loadParser","qmlweb_parse","nowParsingFile","parsetree","QmlDocument","tags","document","getElementsByTagName","indexOf","replace","xhr","XMLHttpRequest","open","send","status","Error","Function","responseText","callSuper","self","meta","info","$qmlTypeInfo","prototype","constructor","call","enums","Object","keys","forEach","properties","desc","createProperty","defaultProperty","construct","component","constructors","perImportContextConstructors","context","importContextId","classComponents","object","split","ci","c","qdirInfo","engine","qmldirs","oldExecutionContext","_executionContext","Qt","createComponent","url","filePath","qualifiedImportPath","createObject","parent","dom","className","id","setupGetterSetter","$context","$basePath","applyProperties","obj","getter","setter","options","arguments","prop","QMLProperty","changed","$properties","set","initialValue","ReasonInit","get","readOnly","newVal","$canEditReadOnlyProperties","ReasonUser","$isComponentRoot","setupGetter","func","defineProperty","configurable","enumerable","connectSignal","signalName","objectScope","componentScope","warn","connect","eval","j","isFunction","compile","slot","metaObject","toUpperCase","Signal","reason","con","targetProp","loopWatchdog","error","pendingOperations","$setCustomData","toLowerCase","$setCustomSlot","QMLColor","Math","round","toString","substr","m","QMLInteger","QMLList","list","Array","pushEvalStack","evaluatingPropertyStackOfStacks","evaluatingPropertyStack","evaluatingProperty","popEvalStack","pop","pushEvaluatingProperty","popEvaluatingProperty","QMLVariant","QObject","$parent","$tidyupList","objectId","objectIds","$delete","$Component","destruction","disconnect","splice","destroy","updateHGeometry","oldVal","anchors","$updatingHGeometry","t","w","width","x","left","hC","right","lM","leftMargin","margins","rM","rightMargin","$isUsingImplicitWidth","implicitWidth","fill","isConnected","centerIn","horizontalCenter","u","updateChildrenRect","updateVGeometry","$updatingVGeometry","height","y","top","vC","bottom","tM","topMargin","bM","bottomMargin","$isUsingImplicitHeight","implicitHeight","verticalCenter","children","child","maxWidth","maxHeight","minX","minY","max","heighth","min","childrenRect","QMLDomElement","tagName","createElement","QMLContext","nameForObject","QMLComponent","$metaObject","jsImports","finalizeImports","js","importDesc","qrc","qmlweb_jsparse","getUrlContents","importJavascriptInContext","bind","moduleImports","loadImport","test","loadImports","QMLBaseObject","isComponentRoot","attributes","key","hasOwnProperty","__proto__","Keys","asteriskPresed","backPressed","backtabPressed","callPressed","cancelPressed","deletePressed","escapePressed","flipPressed","hangupPressed","leftPressed","menuPressed","noPressed","pressed","released","returnPressed","rightPressed","selectPressed","spacePressed","tabPressed","upPressed","volumeDownPressed","volumeUpPressed","yesPressed","getAttributes","QMLButton","_this2","button","impl","style","pointerEvents","appendChild","clicked","Component","completed","offsetWidth","offsetHeight","textChanged","textContent","enabledChanged","disabled","onclick","QMLComboBox","count","currentIndex","currentText","menu","model","updateCB","head","tail","html","elt","accepted","activated","find","text","selectAll","textAt","index","innerHTML","firstChild","modelChanged","e","selectedIndex","QMLScrollView","css","setupFocusOnDom","contentItemChanged","newItem","_typeof","flickableItemChanged","viewportChanged","newViewport","frameVisibleChanged","visible","border","highlightOnFocusChanged","highlight","horizontalScrollBarPolicyChanged","newPolicy","overflowX","scrollBarPolicyToCssOverflow","verticalScrollBarPolicyChanged","overflowY","styleChanged","newStyle","childrenChanged","contentItem","focusChanged","focus","outline","flickableItem","viewport","frameVisible","highlightOnFocus","verticalScrollBarPolicy","ScrollBarAsNeeded","horizontalScrollBarPolicy","QMLTextArea","textarea","padding","borderWidth","backgroundColor","QMLTextInput","testValidator","validator","validate","updateValue","QMLFont","getConstructor","font","input","margin","maximumLength","echoModeChanged","TextField","Normal","Password","maximumLengthChanged","maxLength","readOnlyChanged","Key_Return","Key_Enter","oninput","onpropertychanged","QMLScreen","updateSC","desktopAvailableHeight","window","outerHeight","desktopAvailableWidth","outerWidth","devicePixelRatio","innerHeight","orientation","PrimaryOrientation","orientationUpdateMask","pixelDensity","primaryOrientation","innerWidth","QMLColumn","QMLFlow","Flow","LeftToRight","TopToBottom","flowChanged","layoutChildren","layoutDirectionChanged","widthChanged","QMLGrid","Grid","columnsChanged","rowsChanged","QMLImage","img","Image","Stretch","PreserveAspectFit","PreserveAspectCrop","Tile","TileVertically","TileHorizontally","Null","Ready","Loading","sourceSize","bg","onload","naturalWidth","h","naturalHeight","progress","onerror","updateFillMode","fillMode","backgroundRepeat","backgroundSize","backgroundPosition","updateMirroring","transformRule","transform","$updateTransform","sourceChanged","backgroundImage","$resolvePath","complete","mirrorChanged","fillModeChanged","QMLItem","rootElement","body","position","overflow","boxSizing","parentChanged","newParent","oldParent","removeChild","dataChanged","newData","resources","xChanged","yChanged","heightChanged","implicitWidthChanged","implicitHeightChanged","element","updateFocus","hasFocus","activeElement","addEventListener","qmlFocus","activeFocus","rootContext","base","leftChanged","rightChanged","topChanged","bottomChanged","horizontalCenterChanged","verticalCenterChanged","fillChanged","centerInChanged","leftMarginChanged","rightMarginChanged","topMarginChanged","bottomMarginChanged","marginsChanged","stateChanged","oldState","newState","k","states","actions","$revertActions","action","from","target","changes","$getAllChanges","change","$actions","origValue","to","explicit","found","restoreEntryValues","transition","rating","transitions","$stop","curTransition","curRating","reversible","$start","QMLRotation","QMLScale","QMLTranslate","rotation","scale","filter","transformStyle","axis","z","angle","xScale","yScale","transformType","operation","MozTransform","webkitTransform","webkitTransformStyle","OTransform","msTransform","msFilter","webkitFilter","MozFilter","rotationChanged","scaleChanged","transformChanged","visibleChanged","visibility","clipChanged","zChanged","$calculateOpacity","opacityChanged","$opacityChanged","spacing","updateQmlGeometry","QMLPositioner","spacingChanged","slotChildrenChanged","QMLPropertyChanges","QMLRectangle","borderStyle","borderColor","colorChanged","radiusChanged","borderRadius","$updateBorder","QMLRepeater","callOnCompleted","insertChildren","startIndex","endIndex","QMLListModel","$model","delegate","roleNames","roleName","data","$items","operationState","QMLOperationState","Init","Idle","$initializePropertyBindings","container","onModelDataChanged","roles","onRowsMoved","sourceStartIndex","sourceEndIndex","destinationIndex","vals","smallestChangedIndex","onRowsRemoved","removeChildren","onModelReset","applyModel","JSItemModel","rowsInserted","rowsMoved","rowsRemoved","modelReset","rowCount","removed","removeChildProperties","completedSignals","$completed","_childrenInserted","delegateChanged","itemAt","QMLRow","QMLTextEdit","updateCss","supported","child_style","n","o","v","lineCount","getLineCount","activeFocusOnPress","baseUrl","canPaste","canRedo","canUndo","color","contentHeight","contentWidth","cursorDelegate","cursorPosition","cursorRectangle","cursorVisible","effectiveHorizontalAlignment","horizontalAlignment","hoveredLink","inputMethodComposing","inputMethodHints","mouseSelectionMode","persistentSelection","renderType","selectByKeyboard","selectByMouse","selectedText","selectedTextColor","selectionColor","selectionEnd","selectionStart","textDocument","textFormat","textMargin","verticalAlignment","wrapMode","undoStack","undoStackPosition","redoStack","redoStackPosition","background","resize","linkActivated","linkHovered","append","copy","cut","deselect","getFormattedText","start","end","getText","insert","isRightToLeft","linkAt","moveCursorSelection","paste","positionAt","positionToRectangle","redo","remove","select","selectWord","undo","Symbol","iterator","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","deps","JSON","stringify","skipExceptions","urlContentCache","readQmlDir","makeurl","path","qmldirFileUrl","lines","line","match","qmldir","internals","externals","version","int","real","Number","double","bool","Boolean","enum","variant","var","modules","Main","dependants","registerGlobalQmlType","registerQmlType","baseClass","baseModule","baseName","dot","lastIndexOf","module","substring","descr","baseId","join","versions","moduleDescriptor","inherit","opt","moduleName","collectConstructorsForModule","mergeObjects","obj1","obj2","mergedObject","importContextIds","row","moduleVersion","moduleAlias","moduleConstructors","oldProto","create","getOwnPropertyNames","setRoleNames","names","metaTags","metaTag","source","getAttribute","qmlEngine","QMLEngine","loadFile","jsData","exports","map","sym","keyCodeToQt","keypad","keyCode","Key_Tab","shiftKey","Key_Backtab","Key_A","eventToKeyboard","isAutoRepeat","modifiers","ctrlKey","CtrlModifier","altKey","AltModifier","ShiftModifier","metaKey","MetaModifier","KeypadModifier","fromCharCode","charCode","tick","now","Date","getTime","elapsed","lastTick","tickers","fps","$interval","floor","running","components","bindedProperties","rootObject","Running","tickerId","setInterval","whenStart","stop","clearInterval","whenStop","ensureFileIsLoadedInQrc","QMLDocument","extractBasePath","basePath","parentComponent","loadQMLTree","loadQML","debugTree","$file","callCompletedSignals","removeDotSegments","leadingSlash","segments","out","pos","segment","importsArray","currentFileDir","qmldirsContents","entry","nameIsUrl","nameIsQualifiedModuleName","nameIsDir","content","userAddedModulePaths","probableDirs","concat","importPathList","diredName","attrname","addQualifiedImportPath","addImportPath","focusedElement","keyboardSignals","Key_Asterisk","Key_Back","Key_Call","Key_Cancel","Key_Delete","Key_0","Key_1","Key_2","Key_3","Key_4","Key_5","Key_6","Key_7","Key_8","Key_9","Key_Escape","Key_Flip","Key_Hangup","Key_Menu","Key_No","Key_Select","Key_Space","Key_VolumeDown","Key_VolumeUp","Key_Yes","Key_Up","Key_Right","Key_Down","Key_Left","onkeypress","event","eventName","backup","preventDefault","onkeyup","registerProperty","dependantProperties","update","dirpath","userAddedImportPaths","moduleQualifier","qualifiedImportPaths","importPathsForContext","setImportPathList","arrayOfDirs","addModulePath","dirPath","loadComponent","shift","needsUpdate","$initializeAliasSignals","op","$registerStart","f","$registerStop","$addTicker","$removeTicker","size","getWidth","getHeight","debugConsole","args","getAttachedObject","handler","animation","ReasonAnimation","restart","typeInitialValues","_QMLComponent","$syncPropertyToRemote","connectedSlots","signal","thisObj","err","message","$connectNotify","callType","$disconnectNotify","sendToServer","method","generateBodyForPostQuery","ajax","mimeType","queryMimeType","success","xhrReadResponse","saved","objectToUrlEncoded","myEncodeURIComponent","str","encodeURIComponent","charCodeAt","prefix","overrideMimeType","onreadystatechange","readyState","DONE","failure","runningRequests","isLoading","setRequestHeader","responseObject","parse","updatePropertiesFromResponseObject","$hasProperty","fetched","fetch","mimetype","save","localStorage","getKey","attrName","category","loadProperties","getItem","initializeProperties","emitter","setItem","stripEffectFromSource","previousSource","filterObject","updateEffect","updateFilterObject","radius","navigator","geolocation","getCurrentPosition","updatePosition","accuracy","coords","altitude","altitudeAccuracy","heading","latitude","longitude","speed","timestamp","watchPosition","MediaPlayer","NoError","ResourceError","FormatError","NetworkError","AccessDenied","ServiceMissing","StoppedState","PlayingState","PausedState","NoMedia","Loaded","Buffering","Stalled","EndOfMedia","InvalidMedia","UnknownStatus","VideoOutput","volumeBackup","runningEventListener","domVideo","volume","duration","playbackState","muted","paused","playing","stopped","autoPlayChanged","autoplay","currentTime","buffered","Buffered","demoVideo","playbackRate","pause","play","seek","offset","mimetypeFromExtension","extension","mimetypes","ogg","ogv","ogm","mp4","webm","parts","canPlayType","positionChanged","volumeChanged","playbackRateChanged","mutedChanged","newValue","volulmeBackup","objectFit","bp","ignoreUnknownSignals","_class","_this","$connections","old_target","reconnectTarget","_currentConnection","targetChanged","rgba","r","g","b","hsla","s","l","openUrlExternally","page","origName","moredirs","createQmlObject","resolvedUrl","detectedBasePath","currentCaller","caller","maxcount","LeftButton","RightButton","MiddleButton","NoModifier","ControlModifier","RightToLeft","Vertical","Horizontal","Key_Backspace","Key_Insert","Key_Pause","Key_Print","Key_SysReq","Key_Clear","Key_Home","Key_End","Key_PageUp","Key_PageDown","Key_Shift","Key_Control","Key_Meta","Key_Alt","Key_AltGr","Key_CapsLock","Key_NumLock","Key_ScrollLock","Key_F1","Key_F2","Key_F3","Key_F4","Key_F5","Key_F6","Key_F7","Key_F8","Key_F9","Key_F10","Key_F11","Key_F12","Key_F13","Key_F14","Key_F15","Key_F16","Key_F17","Key_F18","Key_F19","Key_F20","Key_F21","Key_F22","Key_F23","Key_F24","Key_F25","Key_F26","Key_F27","Key_F28","Key_F29","Key_F30","Key_F31","Key_F32","Key_F33","Key_F34","Key_F35","Key_Super_L","Key_Super_R","Key_Hyper_L","Key_Hyper_R","Key_Help","Key_Direction_L","Key_Direction_R","Key_Any","Key_Exclam","Key_QuoteDbl","Key_NumberSign","Key_Dollar","Key_Percent","Key_Ampersant","Key_Apostrophe","Key_ParenLeft","Key_ParenRight","Key_Plus","Key_Comma","Key_Minus","Key_Period","Key_Slash","Key_Colon","Key_Semicolon","Key_Less","Key_Equal","Key_Greater","Key_Question","Key_At","Key_B","Key_C","Key_D","Key_E","Key_F","Key_G","Key_H","Key_I","Key_J","Key_K","Key_L","Key_M","Key_N","Key_O","Key_P","Key_Q","Key_R","Key_S","Key_T","Key_U","Key_V","Key_W","Key_X","Key_Y","Key_Z","Key_BracketLeft","Key_Backslash","Key_BracketRight","Key_AsciiCircum","Key_Underscore","Key_QuoteLeft","Key_BraceLeft","Key_Bar","Key_BraceRight","Key_AsciiTilde","Key_Forward","Key_Stop","Key_VolumeMute","Key_multiply","Key_add","Key_substract","Key_divide","Key_News","Key_OfficeHome","Key_Option","Key_Paste","Key_Phone","Key_Calendar","Key_Reply","Key_Reload","Key_RotateWindows","Key_RotationPB","Key_RotationKB","Key_Save","Key_Send","Key_Spell","Key_SplitScreen","Key_Support","Key_TaskPane","Key_Terminal","Key_Tools","Key_Travel","Key_Video","Key_Word","Key_Xfer","Key_ZoomIn","Key_ZoomOut","Key_Away","Key_Messenger","Key_WebCam","Key_MailForward","Key_Pictures","Key_Music","Key_Battery","Key_Bluetooth","Key_WLAN","Key_UWB","Key_AudioForward","Key_AudioRepeat","Key_AudioRandomPlay","Key_Subtitle","Key_AudioCycleTrack","Key_Time","Key_Hibernate","Key_View","Key_TopMenu","Key_PowerDown","Key_Suspend","Key_ContrastAdjust","Key_MediaLast","Key_unknown","Key_Camera","Key_CameraFocus","Key_Context1","Key_Context2","Key_Context3","Key_Context4","Key_ToggleCallHangup","Key_VoiceDial","Key_LastNumberRedial","Key_Execute","Key_Printer","Key_Play","Key_Sleep","Key_Zoom","AlignLeft","AlignRight","AlignHCenter","AlignJustify","AlignTop","AlignBottom","AlignVCenter","AlignCenter","AlignBaseline","AlignAbsolute","AlignLeading","AlignTrailing","AlignHorizontal_Mask","AlignVertical_Mask","PortraitOrientation","LandscapeOrientation","InvertedPortraitOrientation","InvertedLandscapeOrientation","ArrowCursor","UpArrowCursor","CrossCursor","WaitCursor","IBeamCursor","SizeVerCursor","SizeHorCursor","SizeBDiagCursor","SizeFDiagCursor","SizeAllCursor","BlankCursor","SplitVCursor","SplitHCursor","PointingHandCursor","ForbiddenCursor","WhatsThisCursor","BusyCursor","OpenHandCursor","ClosedHandCursor","DragCopyCursor","DragMoveCursor","DragLinkCursor","LastCursor","BitmapCursor","CustomCursor","ScrollBarAlwaysOff","ScrollBarAlwaysOn","ticker","prevTrigger","interval","trigger","repeat","triggered","runningChanged","triggeredOnStart","label","checkbox","verticalAlign","span","checkedChanged","checked","onchange","policy","Animation","Infinite","alwaysRunToEnd","loops","_class2","animationChanged","updateBorder","MozBorderImageSource","MozBorderImageSlice","MozBorderImageRepeat","horizontalTileMode","verticalTileMode","MozBorderImageWidth","webkitBorderImageSource","webkitBorderImageSlice","webkitBorderImageRepeat","webkitBorderImageWidth","OBorderImageSource","OBorderImageSlice","OBorderImageRepeat","OBorderImageWidth","borderImageSlice","borderImageRepeat","borderImageWidth","BorderImage","Repeat","Round","borderImageSource","horizontalTileModeChanged","verticalTileModeChanged","available","canvasSize","canvasWindow","contextType","renderStrategy","renderTarget","tileSize","imageLoaded","paint","painted","cancelRequestAnimationFrame","handle","getContext","context_id","isImageError","image","isImageLoaded","isImageLoading","loadImage","markDirty","area","requestAnimationFrame","callback","requestPaint","file_name","toDataURL","mime_type","unloadImage","curPos","DoubleValidator","StandardNotation","ScientificNotation","getDecimalsForNumber","number","exec","Infinity","decimals","notation","standardRegExp","scientificRegExp","getRegExpForNotation","regExp","acceptable","trim","parseFloat","Easing","Linear","InQuad","OutQuad","InOutQuad","OutInQuad","InCubic","OutCubic","InOutCubic","OutInCubic","InQuart","OutQuart","InOutQuart","OutInQuart","InQuint","OutQuint","InOutQuint","OutInQuint","InSine","OutSine","InOutSine","OutInSine","InExpo","OutExpo","InOutExpo","OutInExpo","InCirc","OutCirc","InOutCirc","OutInCirc","InElastic","OutElastic","InOutElastic","OutInElastic","InBack","OutBack","InOutBack","OutInBack","InBounce","OutBounce","InOutBounce","OutInBounce","curHPos","curVPos","rowSize","flow","layoutDirection","_this3","sizeLock","boldChanged","fontWeight","weight","capitalizationChanged","fontVariant","textTransform","familyChanged","fontFamily","italicChanged","fontStyle","letterSpacingChanged","letterSpacing","pixelSizeChanged","pointSize","fontSize","pointSizeChanged","pixelSize","strikeoutChanged","textDecoration","underline","underlineChanged","strikeout","weightChanged","bold","wordSpacingChanged","wordSpacing","Font","MixedCase","AllUppercase","AllLowercase","SmallCaps","Capitalize","Light","DemiBold","Bold","Black","cycleTouchName","fontName","lastName","inTouchName","timeouts","setTimeout","loadFont","FontLoader","fontLoader","fontsLoaded","notLoadedFontFamilies","fontLoaded","testDiv","loadFonts","domStyle","font_src","random","nameChanged","visibleItems","colWidth","rowHeight","gridWidth","gridHeight","columns","rows","ceil","step","startingPoint","endPoint","parseInt","parentOpacity","$opacity","opacity","state","clip","firstItem","QMLListElement","$itemsChanged","dict","role","clear","move","setProperty","applyStyleOnItem","$item","display","orientationChanged","createComponentObject","qmlComponent","newComponent","_this4","sourceUrl","loaded","activeChanged","active","sourceComponent","sourceComponentChanged","unload","fileName","loadedComponent","updateGeometry","setSource","eventToMouse","offsetX","layerX","offsetY","layerY","handleClick","mouse","enabled","acceptedButtons","cursorShapeToCSS","cursorShape","entered","exited","oncontextmenu","onmousedown","mouseX","mouseY","pressedButtons","onmouseup","onmouseover","containsMouse","onmouseout","onmousemove","hoverEnabled","cursorShapeChanged","cursor","loop","at","$redoActions","easing","$valueForProgress","startLoop","animationFinished","$runningAnimations","animationsChanged","animations","redoProperties","$props","matches","redoTargets","$targets","targets","pow","cos","PI","sin","sqrt","amplitude","period","asin","overshoot","targetsChanged","propertyChanged","propertiesChanged","newBorderWidth","topBottom","leftRight","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","updateOrigin","transformOrigin","origin","MozTransformOrigin","webkitTransformOrigin","angleChanged","_this5","xScaleChanged","yScaleChanged","nextAnimation","proceed","anim","curIndex","passedLoops","whenChanged","extend","SystemPalette","Active","Inactive","Disabled","platformsDetectors","regexp","systemPalettes","attrs","platform","colorGroupChanged","userAgent","platforms","alternateBase","buttonText","dark","highlightText","light","mid","midlight","shadow","windowText","inactive","updateImplicit","fc","implicitHeigh","Text","NoWrap","WordWrap","WrapAnywhere","Wrap","WrapAtWordBoundaryOrAnywhere","Outline","Raised","Sunken","lineHeightChanged","lineHeight","wrapModeChanged","whiteSpace","wordWrap","wordBreak","horizontalAlignmentChanged","textAlign","textShadow","styleColor","styleColorChanged","family","TextInput","NoEcho","PasswordEchoOnEdit","connectSocket","reconnect","WebSocket","Connecting","socket","onopen","Open","onclose","Closed","errorString","onmessage","textMessageReceived","reconnectSocket","Closing","close","sendTextMessage","statusChanged","urlChanged"],"mappings":"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","file":"qt.min.js","sourcesContent":[";(function(global) {\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QMLBinding = function () {\n    /**\n     * Create QML binding.\n     * @param {Variant} val Sourcecode or function representing the binding\n     * @param {Array} tree Parser tree of the binding\n     * @return {Object} Object representing the binding\n     */\n\n    function QMLBinding(val, tree) {\n        _classCallCheck(this, QMLBinding);\n\n        // this.isFunction states whether the binding is a simple js statement or a function containing\n        // a return statement. We decide this on whether it is a code block or not. If it is, we require\n        // a return statement. If it is a code block it could though also be a object definition, so we\n        // need to check that as well (it is, if the content is labels).\n        // need to check that as well (it is, if the content is labels).\n        this.isFunction = tree && tree[0] == \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\n        this.src = val;\n    }\n\n    _createClass(QMLBinding, [{\n        key: \"toJSON\",\n        value: function toJSON() {\n            return { src: this.src,\n                deps: JSON.stringify(this.deps),\n                tree: JSON.stringify(this.tree) };\n        }\n\n        /**\n         * Compile binding. Afterwards you may call binding.eval to evaluate.\n         */\n\n    }, {\n        key: \"compile\",\n        value: function compile() {\n            this.eval = new Function('__executionObject', '__executionContext', \"_executionContext = __executionContext; with(__executionContext) with(__executionObject) \" + (this.isFunction ? \"\" : \"return \") + this.src);\n        }\n    }]);\n\n    return QMLBinding;\n}();\n\nglobal.QMLBinding = QMLBinding;\n\n/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nQMLMethod.prototype = new QMLBinding();\nfunction QMLMethod(src) {\n    this.src = src;\n}\n\n/**\n * Create an object representing a QML property definition.\n * @param {String} type The type of the property\n * @param {Array} value The default value of the property\n * @return {Object} Object representing the defintion\n */\nfunction QMLPropertyDefinition(type, value) {\n    this.type = type;\n    this.value = value;\n}\n\nfunction QMLAliasDefinition(objName, propName) {\n    this.objectName = objName;\n    this.propertyName = propName;\n}\n\n/**\n * Create an object representing a QML signal definition.\n * @param {Array} params The parameters the signal ships\n * @return {Object} Object representing the defintion\n */\nfunction QMLSignalDefinition(params) {\n    this.parameters = params;\n}\n\n/**\n * Create an object representing a group of QML properties (like anchors).\n * @return {Object} Object representing the group\n */\nfunction QMLMetaPropertyGroup() {}\n\n/**\n * Create an object representing a QML element.\n * @param {String} type The type of the element\n * @param {String} onProp The name of the property specified with the \"on\" keyword\n */\nfunction QMLMetaElement(type, onProp) {\n    this.$class = type;\n    this.$children = [];\n    this.$on = onProp;\n}\n\n// Convert parser tree to the format understood by engine\nfunction convertToEngine(tree) {\n\n    // Help logger\n    function amIn(str, tree) {\n        console.log(str);\n        if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n    }\n\n    var walkers = {\n        \"toplevel\": function toplevel(imports, statement) {\n            var item = { $class: \"Component\" };\n            item.$imports = imports;\n            item.$children = [walk(statement)];\n            return item;\n        },\n        \"qmlelem\": function qmlelem(elem, onProp, statements) {\n            var item = new QMLMetaElement(elem, onProp);\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                switch (statement[0]) {\n                    case \"qmldefaultprop\":\n                        item.$defaultProperty = name;\n                    case \"qmlprop\":\n                    case \"qmlpropdef\":\n                    case \"qmlaliasdef\":\n                    case \"qmlmethod\":\n                    case \"qmlsignaldef\":\n                        item[name] = val;\n                        break;\n                    case \"qmlelem\":\n                        item.$children.push(val);\n                        break;\n                    case \"qmlobjdef\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        item[name][statement[2]] = val;\n                        break;\n                    case \"qmlobj\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        for (var i in val) {\n                            item[name][i] = val[i];\n                        }break;\n                    default:\n                        console.log(\"Unknown statement\", statement);\n\n                }\n            }\n            // Make $children be either a single item or an array, if it's more than one\n            if (item.$children.length === 1) item.$children = item.$children[0];\n\n            return item;\n        },\n        \"qmlprop\": function qmlprop(name, tree, src) {\n            if (name == \"id\") {\n                // id property\n                return tree[1][1];\n            }\n            return bindout(tree, src);\n        },\n        \"qmlobjdef\": function qmlobjdef(name, property, tree, src) {\n            return bindout(tree, src);\n        },\n        \"qmlobj\": function qmlobj(elem, statements) {\n            var item = {};\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                if (statement[0] == \"qmlprop\") item[name] = val;\n            }\n\n            return item;\n        },\n        \"qmlmethod\": function qmlmethod(name, tree, src) {\n            return new QMLMethod(src);\n        },\n        \"qmlpropdef\": function qmlpropdef(name, type, tree, src) {\n            return new QMLPropertyDefinition(type, tree ? bindout(tree, src) : undefined);\n        },\n        \"qmlaliasdef\": function qmlaliasdef(name, objName, propName) {\n            return new QMLAliasDefinition(objName, propName);\n        },\n        \"qmlsignaldef\": function qmlsignaldef(name, params) {\n            return new QMLSignalDefinition(params);\n        },\n        \"qmldefaultprop\": function qmldefaultprop(tree) {\n            return walk(tree);\n        },\n        \"name\": function name(src) {\n            if (src == \"true\" || src == \"false\") return src == \"true\";\n            return new QMLBinding(src, [\"name\", src]);\n        },\n        \"num\": function num(src) {\n            return +src;\n        },\n        \"string\": function string(src) {\n            return String(src);\n        },\n        \"array\": function array(tree, src) {\n            var a = [];\n            var isList = false;\n            var hasBinding = false;\n            for (var i in tree) {\n                var val = bindout(tree[i]);\n                a.push(val);\n\n                if (val instanceof QMLMetaElement) isList = true;else if (val instanceof QMLBinding) hasBinding = true;\n            }\n\n            if (hasBinding) {\n                if (isList) throw new TypeError(\"An array may either contain bindings or Element definitions.\");\n                return new QMLBinding(src, tree);\n            }\n\n            return a;\n        }\n    };\n\n    function walk(tree) {\n        var type = tree[0];\n        var walker = walkers[type];\n        if (!walker) {\n            console.log(\"No walker for \" + type);\n            return;\n        } else {\n            return walker.apply(type, tree.slice(1));\n        }\n    }\n\n    return walk(tree);\n\n    // Try to bind out tree and return static variable instead of binding\n    function bindout(tree, binding) {\n        if (tree[0] === \"stat\") // We want to process the content of the statement\n            tree = tree[1]; // (but still handle the case, we get the content directly)\n        var type = tree[0];\n        var walker = walkers[type];\n        if (walker) {\n            return walker.apply(type, tree.slice(1));\n        } else {\n            return new QMLBinding(binding, tree);\n        }\n    }\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n    loadParser();\n    qmlweb_parse.nowParsingFile = file;\n    var parsetree = qmlweb_parse(src, qmlweb_parse.QmlDocument);\n    return convertToEngine(parsetree);\n}\n\nfunction loadParser() {\n    if (typeof qmlweb_parse !== 'undefined') return;\n\n    console.log('Loading parser...');\n    var tags = document.getElementsByTagName('script');\n    for (var i in tags) {\n        if (tags[i].src && tags[i].src.indexOf('/qt.') !== -1) {\n            var src = tags[i].src.replace('/qt.', '/qmlweb.parser.');\n            // TODO: rewrite to async loading\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', src, false);\n            xhr.send(null);\n            if (xhr.status !== 200 && xhr.status !== 0) {\n                // 0 if accessing with file://\n                throw new Error('Could not load QmlWeb parser!');\n            }\n            new Function(xhr.responseText)();\n            return;\n        }\n    }\n}\n\n/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\n                                                         import implementation.\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * Get URL contents. EXPORTED.\n * @param url {String} Url to fetch.\n * @param skipExceptions {bool} when turned on, ignore exeptions and return false. This feature is used by readQmlDir.\n * @private\n * @return {mixed} String of contents or false in errors.\n */\ngetUrlContents = function getUrlContents(url, skipExceptions) {\n    if (typeof urlContentCache[url] == 'undefined') {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, false);\n\n        if (skipExceptions) {\n            try {\n                xhr.send(null);\n            } catch (e) {\n                return false;\n            }\n        } /* it is OK to not have logging here, because DeveloperTools already will have red log record */\n        else xhr.send(null);\n\n        if (xhr.status != 200 && xhr.status != 0) {\n            // 0 if accessing with file://\n            console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\n            return false;\n        }\n        urlContentCache[url] = xhr.responseText;\n    }\n    return urlContentCache[url];\n};\nif (typeof global.urlContentCache == 'undefined') global.urlContentCache = {};\n\n/**\n * Read qmldir spec file at directory. EXPORTED.\n * @param url Url of the directory\n * @return {Object} Object, where .internals lists qmldir internal references\n *                          and .externals lists qmldir external references.\n */\n\n/*  Note on how importing works.\n\n   * parseQML gives us `tree.$imports` variable, which contains information from `import` statements.\n\n   * After each call to parseQML, we call engine.loadImports(tree.$imports).\n     It in turn invokes readQmlDir() calls for each import, with respect to current component base path and engine.importPathList().\n\n   * We keep all component names from all qmldir files in global variable `engine.qmldir`.\n   \n   * In construct() function, we use `engine.qmldir` for component url lookup.\n\n   Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html \n   Also please look at notes and TODO's in qtcore.js::loadImports() and qtcore.js::construct() methods.\n*/\n\nreadQmlDir = function readQmlDir(url) {\n    // in case 'url' is empty, do not attach \"/\"\n    // Q1: when this happen?\n    var qmldirFileUrl = url.length > 0 ? url + \"/qmldir\" : \"qmldir\";\n\n    if (!qrc.hasOwnProperty(qmldirFileUrl)) qrc[qmldirFileUrl] = getUrlContents(qmldirFileUrl, true); // loading url contents with skipping errors\n    var qmldir = qrc[qmldirFileUrl],\n        lines,\n        line,\n        internals = {},\n        externals = {},\n        match,\n        i;\n\n    if (qmldir === false) {\n        return false;\n    }\n\n    // we have to check for \"://\"\n    // In that case, item path is meant to be absolute, and we have no need to prefix it with base url\n    function makeurl(path) {\n        if (path.indexOf(\"://\") > 0) return path;\n        return url + \"/\" + path;\n    }\n\n    lines = qmldir.split(/\\r?\\n/);\n    for (i = 0; i < lines.length; i++) {\n        // trim\n        line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n        if (!line.length || line[0] == \"#\") {\n            // Empty line or comment\n            continue;\n        }\n        match = line.split(/\\s+/);\n        if (match.length == 2 || match.length == 3) {\n            if (match[0] == \"plugin\") {\n                console.log(url + \": qmldir plugins are not supported!\");\n            } else if (match[0] == \"internal\") {\n                internals[match[1]] = { url: makeurl(match[2]) };\n            } else {\n                if (match.length == 2) {\n                    externals[match[0]] = { url: makeurl(match[1]) };\n                } else {\n                    externals[match[0]] = { url: makeurl(match[2]), version: match[1] };\n                }\n            }\n        } else {\n            console.log(url + \": unmatched: \" + line);\n        }\n    }\n    return { internals: internals, externals: externals };\n};\n\n// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\nvar evaluatingProperty;\nvar evaluatingPropertyStack = [];\nvar evaluatingPropertyPaused = false;\nvar evaluatingPropertyStackOfStacks = [];\n\nvar _executionContext = null;\n\n// All object constructors\nvar constructors = {\n    'int': QMLInteger,\n    real: Number,\n    'double': Number,\n    string: String,\n    'bool': Boolean,\n    list: QMLList,\n    color: QMLColor,\n    'enum': Number,\n    url: String,\n    variant: QMLVariant,\n    'var': QMLVariant\n};\n\nvar modules = {\n    Main: constructors\n};\n\nvar dependants = {};\n\n// Helper. Adds a type to the constructor list\nglobal.registerGlobalQmlType = function (name, type) {\n    global[type.name] = type;\n    constructors[name] = type;\n    modules.Main[name] = type;\n};\n\n// Helper. Register a type to a module\nglobal.registerQmlType = function (options, constructor) {\n    if (constructor !== undefined) {\n        options.constructor = constructor;\n    }\n\n    if (typeof options.baseClass === 'string') {\n        // TODO: Does not support version specification (yet?)\n        var baseModule, baseName;\n        var dot = options.baseClass.lastIndexOf('.');\n        if (dot === -1) {\n            baseModule = options.module;\n            baseName = options.baseClass;\n        } else {\n            baseModule = options.baseClass.substring(0, dot);\n            baseName = options.baseClass.substring(dot + 1);\n        }\n        var found = (modules[baseModule] || []).filter(function (descr) {\n            return descr.name === baseName;\n        });\n        if (found.length > 0) {\n            // Ok, we found our base class\n            options.baseClass = found[0].constructor;\n        } else {\n            // Base class not found, delay the loading\n            var baseId = [baseModule, baseName].join('.');\n            if (!dependants.hasOwnProperty(baseId)) {\n                dependants[baseId] = [];\n            }\n            dependants[baseId].push(options);\n            return;\n        }\n    }\n\n    if (typeof options === 'function') {\n        options = {\n            module: options.module,\n            name: options.element,\n            versions: options.versions,\n            baseClass: options.baseClass,\n            enums: options.enums,\n            properties: options.properties,\n            constructor: options\n        };\n    };\n\n    options.constructor.$qmlTypeInfo = {\n        enums: options.enums,\n        defaultProperty: options.defaultProperty,\n        properties: options.properties\n    };\n\n    if (options.global) {\n        registerGlobalQmlType(options.name, options.constructor);\n    }\n\n    var moduleDescriptor = {\n        name: options.name,\n        versions: options.versions,\n        constructor: options.constructor\n    };\n\n    if (typeof modules[options.module] == 'undefined') modules[options.module] = [];\n    modules[options.module].push(moduleDescriptor);\n\n    if (typeof options.baseClass !== 'undefined') {\n        inherit(options.constructor, options.baseClass);\n    }\n\n    var id = [options.module, options.name].join('.');\n    if (dependants.hasOwnProperty(id)) {\n        dependants[id].forEach(function (opt) {\n            return global.registerQmlType(opt);\n        });\n        dependants[id].length = 0;\n    }\n};\n\nglobal.getConstructor = function (moduleName, version, name) {\n    if (typeof modules[moduleName] != 'undefined') {\n        for (var i = 0; i < modules[moduleName].length; ++i) {\n            var type = modules[moduleName][i];\n\n            if (type.name == name && type.versions.test(version)) return type.constructor;\n        }\n    }\n    return null;\n};\n\nglobal.collectConstructorsForModule = function (moduleName, version) {\n    var constructors = {};\n\n    if (typeof modules[moduleName] == 'undefined') {\n        console.warn(\"module `\" + moduleName + \"` not found\");\n        return constructors;\n    }\n    for (var i = 0; i < modules[moduleName].length; ++i) {\n        var module = modules[moduleName][i];\n\n        if (module.versions.test(version)) {\n            constructors[module.name] = module.constructor;\n        }\n    }\n    return constructors;\n};\n\nglobal.mergeObjects = function (obj1, obj2) {\n    var mergedObject = {};\n\n    if (typeof obj1 != 'undefined' && obj1 != null) {\n        for (var key in obj1) {\n            mergedObject[key] = obj1[key];\n        }\n    }\n    if (typeof obj2 != 'undefined' && obj2 != null) {\n        for (var key in obj2) {\n            mergedObject[key] = obj2[key];\n        }\n    }\n    return mergedObject;\n};\n\nvar importContextIds = 0;\nglobal.perImportContextConstructors = {};\n\nglobal.loadImports = function (self, imports) {\n    constructors = mergeObjects(modules.Main, null);\n    if (imports.filter(function (row) {\n        return row[1] === 'QtQml';\n    }).length === 0 && imports.filter(function (row) {\n        return row[1] === 'QtQuick';\n    }).length === 1) {\n        imports.push(['qmlimport', 'QtQml', 2, '', true]);\n    }\n    for (var i = 0; i < imports.length; ++i) {\n        var moduleName = imports[i][1],\n            moduleVersion = imports[i][2],\n            moduleAlias = imports[i][3],\n            moduleConstructors = collectConstructorsForModule(moduleName, moduleVersion);\n\n        if (moduleAlias !== \"\") constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);else constructors = mergeObjects(constructors, moduleConstructors);\n    }\n    self.importContextId = importContextIds++;\n    perImportContextConstructors[self.importContextId] = constructors;\n};\n\nglobal.inherit = function (constructor, baseClass) {\n    var oldProto = constructor.prototype;\n    constructor.prototype = Object.create(baseClass.prototype);\n    Object.getOwnPropertyNames(oldProto).forEach(function (prop) {\n        constructor.prototype[prop] = oldProto[prop];\n    });\n    constructor.prototype.constructor = baseClass;\n};\n\nfunction callSuper(self, meta) {\n    var info = meta.super.$qmlTypeInfo || {};\n    meta.super = meta.super.prototype.constructor;\n    meta.super.call(self, meta);\n\n    if (info.enums) {\n        // TODO: not exported to the whole file scope yet\n        Object.keys(info.enums).forEach(function (name) {\n            self[name] = info.enums[name];\n        });\n    }\n    if (info.properties) {\n        Object.keys(info.properties).forEach(function (name) {\n            var desc = info.properties[name];\n            if (typeof desc === 'string') {\n                desc = { type: desc };\n            }\n            createProperty(desc.type, self, name, desc);\n        });\n    }\n    if (info.defaultProperty) {\n        self.$defaultProperty = info.defaultProperty;\n    }\n}\n\n/**\n * QML Object constructor.\n * @param {Object} meta Meta information about the object and the creation context\n * @return {Object} New qml object\n */\nfunction construct(meta) {\n    var item, component;\n\n    var constructors = perImportContextConstructors[meta.context.importContextId];\n\n    var classComponents = meta.object.$class.split(\".\");\n    for (var ci = 0; ci < classComponents.length; ++ci) {\n        var c = classComponents[ci];\n        constructors = constructors[c];\n        if (constructors === undefined) {\n            break;\n        }\n    }\n\n    if (constructors !== undefined) {\n        var constructor = constructors;\n        meta.super = constructor;\n        item = new constructor(meta);\n        meta.super = undefined;\n    } else {\n        // Load component from file. Please look at import.js for main notes.\n        // Actually, we have to use that order:\n        // 1) try to load component from current basePath\n        // 2) from importPathList\n        // 3) from directories in imports statements and then\n        // 4) from qmldir files\n        // Currently we support only 1,2 and 4 and use order: 4,1,2\n        // TODO: engine.qmldirs is global for all loaded components. That's not qml's original behaviour.\n        var qdirInfo = engine.qmldirs[meta.object.$class]; // Are we have info on that component in some imported qmldir files?\n\n        var oldExecutionContext = _executionContext;\n        _executionContext = meta.context;\n\n        if (qdirInfo) {\n            // We have that component in some qmldir, load it from qmldir's url\n            component = Qt.createComponent(\"@\" + qdirInfo.url);\n        } else {\n            var filePath;\n            if (classComponents.length === 2) {\n                filePath = engine.qualifiedImportPath(meta.context.importContextId, classComponents[0]) + classComponents[1];\n            } else {\n                filePath = classComponents[0];\n            }\n            component = Qt.createComponent(filePath + \".qml\");\n        }\n\n        _executionContext = oldExecutionContext;\n\n        if (component) {\n            var item = component.createObject(meta.parent);\n\n            if (typeof item.dom != 'undefined') item.dom.className += \" \" + classComponents[classComponents.length - 1] + (meta.object.id ? \" \" + meta.object.id : \"\");\n            var dProp; // Handle default properties\n        } else {\n            throw new Error(\"No constructor found for \" + meta.object.$class);\n        }\n    }\n\n    // id\n    if (meta.object.id) setupGetterSetter(meta.context, meta.object.id, function () {\n        return item;\n    }, function () {});\n\n    // keep path in item for probale use it later in Qt.resolvedUrl\n    item.$context[\"$basePath\"] = engine.$basePath; //gut\n\n    // We want to use the item's scope, but this Component's imports\n    item.$context.importContextId = meta.context.importContextId;\n\n    // Apply properties (Bindings won't get evaluated, yet)\n    applyProperties(meta.object, item, item, item.$context);\n\n    return item;\n}\n\n/**\n * Create property getters and setters for object.\n * @param {Object} obj Object for which gsetters will be set\n * @param {String} propName Property name\n * @param {Object} [options] Options that allow finetuning of the property\n */\nfunction createProperty(type, obj, propName) {\n    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var prop = new QMLProperty(type, obj, propName);\n    var getter, setter;\n\n    obj[propName + \"Changed\"] = prop.changed;\n    obj.$properties[propName] = prop;\n    obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n    getter = function getter() {\n        return obj.$properties[propName].get();\n    };\n    if (!options.readOnly) setter = function setter(newVal) {\n        obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };else {\n        setter = function setter(newVal) {\n            if (obj.$canEditReadOnlyProperties != true) throw \"property '\" + propName + \"' has read only access\";\n            obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n        };\n    }\n    setupGetterSetter(obj, propName, getter, setter);\n    if (obj.$isComponentRoot) setupGetterSetter(obj.$context, propName, getter, setter);\n}\n\n/**\n * Set up simple getter function for property\n */\n\nfunction setupGetter(obj, propName, func) {\n    Object.defineProperty(obj, propName, {\n        get: func,\n        configurable: true,\n        enumerable: true\n    });\n}\n\nfunction setupSetter(obj, propName, func) {\n    Object.defineProperty(obj, propName, {\n        set: func,\n        configurable: true,\n        enumerable: false\n    });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n    Object.defineProperty(obj, propName, {\n        get: getter,\n        set: setter,\n        configurable: true,\n        enumerable: false\n    });\n}\n\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\n    if (!item[signalName]) {\n        console.warn(\"No signal called \" + signalName + \" found!\");\n        return;\n    } else if (typeof item[signalName].connect != 'function') {\n        console.warn(signalName + \" is not a signal!\");\n        return;\n    }\n    if (!value.eval) {\n        var params = \"\";\n        for (var j in item[signalName].parameters) {\n            params += j == 0 ? \"\" : \", \";\n            params += item[signalName].parameters[j].name;\n        }\n        value.src = \"(function(\" + params + \") { _executionContext = __executionContext;\" + value.src + \"})\";\n        value.isFunction = false;\n        value.compile();\n    }\n    var slot = value.eval(objectScope, componentScope);\n    item[signalName].connect(item, slot);\n    return slot;\n}\n\n/**\n * Apply properties from metaObject to item.\n * @param {Object} metaObject Source of properties\n * @param {Object} item Target of property apply\n * @param {Object} objectScope Scope in which properties should be evaluated\n * @param {Object} componentScope Component scope in which properties should be evaluated\n */\nfunction applyProperties(metaObject, item, objectScope, componentScope) {\n    var i;\n    objectScope = objectScope || item;\n    _executionContext = componentScope;\n\n    if (metaObject.$children && metaObject.$children.length !== 0) {\n        if (item.$defaultProperty) item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);else throw \"Cannot assign to unexistant default property\";\n    }\n    // We purposefully set the default property AFTER using it, in order to only have it applied for\n    // instanciations of this component, but not for its internal children\n    if (metaObject.$defaultProperty) item.$defaultProperty = metaObject.$defaultProperty;\n\n    for (i in metaObject) {\n        var value = metaObject[i];\n        if (i == \"id\" || i == \"$class\") {\n            // keep them\n            item[i] = value;\n            continue;\n        }\n\n        // skip global id's and internal values\n        if (i == \"id\" || i[0] == \"$\") {\n            continue;\n        }\n        // slots\n        if (i.indexOf(\"on\") == 0 && i[2].toUpperCase() == i[2]) {\n            var signalName = i[2].toLowerCase() + i.slice(3);\n            if (!connectSignal(item, signalName, value, objectScope, componentScope)) {\n                if (item.$setCustomSlot) {\n                    item.$setCustomSlot(signalName, value, objectScope, componentScope);\n                }\n            }\n            continue;\n        }\n\n        if (value instanceof Object) {\n            if (value instanceof QMLSignalDefinition) {\n                item[i] = Signal(value.parameters);\n                if (item.$isComponentRoot) componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLMethod) {\n                value.compile();\n                item[i] = value.eval(objectScope, componentScope);\n                if (item.$isComponentRoot) componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLAliasDefinition) {\n                // TODO: 1. Alias must be able to point to prop or id of local object,eg: property alias q: t\n                //       2. Alias may have same name as id it points to: property alias someid: someid\n                //       3. Alias proxy (or property proxy) to proxy prop access to selected incapsulated object. (think twice).\n                createProperty(\"alias\", item, i);\n                item.$properties[i].componentScope = componentScope;\n                item.$properties[i].val = value;\n                item.$properties[i].get = function () {\n                    var obj = this.componentScope[this.val.objectName];\n                    return this.val.propertyName ? obj.$properties[this.val.propertyName].get() : obj;\n                };\n                item.$properties[i].set = function (newVal, reason, objectScope, componentScope) {\n                    if (!this.val.propertyName) throw \"Cannot set alias property pointing to an QML object.\";\n                    this.componentScope[this.val.objectName].$properties[this.val.propertyName].set(newVal, reason, objectScope, componentScope);\n                };\n\n                if (value.propertyName) {\n                    var con = function con(prop) {\n                        var obj = prop.componentScope[prop.val.objectName];\n                        if (!obj) {\n                            console.error(\"qtcore: target object \", prop.val.objectName, \" not found for alias \", prop);\n                        } else {\n                            var targetProp = obj.$properties[prop.val.propertyName];\n                            if (!targetProp) {\n                                console.error(\"qtcore: target property [\", prop.val.objectName, \"].\", prop.val.propertyName, \" not found for alias \", prop.name);\n                            } else {\n                                // targetProp.changed.connect( prop.changed );\n                                // it is not sufficient to connect to `changed` of source property\n                                // we have to propagate own changed to it too\n                                // seems the best way to do this is to make them identical?..\n                                // prop.changed = targetProp.changed;\n                                // obj[i + \"Changed\"] = prop.changed;\n                                // no. because those object might be destroyed later.\n                                (function () {\n                                    var loopWatchdog = false;\n                                    targetProp.changed.connect(item, function () {\n                                        if (loopWatchdog) return;loopWatchdog = true;\n                                        prop.changed.apply(item, arguments);\n                                        loopWatchdog = false;\n                                    });\n                                    prop.changed.connect(obj, function () {\n                                        if (loopWatchdog) return;loopWatchdog = true;\n                                        targetProp.changed.apply(obj, arguments);\n                                        loopWatchdog = false;\n                                    });\n                                })();\n                            }\n                        }\n                    };\n                    engine.pendingOperations.push([con, item.$properties[i]]);\n                }\n\n                continue;\n            } else if (value instanceof QMLPropertyDefinition) {\n                createProperty(value.type, item, i);\n                item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);\n                continue;\n            } else if (item[i] && value instanceof QMLMetaPropertyGroup) {\n                // Apply properties one by one, otherwise apply at once\n                applyProperties(value, item[i], objectScope, componentScope);\n                continue;\n            }\n        }\n        if (item.$properties && i in item.$properties) item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);else if (i in item) item[i] = value;else if (item.$setCustomData) item.$setCustomData(i, value);else console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\n    }\n}\n\n// ItemModel. EXPORTED.\nJSItemModel = function JSItemModel() {\n    this.roleNames = [];\n\n    this.setRoleNames = function (names) {\n        this.roleNames = names;\n    };\n\n    this.dataChanged = Signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsInserted = Signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsMoved = Signal([{ type: \"int\", name: \"sourceStartIndex\" }, { type: \"int\", name: \"sourceEndIndex\" }, { type: \"int\", name: \"destinationIndex\" }]);\n    this.rowsRemoved = Signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.modelReset = Signal();\n};\n\n// -----------------------------------------------------------------------------\n// Stuff below defines QML things\n// -----------------------------------------------------------------------------\n\nglobal.addEventListener('load', function () {\n    var metaTags = document.getElementsByTagName('BODY');\n\n    for (var i = 0; i < metaTags.length; ++i) {\n        var metaTag = metaTags[i];\n        var source = metaTag.getAttribute('data-qml');\n\n        if (source != null) {\n            global.qmlEngine = new QMLEngine();\n            qmlEngine.loadFile(source);\n            qmlEngine.start();\n            break;\n        }\n    }\n});\n\nglobal.importJavascriptInContext = function (jsData, $context) {\n    /* Remove any \".pragma\" statements, as they are not valid JavaScript */\n    var source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\n    // TODO: pass more objects to the scope?\n    new Function('jsData', '$context', \"\\n      with ($context) {\\n        \" + source + \"\\n      }\\n      \" + jsData.exports.map(function (sym) {\n        return \"$context.\" + sym + \" = \" + sym + \";\";\n    }).join('') + \"\\n    \")(jsData, $context);\n};\n\n// TODO\nfunction QMLColor(val) {\n    if (typeof val === \"number\") {\n        // we assume it is int value and must be converted to css hex with padding\n        // http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript\n        val = \"#\" + (Math.round(val) + 0x1000000).toString(16).substr(-6).toUpperCase();\n    } else {\n        if (typeof val === \"array\" && val.length >= 3) {\n            // array like [r,g,b] where r,g,b are in 0..1 range\n            var m = 255;\n            val = \"rgb(\" + Math.round(m * val[0]) + \",\" + Math.round(m * val[1]) + \",\" + Math.round(m * val[2]) + \")\";\n        }\n    }\n    return val;\n};\n\n/*\n * - QMLEngine(element, options) -- Returns new qml engine object, for which:\n *   - loadFile(file) -- Load file to the engine (.qml or .qml.js atm)\n *   - start() -- start the engine/application\n *   - stop() -- stop the engine/application. Restarting is experimental.\n *   element is HTMLCanvasElement and options are for debugging.\n *   For further reference, see testpad and qml viewer applications.\n */\n\n// There can only be one running QMLEngine. This variable points to the currently running engine.\nvar engine = null;\n\n// QML engine. EXPORTED.\nQMLEngine = function QMLEngine(element, options) {\n    //----------Public Members----------\n    this.fps = 60;\n    this.$interval = Math.floor(1000 / this.fps); // Math.floor, causes bugs to timing?\n    this.running = false;\n\n    // List of available Components\n    this.components = {};\n\n    this.rootElement = element;\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n    //----------Public Methods----------\n    // Start the engine\n    this.start = function () {\n        engine = this;\n        var i;\n        if (this.operationState !== QMLOperationState.Running) {\n            this.operationState = QMLOperationState.Running;\n            tickerId = setInterval(tick, this.$interval);\n            for (i = 0; i < whenStart.length; i++) {\n                whenStart[i]();\n            }\n        }\n    };\n\n    // Stop the engine\n    this.stop = function () {\n        var i;\n        if (this.operationState == QMLOperationState.Running) {\n            clearInterval(tickerId);\n            this.operationState = QMLOperationState.Idle;\n            for (i = 0; i < whenStop.length; i++) {\n                whenStop[i]();\n            }\n        }\n    };\n\n    this.ensureFileIsLoadedInQrc = function (file) {\n        if (!qrc.hasOwnProperty(file)) {\n            var src = getUrlContents(file);\n\n            if (src) {\n                loadParser();\n                console.log('Loading file [', file, ']');\n                qrc[file] = qmlweb_parse(src, qmlweb_parse.QMLDocument);\n            } else {\n                console.log('Can not load file [', file, ']');\n            }\n        }\n    };\n\n    this.extractBasePath = function (file) {\n        var basePath = file.split(/[\\/\\\\]/); // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n        basePath[basePath.length - 1] = \"\";\n        basePath = basePath.join(\"/\");\n        return basePath;\n    };\n    // Load file, parse and construct (.qml or .qml.js)\n    this.loadFile = function (file) {\n        var parentComponent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n        var tree;\n\n        this.$basePath = this.extractBasePath(file);\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        return this.loadQMLTree(tree, parentComponent, file);\n    };\n\n    // parse and construct qml\n    this.loadQML = function (src) {\n        var parentComponent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n        var file = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];\n        // file is not required; only for debug purposes\n        return this.loadQMLTree(parseQML(src, file), parentComponent, file);\n    };\n\n    this.loadQMLTree = function (tree) {\n        var parentComponent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n        var file = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];\n\n        engine = this;\n        if (options.debugTree) {\n            options.debugTree(tree);\n        }\n\n        // Create and initialize objects\n        var QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        var component = new QMLComponent({ object: tree, parent: parentComponent });\n\n        this.loadImports(tree.$imports, undefined, component.importContextId);\n        component.$basePath = engine.$basePath;\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // just for debugging\n\n        this.rootObject = component.createObject(parentComponent);\n        component.finalizeImports(this.rootContext());\n        this.$initializePropertyBindings();\n\n        this.start();\n\n        this.callCompletedSignals();\n\n        return component;\n    };\n\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\n     *\n     * Removes dot segments in given path component, as described in\n     * RFC 3986, section 5.2.4.\n     *\n     * @param {string} path A non-empty path component.\n     * @return {string} Path component with removed dot segments.\n     */\n    this.removeDotSegments = function (path) {\n        var leadingSlash = path && path[0] == \"/\"; // path.startsWith('/'); -- startsWith seems to be undefined in some browsers\n        var segments = path.split('/');\n        var out = [];\n\n        for (var pos = 0; pos < segments.length;) {\n            var segment = segments[pos++];\n\n            if (segment == '.') {\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else if (segment == '..') {\n                if (out.length > 1 || out.length == 1 && out[0] != '') {\n                    out.pop();\n                }\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else {\n                out.push(segment);\n                leadingSlash = true;\n            }\n        }\n\n        return out.join('/');\n    };\n\n    /*\n      engine.loadImports( imports, currentDir ) : performs loading of qmldir files from given qml import records.\n       Input:\n      * parameter `importsArray` - import statements. It is in parser notation, e.g. [import1, import2, ...] where each importN is also array: [\"qmlimport\",\"name\",version,as,isQualifiedName]\n      * parameter `currentFileDir` - base dir for imports lookup. It will be used together with importPathList()\n       Implicit input:\n      * engine object function `importPathList()` - list of urls bases used for qmldir files lookup\n       Additional implicit input/output:\n      * engine object variable `qmldirsContents` - used for caching, e.g. memory for previously loaded qmldir files\n       Output: \n      * engine object variable `qmldirs` - new records will be added there\n       Return value: \n      * nothing\n       Details:\n       For each of given import statements, loadImports \n      1. computes qmldir file location according to http://doc.qt.io/qt-5/qtqml-syntax-imports.html\n      2. calls `readQmlDir` for actual reading and parsing of qmldir file content\n      3. gets `external` declarations of that qmldir file and pushes them to `engine.qmldirs` hash.\n       `engine.qmldirs` is a hash of form: { componentName => componentFileUrl }\n      This hash then used by `qml.js::construct` method for computing component urls.\n       Notes:\n      1. This method is not suited for loading js imports. This may be done probably after answering to Q1 (below).\n      2. Please look for additional notes at readQmlDir function.\n       QNA\n      Q1: How and where in engine component names might be prefixed? E.g. names with dot inside: SomeModule.Component1\n      A1: Seems it doesn't matter. Seems we may just save name with dot-inside right to qmldirs, and it may be used by construct() seamlessly. Check it..\n       Q2: How we may access component object from here, to store qmldirs info in components logical scope, and not at engine scope?\n      A2: Probably, answer is in Component.js and in global.loadImports\n       TODO \n      * We have to keep output in component scope, not in engine scope.\n      * We have to add module \"as\"-names to component's names (which is possible after keeping imports in component scope).\n      * Determine how this stuff is related to `global.loadImports`\n      * Check A1\n      * Make a complete picture of what going in with imports, including Component.js own imports loading\n      * Note importJs method in import.js \n    */\n\n    this.loadImports = function (importsArray, currentFileDir, importContextId) {\n        if (!this.qmldirsContents) {\n            this.qmldirsContents = {}; // cache\n\n            // putting initial keys in qmldirsContents - is a hack. We should find a way to explain to qmlweb, is this built-in module or qmldir-style module.\n            for (var module in modules) {\n                if (module !== 'Main') {\n                    this.qmldirsContents[module] = {};\n                }\n            }\n        }\n\n        if (!this.qmldirs) this.qmldirs = {}; // resulting components lookup table\n\n        if (!importsArray || importsArray.length == 0) return;\n        if (!currentFileDir) currentFileDir = this.$basePath; // use this.$basePath by default\n\n        for (var i = 0; i < importsArray.length; i++) {\n            var entry = importsArray[i];\n\n            var name = entry[1];\n\n            var nameIsUrl = name.indexOf(\"//\") == 0 || name.indexOf(\"://\") >= 0; // is it url to remote resource\n            var nameIsQualifiedModuleName = entry[4]; // e.g. QtQuick, QtQuick.Controls, etc\n            var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl; // local [relative] dir\n\n            if (nameIsDir) {\n                // resolve name from relative to full dir path\n                // we hope all dirs are relative\n                if (currentFileDir && currentFileDir.length > 0) name = this.removeDotSegments(currentFileDir + name);\n                if (name[name.length - 1] == \"/\") name = name.substr(0, name.length - 1); // remove trailing slash as it required for `readQmlDir`\n            }\n            // TODO if nameIsDir, we have also to add `name` to importPathList() for current component...\n\n            // check if we have already loaded that qmldir file\n            if (this.qmldirsContents[name]) continue;\n\n            var content = false;\n            if (nameIsQualifiedModuleName && this.userAddedModulePaths && this.userAddedModulePaths[name]) {\n                // 1. we have qualified module and user had configured path for that module with this.addModulePath\n                content = readQmlDir(this.userAddedModulePaths[name]);\n            } else if (nameIsUrl || nameIsDir) {\n                // 2. direct load\n                // nameIsUrl => url do not need dirs\n                // nameIsDir => already computed full path above\n                content = readQmlDir(name);\n            } else {\n                // 3. qt-style lookup for qualified module\n                var probableDirs = [currentFileDir].concat(this.importPathList());\n                var diredName = name.replace(/\\./g, \"/\");\n\n                for (var k = 0; k < probableDirs.length; k++) {\n                    var file = probableDirs[k] + diredName;\n                    content = readQmlDir(file);\n                    if (content) break;\n                }\n            }\n\n            if (!content) {\n                // NEW\n                // add that dir to import path list\n                // that means, lookup qml files in that failed dir by trying to load them directly\n                // this is not the same behavior as in Qt for \"url\" schemes,\n                // but it is same as for ordirnal disk files.\n                // So, we do it for experimental purposes.\n                if (nameIsDir) {\n                    if (entry[3]) {\n                        /* Use entry[1] directly, as we don't want to include the\n                         * basePath, otherwise it gets prepended twice in\n                         * createComponent. */\n                        this.addQualifiedImportPath(importContextId, entry[3], entry[1] + \"/\");\n                    } else {\n                        this.addImportPath(name + \"/\");\n                    }\n                }\n\n                continue;\n            }\n\n            // copy founded externals to global var\n            // TODO actually we have to copy it to current component\n            for (var attrname in content.externals) {\n                this.qmldirs[attrname] = content.externals[attrname];\n            }\n\n            // keep already loaded qmldir files\n            this.qmldirsContents[name] = content;\n        }\n    };\n\n    this.rootContext = function () {\n        return this.rootObject.$context;\n    };\n\n    this.focusedElement = function () {\n        return this.rootContext().activeFocus;\n    }.bind(this);\n\n    // KEYBOARD MANAGEMENT\n    var keyboardSignals = {};\n    keyboardSignals[Qt.Key_Asterisk] = 'asteriskPressed';\n    keyboardSignals[Qt.Key_Back] = 'backPressed';\n    keyboardSignals[Qt.Key_Backtab] = 'backtabPressed';\n    keyboardSignals[Qt.Key_Call] = 'callPressed';\n    keyboardSignals[Qt.Key_Cancel] = 'cancelPressed';\n    keyboardSignals[Qt.Key_Delete] = 'deletePressed';\n    keyboardSignals[Qt.Key_0] = 'digit0Pressed';\n    keyboardSignals[Qt.Key_1] = 'digit1Pressed';\n    keyboardSignals[Qt.Key_2] = 'digit2Pressed';\n    keyboardSignals[Qt.Key_3] = 'digit3Pressed';\n    keyboardSignals[Qt.Key_4] = 'digit4Pressed';\n    keyboardSignals[Qt.Key_5] = 'digit5Pressed';\n    keyboardSignals[Qt.Key_6] = 'digit6Pressed';\n    keyboardSignals[Qt.Key_7] = 'digit7Pressed';\n    keyboardSignals[Qt.Key_8] = 'digit8Pressed';\n    keyboardSignals[Qt.Key_9] = 'digit9Pressed';\n    keyboardSignals[Qt.Key_Escape] = 'escapePressed';\n    keyboardSignals[Qt.Key_Flip] = 'flipPressed';\n    keyboardSignals[Qt.Key_Hangup] = 'hangupPressed';\n    keyboardSignals[Qt.Key_Menu] = 'menuPressed';\n    keyboardSignals[Qt.Key_No] = 'noPressed';\n    keyboardSignals[Qt.Key_Return] = 'returnPressed';\n    keyboardSignals[Qt.Key_Select] = 'selectPressed';\n    keyboardSignals[Qt.Key_Space] = 'spacePressed';\n    keyboardSignals[Qt.Key_Tab] = 'tabPressed';\n    keyboardSignals[Qt.Key_VolumeDown] = 'volumeDownPressed';\n    keyboardSignals[Qt.Key_VolumeUp] = 'volumeUpPressed';\n    keyboardSignals[Qt.Key_Yes] = 'yesPressed';\n    keyboardSignals[Qt.Key_Up] = 'upPressed';\n    keyboardSignals[Qt.Key_Right] = 'rightPressed';\n    keyboardSignals[Qt.Key_Down] = 'downPressed';\n    keyboardSignals[Qt.Key_Left] = 'leftPressed';\n\n    function keyCodeToQt(e) {\n        e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n        if (e.keyCode == Qt.Key_Tab && e.shiftKey == true) return Qt.Key_Backtab;else if (e.keyCode >= 97 && e.keyCode <= 122) return e.keyCode - (97 - Qt.Key_A);\n        return e.keyCode;\n    }\n\n    function eventToKeyboard(e) {\n        return {\n            accepted: false,\n            count: 1,\n            isAutoRepeat: false,\n            key: keyCodeToQt(e),\n            modifiers: e.ctrlKey * Qt.CtrlModifier | e.altKey * Qt.AltModifier | e.shiftKey * Qt.ShiftModifier | e.metaKey * Qt.MetaModifier | e.keypad * Qt.KeypadModifier,\n            text: String.fromCharCode(e.charCode)\n        };\n    }\n\n    document.onkeypress = function (e) {\n        var focusedElement = this.focusedElement();\n        var event = eventToKeyboard(e || window.event);\n        var eventName = keyboardSignals[event.key];\n\n        while (event.accepted != true && focusedElement != null) {\n            var backup = focusedElement.$context.event;\n\n            focusedElement.$context.event = event;\n            focusedElement.Keys.pressed(event);\n            if (eventName != null) focusedElement.Keys[eventName](event);\n            focusedElement.$context.event = backup;\n            if (event.accepted == true) e.preventDefault();else focusedElement = focusedElement.$parent;\n        }\n    }.bind(this);\n\n    document.onkeyup = function (e) {\n        var focusedElement = this.focusedElement();\n        var event = eventToKeyboard(e || window.event);\n\n        while (event.accepted != true && focusedElement != null) {\n            var backup = focusedElement.$context.event;\n\n            focusedElement.$context.event = event;\n            focusedElement.Keys.released(event);\n            focusedElement.$context.event = backup;\n            if (event.accepted == true) e.preventDefault();else focusedElement = focusedElement.$parent;\n        }\n    }.bind(this);\n    // END KEYBOARD MANAGEMENT\n\n    this.registerProperty = function (obj, propName) {\n        var dependantProperties = [];\n        var value = obj[propName];\n\n        function getter() {\n            if (evaluatingProperty && dependantProperties.indexOf(evaluatingProperty) == -1) dependantProperties.push(evaluatingProperty);\n\n            return value;\n        }\n\n        function setter(newVal) {\n            value = newVal;\n\n            for (i in dependantProperties) {\n                dependantProperties[i].update();\n            }\n        }\n\n        setupGetterSetter(obj, propName, getter, setter);\n    };\n\n    // next 3 methods used in Qt.createComponent for qml files lookup\n    // please open qt site for documentation\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n    this.addImportPath = function (dirpath) {\n        if (!this.userAddedImportPaths) this.userAddedImportPaths = [];\n        this.userAddedImportPaths.push(dirpath);\n    };\n\n    this.addQualifiedImportPath = function (importContextId, moduleQualifier, dirpath) {\n        if (!this.qualifiedImportPaths) this.qualifiedImportPaths = {};\n        if (!this.qualifiedImportPaths[importContextId]) {\n            this.qualifiedImportPaths[importContextId] = {};\n        }\n        this.qualifiedImportPaths[importContextId][moduleQualifier] = dirpath;\n    };\n\n    this.qualifiedImportPath = function (importContextId, moduleQualifier) {\n        if (!this.qualifiedImportPaths) return \"\";\n        var importPathsForContext = this.qualifiedImportPaths[importContextId];\n        if (!importPathsForContext) return \"\";\n        return importPathsForContext[moduleQualifier] || \"\";\n    };\n\n    this.setImportPathList = function (arrayOfDirs) {\n        this.userAddedImportPaths = arrayOfDirs;\n    };\n\n    this.importPathList = function () {\n        return this.userAddedImportPaths || [];\n    };\n\n    // `addModulePath` defines conrete path for module lookup\n    // e.g. addModulePath( \"QtQuick.Controls\",\"http://someserver.com/controls\" )\n    // will force system to `import QtQuick.Controls` module from `http://someserver.com/controls/qmldir`\n\n    this.addModulePath = function (moduleName, dirPath) {\n\n        // remove trailing slash as it required for `readQmlDir`\n        if (dirPath[dirPath.length - 1] == \"/\") dirPath = dirPath.substr(0, dirPath.length - 1);\n\n        // keep the mapping. It will be used in loadImports() function .\n        if (!this.userAddedModulePaths) this.userAddedModulePaths = {};\n        this.userAddedModulePaths[moduleName] = dirPath;\n    };\n\n    //Intern\n\n    // Load file, parse and construct as Component (.qml)\n    this.loadComponent = function (name) {\n        if (name in this.components) return this.components[name];\n\n        var file = engine.$basePath + name + \".qml\";\n\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        this.components[name] = tree;\n        return tree;\n    };\n\n    this.$initializePropertyBindings = function () {\n        // Initialize property bindings\n        // we use `while`, because $initializePropertyBindings may be called recursive (because of Loader and/or createQmlObject )\n        while (this.bindedProperties.length > 0) {\n            var property = this.bindedProperties.shift();\n            if (!property.binding) continue; // Probably, the binding was overwritten by an explicit value. Ignore.\n            if (property.needsUpdate) property.update();else if ([\"width\", \"height\", \"fill\", \"x\", \"y\", \"left\", \"right\", \"top\", \"bottom\"].indexOf(property.name) >= 0) {\n                // It is possible that bindings with these names was already evaluated during eval of other bindings\n                // but in that case updateHGeometry and updateVGeometry could be blocked during their eval.\n                // So we call them explicitly, just in case.\n\n                if (property.changed.isConnected(property.obj, updateHGeometry)) updateHGeometry.apply(property.obj, [property.val, property.val, property.name]);\n                if (property.changed.isConnected(property.obj, updateVGeometry)) updateVGeometry.apply(property.obj, [property.val, property.val, property.name]);\n            }\n        }\n\n        this.$initializeAliasSignals();\n    };\n\n    this.$initializeAliasSignals = function () {\n        // Perform pending operations. Now we use it only to init alias's \"changed\" handlers, that's why we have such strange function name.\n        while (this.pendingOperations.length > 0) {\n            var op = this.pendingOperations.shift();\n            op[0](op[1], op[2], op[3]);\n        }\n        this.pendingOperations = [];\n    };\n\n    // Return a path to load the file\n    this.$resolvePath = function (file) {\n        // probably, replace :// with :/ ?\n        if (file == \"\" || file.indexOf(\"://\") != -1 || file.indexOf(\"/\") == 0 || file.indexOf(\"data:\") == 0 || file.indexOf(\"blob:\") == 0) {\n            return file;\n        }\n        return this.$basePath + file;\n    };\n\n    this.$registerStart = function (f) {\n        whenStart.push(f);\n    };\n\n    this.$registerStop = function (f) {\n        whenStop.push(f);\n    };\n\n    this.$addTicker = function (t) {\n        tickers.push(t);\n    };\n\n    this.$removeTicker = function (t) {\n        var index = tickers.indexOf(t);\n        if (index != -1) {\n            tickers.splice(index, 1);\n        }\n    };\n\n    this.size = function () {\n        return { width: this.rootObject.getWidth(), height: this.rootObject.getHeight() };\n    };\n\n    //----------Private Methods----------\n\n    function tick() {\n        var i,\n            now = new Date().getTime(),\n            elapsed = now - lastTick;\n        lastTick = now;\n        for (i = 0; i < tickers.length; i++) {\n            tickers[i](now, elapsed);\n        }\n    }\n\n    //----------Private Members----------\n    // Target canvas\n    var // Callbacks for stopping or starting the engine\n    whenStop = [],\n        whenStart = [],\n\n    // Ticker resource id and ticker callbacks\n    tickerId,\n        tickers = [],\n        lastTick = new Date().getTime(),\n        i;\n\n    //----------Construct----------\n\n    options = options || {};\n\n    if (options.debugConsole) {\n        // Replace QML-side console.log\n        console = {};\n        console.log = function () {\n            var args = Array.prototype.slice.call(arguments);\n            options.debugConsole.apply(undefined, args);\n        };\n    }\n\n    // TODO: Move to module initialization\n    for (i in constructors) {\n        if (constructors[i].getAttachedObject) setupGetter(QMLBaseObject.prototype, i, constructors[i].getAttachedObject);\n    }\n};\n\nQMLEngine.prototype.callCompletedSignals = function () {\n    // the while loop is better than for..in loop, because completedSignals array might change dynamically when\n    // some completed signal handlers will create objects dynamically via createQmlObject or Loader\n    while (this.completedSignals.length > 0) {\n        var handler = this.completedSignals.shift();\n        handler();\n    }\n};\n\nfunction QMLInteger(val) {\n    return val | 0;\n}\n\nfunction QMLList(meta) {\n    var list = [];\n    if (meta.object instanceof Array) for (var i in meta.object) {\n        list.push(construct({ object: meta.object[i], parent: meta.parent, context: meta.context }));\n    } else if (meta.object instanceof QMLMetaElement) list.push(construct({ object: meta.object, parent: meta.parent, context: meta.context }));\n\n    return list;\n}\n\nQMLOperationState = {\n    Idle: 1,\n    Init: 2,\n    Running: 3\n};\n\nvar QMLProperty = function QMLProperty(type, obj, name) {\n    _classCallCheck(this, QMLProperty);\n\n    this.obj = obj;\n    this.name = name;\n    this.changed = Signal([], { obj: obj });\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n    this.needsUpdate = true;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this object.\n    this.$tidyupList = [];\n};\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\nfunction pushEvalStack() {\n    evaluatingPropertyStackOfStacks.push(evaluatingPropertyStack);\n    evaluatingPropertyStack = [];\n    evaluatingProperty = undefined;\n    //  console.log(\"evaluatingProperty=>undefined due to push stck \");\n}\n\nfunction popEvalStack() {\n    evaluatingPropertyStack = evaluatingPropertyStackOfStacks.pop() || [];\n    evaluatingProperty = evaluatingPropertyStack[evaluatingPropertyStack.length - 1];\n}\n\nfunction pushEvaluatingProperty(prop) {\n    // TODO say warnings if already on stack. This means binding loop. BTW actually we do not loop because needsUpdate flag is reset before entering update again.\n    if (evaluatingPropertyStack.indexOf(prop) >= 0) {\n        console.error(\"Property binding loop detected for property \", prop.name, [prop].slice(0));\n    }\n    evaluatingProperty = prop;\n    evaluatingPropertyStack.push(prop); //keep stack of props\n}\n\nfunction popEvaluatingProperty() {\n\n    evaluatingPropertyStack.pop();\n    evaluatingProperty = evaluatingPropertyStack[evaluatingPropertyStack.length - 1];\n}\n\n// Updater recalculates the value of a property if one of the\n// dependencies changed\nQMLProperty.prototype.update = function () {\n    this.needsUpdate = false;\n\n    if (!this.binding) return;\n\n    var oldVal = this.val;\n\n    try {\n        pushEvaluatingProperty(this);\n        if (!this.binding.eval) this.binding.compile();\n        this.val = this.binding.eval(this.objectScope, this.componentScope);\n    } catch (e) {\n        console.log(\"QMLProperty.update binding error:\", e, Function.prototype.toString.call(this.binding.eval));\n    } finally {\n        popEvaluatingProperty();\n    }\n\n    if (this.animation) {\n        this.animation.$actions = [{\n            target: this.animation.target || this.obj,\n            property: this.animation.property || this.name,\n            from: this.animation.from || oldVal,\n            to: this.animation.to || this.val\n        }];\n        this.animation.restart();\n    }\n\n    if (this.val !== oldVal) this.changed(this.val, oldVal, this.name);\n};\n\n// Define getter\nQMLProperty.prototype.get = function () {\n    //if (this.needsUpdate && !evaluatingPropertyPaused) {\n    if (this.needsUpdate && engine.operationState !== QMLOperationState.Init) {\n        this.update();\n    }\n\n    // If this call to the getter is due to a property that is dependant on this\n    // one, we need it to take track of changes\n    if (evaluatingProperty && !this.changed.isConnected(evaluatingProperty, QMLProperty.prototype.update)) {\n        // console.log( this,evaluatingPropertyStack.slice(0),this.val );\n        this.changed.connect(evaluatingProperty, QMLProperty.prototype.update);\n    }\n\n    return this.val;\n};\n\nvar typeInitialValues = {\n    int: 0,\n    real: 0,\n    double: 0,\n    string: '',\n    bool: false,\n    list: [],\n    url: ''\n};\n\n// Define setter\nQMLProperty.prototype.set = function (newVal, reason, objectScope, componentScope) {\n    var i,\n        oldVal = this.val;\n\n    if (newVal instanceof QMLBinding) {\n        if (!objectScope || !componentScope) throw \"Internal error: binding assigned without scope\";\n        this.binding = newVal;\n        this.objectScope = objectScope;\n        this.componentScope = componentScope;\n\n        if (engine.operationState !== QMLOperationState.Init) {\n            if (!newVal.eval) newVal.compile();\n            try {\n                pushEvaluatingProperty(this);\n\n                this.needsUpdate = false;\n                newVal = this.binding.eval(objectScope, componentScope);\n            } finally {\n                popEvaluatingProperty();\n            }\n        } else {\n            engine.bindedProperties.push(this);\n            return;\n        }\n    } else {\n        if (reason != QMLProperty.ReasonAnimation) this.binding = null;\n        if (newVal instanceof Array) newVal = newVal.slice(); // Copies the array\n    }\n\n    if (reason === QMLProperty.ReasonInit && typeof newVal === 'undefined') {\n        if (typeInitialValues.hasOwnProperty(this.type)) {\n            newVal = typeInitialValues[this.type];\n        }\n    }\n\n    if (constructors[this.type] == QMLList) {\n        this.val = QMLList({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof QMLMetaElement) {\n        var _QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        if (constructors[newVal.$class] == _QMLComponent || constructors[this.type] == _QMLComponent) this.val = new _QMLComponent({ object: newVal, parent: this.obj, context: componentScope });else this.val = construct({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof Object || !newVal) {\n        this.val = newVal;\n    } else {\n        this.val = constructors[this.type](newVal);\n    }\n\n    if (this.val !== oldVal) {\n        if (this.animation && reason == QMLProperty.ReasonUser) {\n            this.animation.running = false;\n            this.animation.$actions = [{\n                target: this.animation.target || this.obj,\n                property: this.animation.property || this.name,\n                from: this.animation.from || oldVal,\n                to: this.animation.to || this.val\n            }];\n            this.animation.running = true;\n        }\n        if (this.obj.$syncPropertyToRemote instanceof Function && reason == QMLProperty.ReasonUser) {\n            // is a remote object from e.g. a QWebChannel\n            this.obj.$syncPropertyToRemote(this.name, newVal);\n        } else {\n            this.changed(this.val, oldVal, this.name);\n        }\n    }\n};\n\nfunction QMLVariant(val) {\n    return val;\n}\n\n// Base object for all qml thingies\nvar objectIds = 0;\nfunction QObject(parent) {\n    this.$parent = parent;\n    if (parent && parent.$tidyupList) parent.$tidyupList.push(this);\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n\n    this.objectId = objectIds++;\n    this.$delete = function () {\n        if (this.$Component) this.$Component.destruction();\n\n        while (this.$tidyupList.length > 0) {\n            var item = this.$tidyupList[0];\n            if (item.$delete) // It's a QObject\n                item.$delete();else // It must be a signal\n                item.disconnect(this);\n        }\n\n        for (var i in this.$properties) {\n            var prop = this.$properties[i];\n            while (prop.$tidyupList.length > 0) {\n                prop.$tidyupList[0].disconnect(prop);\n            }\n        }\n\n        if (this.$parent && this.$parent.$tidyupList) this.$parent.$tidyupList.splice(this.$parent.$tidyupList.indexOf(this), 1);\n\n        // must do this:\n        // 1) parent will be notified and erase object from it's children.\n        // 2) DOM node will be removed.\n        this.parent = undefined;\n    };\n\n    // must have `destroy` method\n    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n    this.destroy = this.$delete;\n}\n\nglobal.qrc = {};\n\n/**\n * Creates and returns a signal with the parameters specified in @p params.\n *\n * @param params Array with the parameters of the signal. Each element has to be\n *               an object with the two properties \"type\" and \"name\" specifying\n *               the datatype of the parameter and its name. The type is\n *               currently ignored.\n * @param options Options that allow finetuning of the signal.\n */\nglobal.Signal = function Signal(params, options) {\n    options = options || {};\n    var connectedSlots = [];\n    var obj = options.obj;\n\n    var signal = function signal() {\n        pushEvalStack();\n        for (var i in connectedSlots) {\n            try {\n                connectedSlots[i].slot.apply(connectedSlots[i].thisObj, arguments);\n            } catch (err) {\n                console.log(err.message);\n            }\n        }popEvalStack();\n    };\n    signal.parameters = params || [];\n    signal.connect = function () {\n        if (arguments.length == 1) connectedSlots.push({ thisObj: global, slot: arguments[0] });else if (typeof arguments[1] == 'string' || arguments[1] instanceof String) {\n            if (arguments[0].$tidyupList && arguments[0] !== obj) arguments[0].$tidyupList.push(this);\n            connectedSlots.push({ thisObj: arguments[0], slot: arguments[0][arguments[1]] });\n        } else {\n            if (arguments[0].$tidyupList && (!obj || arguments[0] !== obj && arguments[0] !== obj.$parent)) arguments[0].$tidyupList.push(this);\n            connectedSlots.push({ thisObj: arguments[0], slot: arguments[1] });\n        }\n\n        // Notify object of connect\n        if (options.obj && options.obj.$connectNotify) {\n            options.obj.$connectNotify(options);\n        }\n    };\n    signal.disconnect = function () {\n        // callType meaning: 1 = function  2 = string  3 = object with string method  4 = object with function\n\n        var callType = arguments.length == 1 ? arguments[0] instanceof Function ? 1 : 2 : typeof arguments[1] == 'string' || arguments[1] instanceof String ? 3 : 4;\n        for (var i = 0; i < connectedSlots.length; i++) {\n            var item = connectedSlots[i];\n            if (callType == 1 && item.slot == arguments[0] || callType == 2 && item.thisObj == arguments[0] || callType == 3 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]] || item.thisObj == arguments[0] && item.slot == arguments[1]) {\n                if (item.thisObj) item.thisObj.$tidyupList.splice(item.thisObj.$tidyupList.indexOf(this), 1);\n                connectedSlots.splice(i, 1);\n                i--; // We have removed an item from the list so the indexes shifted one backwards\n            }\n        }\n\n        // Notify object of disconnect\n        if (options.obj && options.obj.$disconnectNotify) {\n            options.obj.$disconnectNotify(options);\n        }\n    };\n    signal.isConnected = function () {\n        var callType = arguments.length == 1 ? 1 : typeof arguments[1] == 'string' || arguments[1] instanceof String ? 2 : 3;\n        for (var i in connectedSlots) {\n            var item = connectedSlots[i];\n            if (callType == 1 && item.slot == arguments[0] || callType == 2 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]] || item.thisObj == arguments[0] && item.slot == arguments[1]) return true;\n        }\n        return false;\n    };\n    return signal;\n};\n\nfunction updateHGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingHGeometry) return;\n    this.$updatingHGeometry = true;\n\n    var t,\n        w,\n        width,\n        x,\n        left,\n        hC,\n        right,\n        lM = anchors.leftMargin || anchors.margins,\n        rM = anchors.rightMargin || anchors.margins;\n\n    // Width\n    if (this.$isUsingImplicitWidth && propName == \"implicitWidth\") width = this.implicitWidth;else if (propName == \"width\") this.$isUsingImplicitWidth = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.left.changed.isConnected(this, updateHGeometry)) t.$properties.left.changed.connect(this, updateHGeometry);\n        if (!t.$properties.right.changed.isConnected(this, updateHGeometry)) t.$properties.right.changed.connect(this, updateHGeometry);\n        if (!t.$properties.width.changed.isConnected(this, updateHGeometry)) t.$properties.width.changed.connect(this, updateHGeometry);\n\n        this.$isUsingImplicitWidth = false;\n        width = t.width - lM - rM;\n        x = t.left - (this.parent ? this.parent.left : 0) + lM;\n        left = t.left + lM;\n        right = t.right - rM;\n        hC = (left + right) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.horizontalCenter.changed.isConnected(this, updateHGeometry)) t.$properties.horizontalCenter.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        hC = t.horizontalCenter;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else if ((t = anchors.left) !== undefined) {\n        left = t + lM;\n        if ((u = anchors.right) !== undefined) {\n            right = u - rM;\n            this.$isUsingImplicitWidth = false;\n            width = right - left;\n            x = left - (this.parent ? this.parent.left : 0);\n            hC = (right + left) / 2;\n        } else if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (hC - left) * 2;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = 2 * hC - left;\n        } else {\n            w = width || this.width;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = left + w;\n            hC = left + w / 2;\n        }\n    } else if ((t = anchors.right) !== undefined) {\n        right = t - rM;\n        if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (right - hC) * 2;\n            x = 2 * hC - right - (this.parent ? this.parent.left : 0);\n            left = 2 * hC - right;\n        } else {\n            w = width || this.width;\n            x = right - w - (this.parent ? this.parent.left : 0);\n            left = right - w;\n            hC = right - w / 2;\n        }\n    } else if ((hC = anchors.horizontalCenter) !== undefined) {\n        w = width || this.width;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.left.changed.isConnected(this, updateHGeometry)) this.parent.$properties.left.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        left = this.x + (this.parent ? this.parent.left : 0);\n        right = left + w;\n        hC = left + w / 2;\n    }\n\n    if (left !== undefined) this.left = left;\n    if (hC !== undefined) this.horizontalCenter = hC;\n    if (right !== undefined) this.right = right;\n    if (x !== undefined) this.x = x;\n    if (width !== undefined) this.width = width;\n\n    this.$updatingHGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateVGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingVGeometry) return;\n    this.$updatingVGeometry = true;\n\n    var t,\n        w,\n        height,\n        y,\n        top,\n        vC,\n        bottom,\n        tM = anchors.topMargin || anchors.margins,\n        bM = anchors.bottomMargin || anchors.margins;\n\n    // Height\n    if (this.$isUsingImplicitHeight && propName == \"implicitHeight\") height = this.implicitHeight;else if (propName == \"height\") this.$isUsingImplicitHeight = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.top.changed.isConnected(this, updateVGeometry)) t.$properties.top.changed.connect(this, updateVGeometry);\n        if (!t.$properties.bottom.changed.isConnected(this, updateVGeometry)) t.$properties.bottom.changed.connect(this, updateVGeometry);\n        if (!t.$properties.height.changed.isConnected(this, updateVGeometry)) t.$properties.height.changed.connect(this, updateVGeometry);\n\n        this.$isUsingImplicitHeight = false;\n        height = t.height - tM - bM;\n        y = t.top - (this.parent ? this.parent.top : 0) + tM;\n        top = t.top + tM;\n        bottom = t.bottom - bM;\n        vC = (top + bottom) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.verticalCenter.changed.isConnected(this, updateVGeometry)) t.$properties.verticalCenter.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        vC = t.verticalCenter;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else if ((t = anchors.top) !== undefined) {\n        top = t + tM;\n        if ((u = anchors.bottom) !== undefined) {\n            bottom = u - bM;\n            this.$isUsingImplicitHeight = false;\n            height = bottom - top;\n            y = top - (this.parent ? this.parent.top : 0);\n            vC = (bottom + top) / 2;\n        } else if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (vC - top) * 2;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = 2 * vC - top;\n        } else {\n            w = height || this.height;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = top + w;\n            vC = top + w / 2;\n        }\n    } else if ((t = anchors.bottom) !== undefined) {\n        bottom = t - bM;\n        if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (bottom - vC) * 2;\n            y = 2 * vC - bottom - (this.parent ? this.parent.top : 0);\n            top = 2 * vC - bottom;\n        } else {\n            w = height || this.height;\n            y = bottom - w - (this.parent ? this.parent.top : 0);\n            top = bottom - w;\n            vC = bottom - w / 2;\n        }\n    } else if ((vC = anchors.verticalCenter) !== undefined) {\n        w = height || this.height;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.top.changed.isConnected(this, updateVGeometry)) this.parent.$properties.top.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        top = this.y + (this.parent ? this.parent.top : 0);\n        bottom = top + w;\n        vC = top + w / 2;\n    }\n\n    if (top !== undefined) this.top = top;\n    if (vC !== undefined) this.verticalCenter = vC;\n    if (bottom !== undefined) this.bottom = bottom;\n    if (y !== undefined) this.y = y;\n    if (height !== undefined) this.height = height;\n\n    this.$updatingVGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateChildrenRect(component) {\n    var children = component !== undefined ? component.children : undefined;\n    if (children == undefined || children.length == 0) return;\n\n    var maxWidth = 0;\n    var maxHeight = 0;\n    var minX = children.length > 0 ? children[0].x : 0;\n    var minY = children.length > 0 ? children[0].y : 0;\n    var child;\n\n    for (var i = 0; i < children.length; i++) {\n        child = children[i];\n        maxWidth = Math.max(maxWidth, child.x + child.width);\n        maxHeight = Math.max(maxHeight, child.y + child.heighth);\n        minX = Math.min(minX, child.x);\n        minY = Math.min(minX, child.y);\n    }\n\n    component.childrenRect.x = minX;\n    component.childrenRect.y = minY;\n    component.childrenRect.width = maxWidth;\n    component.childrenRect.height = maxHeight;\n}\n\nfunction QMLDomElement(meta) {\n    callSuper(this, meta);\n    var tagName = meta.object.tagName || 'div';\n    this.dom = document.createElement(tagName);\n\n    createProperty('string', this, 'tagName');\n\n    // TODO: support properties, styles, perhaps changing the tagName\n}\n\nregisterQmlType({\n    module: 'QmlWeb.Dom',\n    name: 'DomElement',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLDomElement\n});\n\nregisterQmlType({\n    module: 'QmlWeb',\n    name: 'RestModel',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLRestModel(meta) {\n        callSuper(this, meta);\n        var self = this;\n        var attributes = this.getAttributes();\n\n        createProperty(\"string\", this, \"url\");\n        createProperty(\"bool\", this, \"isLoading\");\n        createProperty(\"string\", this, \"mimeType\");\n        createProperty(\"string\", this, \"queryMimeType\");\n\n        this.mimeType = \"application/json\";\n        this.queryMimeType = \"application/x-www-urlencoded\";\n        this.isLoading = false;\n        this.attributes = attributes;\n\n        this.fetched = Signal();\n        this.saved = Signal();\n\n        this.runningRequests = 0;\n\n        this.fetch = function () {\n            ajax({\n                method: 'GET',\n                mimeType: self.mimetype,\n                success: function success(xhr) {\n                    xhrReadResponse(xhr);\n                    self.fetched();\n                }\n            });\n        };\n\n        this.create = function () {\n            sendToServer('POST');\n        };\n\n        this.save = function () {\n            sendToServer('PUT');\n        };\n\n        function sendToServer(method) {\n            var body = generateBodyForPostQuery();\n\n            ajax({\n                method: method,\n                mimeType: self.queryMimeType,\n                body: body,\n                success: function success(xhr) {\n                    xhrReadResponse(xhr);\n                    self.saved();\n                }\n            });\n        }\n\n        this.remove = function () {\n            ajax({\n                method: 'DELETE',\n                success: function success(xhr) {\n                    self.destroy();\n                }\n            });\n        };\n\n        function generateBodyForPostQuery() {\n            var object = {};\n            var body;\n\n            for (var i = 0; i < self.attributes.length; ++i) {\n                object[self.attributes[i]] = self.$properties[self.attributes[i]].get();\n            }console.log(object);\n            if (self.queryMimeType == 'application/json' || self.queryMimeType == 'text/json') body = JSON.stringify(object);else if (self.queryMimeType == 'application/x-www-urlencoded') body = objectToUrlEncoded(object);\n            return body;\n        }\n\n        function myEncodeURIComponent(str) {\n            return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n                return '%' + c.charCodeAt(0).toString(16);\n            });\n        }\n\n        function objectToUrlEncoded(object, prefix) {\n            var str = '';\n            for (var key in object) {\n                if (object.hasOwnProperty(key)) {\n                    var value = object[key];\n                    if (str != '') str += '&';\n                    if (typeof prefix != 'undefined') key = prefix + '[' + key + ']';\n                    if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) == 'object') str += objectToUrlEncoded(value, key);else str += myEncodeURIComponent(key) + '=' + myEncodeURIComponent(value);\n                }\n            }\n            return str;\n        }\n\n        function ajax(options) {\n            var xhr = new XMLHttpRequest();\n\n            xhr.overrideMimeType(self.mimeType);\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState == XMLHttpRequest.DONE) {\n                    if (xhr.status == 200) options.success(xhr);else options.failure(xhr);\n                    self.runningRequests -= 1;\n                    if (self.runningRequests <= 0) self.isLoading = false;\n                }\n            };\n            xhr.open(options.method, self.url, true);\n            if (typeof options.body != 'undefined') {\n                xhr.setRequestHeader('Content-Type', self.queryMimeType);\n                xhr.send(options.body);\n            } else xhr.send(null);\n            self.runningRequests += 1;\n            self.isLoading = true;\n        }\n\n        function xhrReadResponse(xhr) {\n            var responseObject;\n\n            if (self.mimeType == 'application/json' || self.mimeType == 'text/json') {\n                responseObject = JSON.parse(xhr.responseText);\n            }\n            updatePropertiesFromResponseObject(responseObject);\n        }\n\n        function updatePropertiesFromResponseObject(responseObject) {\n            for (var key in responseObject) {\n                if (responseObject.hasOwnProperty(key) && self.$hasProperty(key)) {\n                    self.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n                }\n            }\n        }\n\n        this.$hasProperty = function (name) {\n            return typeof self.$properties[name] != 'undefined';\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'Qt.labs.settings',\n    name: 'Settings',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLSettings(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"string\", this, \"category\");\n\n        if (typeof window.localStorage == 'undefined') return;\n\n        var attributes;\n\n        var getKey = function (attrName) {\n            return this.category + '/' + attrName;\n        }.bind(this);\n\n        var loadProperties = function () {\n            for (var i = 0; i < attributes.length; ++i) {\n                this[attributes[i]] = localStorage.getItem(getKey(attributes[i]));\n            }\n        }.bind(this);\n\n        var initializeProperties = function () {\n            for (var i = 0; i < attributes.length; ++i) {\n                var attrName = attributes[i];\n                var signalName = attrName + 'Changed';\n                var emitter = this;\n\n                if (this.$properties[attrName].type == 'alias') {\n                    emitter = this.$context[this.$properties[attrName].val.objectName];\n                    signalName = this.$properties[attrName].val.propertyName + 'Changed';\n                }\n                emitter[signalName].connect(this, function () {\n                    localStorage.setItem(getKey(this.attrName), this.self[this.attrName]);\n                }.bind({ self: this, attrName: attrName }));\n            }\n        }.bind(this);\n\n        this.Component.completed.connect(this, function () {\n            attributes = this.getAttributes();\n            loadProperties();\n            initializeProperties();\n        }.bind(this));\n    }\n});\n\nregisterQmlType({\n    module: 'QtGraphicalEffects',\n    name: 'FastBlur',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLFastBlur(meta) {\n        callSuper(this, meta);\n\n        var previousSource = null;\n        var filterObject;\n\n        createProperty(\"real\", this, \"radius\");\n        createProperty(\"var\", this, \"source\");\n        this.radius = 0;\n        this.source = null;\n\n        var updateFilterObject = function () {\n            filterObject = {\n                transformType: 'filter',\n                operation: 'blur',\n                parameters: this.radius + 'px'\n            };\n        }.bind(this);\n\n        function stripEffectFromSource(source) {\n            if (previousSource != null) {\n                var index = previousSource.transform.indexOf(filterObject);\n\n                previousSource.transform.splice(index, 1);\n                previousSource.$updateTransform();\n            }\n        }\n\n        function updateEffect(source) {\n            console.log(\"updating effect\");\n            stripEffectFromSource(previousSource);\n            if (source != null && typeof source.transform != 'undefined') {\n                updateFilterObject();\n                console.log(\"updating effect:\", filterObject, source);\n                source.transform.push(filterObject);\n                source.$updateTransform();\n                previousSource = source;\n            } else {\n                previousSource = null;\n            }\n        }\n\n        this.radiusChanged.connect(this, function (newVal) {\n            updateEffect(this.source);\n        }.bind(this));\n\n        this.sourceChanged.connect(this, function (newVal) {\n            updateEffect(this.source);\n        }.bind(this));\n    }\n});\n\nregisterQmlType({\n    module: 'QtMobility',\n    name: 'GeoLocation',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLGeoLocation(meta) {\n        callSuper(this, meta);\n        var self = this;\n\n        createProperty(\"double\", this, \"accuracy\");\n        createProperty(\"double\", this, \"altitude\");\n        createProperty(\"double\", this, \"altitudeAccuracy\");\n        createProperty(\"double\", this, \"heading\");\n        createProperty(\"string\", this, \"label\");\n        createProperty(\"double\", this, \"latitude\");\n        createProperty(\"double\", this, \"longitude\");\n        createProperty(\"double\", this, \"speed\");\n        createProperty(\"date\", this, \"timestamp\");\n\n        if (navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition;\n        }\n\n        var updatePosition = function (position) {\n            this.accuracy = position.coords.accuracy;\n            this.altitude = position.coords.altitude;\n            this.altitudeAccuracy = position.coords.altitudeAccuracy;\n            this.heading = position.coords.heading;\n            this.latitude = position.coords.latitude;\n            this.longitude = position.coords.longitude;\n            this.speed = position.coords.speed;\n            this.timestamp = position.timestamp;\n        }.bind(this);\n\n        navigator.geolocation.getCurrentPosition(updatePosition);\n        navigator.geolocation.watchPosition(updatePosition);\n    }\n});\n\nglobal.MediaPlayer = {\n    NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4, AccessDenied: 8, ServiceMissing: 16,\n    StoppedState: 0, PlayingState: 1, PausedState: 2,\n    NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8, EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n};\n\nglobal.VideoOutput = {\n    PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2\n};\n\nregisterQmlType({\n    module: 'QtMultimedia',\n    name: 'Video',\n    versions: /^5\\./,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLVideo(meta) {\n        callSuper(this, meta);\n\n        var runningEventListener = 0;\n        var volumeBackup;\n\n        var domVideo = this.impl = document.createElement('video');\n        domVideo.style.width = domVideo.style.height = \"100%\";\n        domVideo.style.margin = \"0\";\n        this.dom.appendChild(domVideo);\n\n        createProperty(\"bool\", this, \"autoPlay\");\n        createProperty(\"enum\", this, \"fillMode\");\n        createProperty(\"int\", this, \"duration\");\n        createProperty(\"int\", this, \"position\");\n        createProperty(\"bool\", this, \"muted\");\n        createProperty(\"real\", this, \"playbackRate\");\n        createProperty(\"enum\", this, \"playbackState\");\n        createProperty(\"string\", this, \"source\");\n        createProperty(\"real\", this, \"volume\");\n        createProperty(\"enum\", this, \"status\");\n        createProperty(\"enum\", this, \"error\");\n        this.status = MediaPlayer.NoMedia;\n        this.error = MediaPlayer.NoError;\n        this.fillMode = VideoOutput.PreserveAspectFit;\n        this.volume = domVideo.volume;\n        this.duration = domVideo.duration;\n        this.playbackState = MediaPlayer.StoppedState;\n        this.muted = false;\n\n        this.paused = Signal();\n        this.playing = Signal();\n        this.stopped = Signal();\n\n        this.autoPlayChanged.connect(this, function (newVal) {\n            domVideo.autoplay = newVal;\n        }.bind(this));\n\n        domVideo.addEventListener(\"play\", function () {\n            this.playing();\n            this.playbackState = MediaPlayer.PlayingState;\n        }.bind(this));\n\n        domVideo.addEventListener(\"pause\", function () {\n            this.paused();\n            this.playbackState = MediaPlayer.PausedState;\n        }.bind(this));\n\n        domVideo.addEventListener(\"timeupdate\", function () {\n            runningEventListener++;\n            this.position = domVideo.currentTime * 1000;\n            runningEventListener--;\n        }.bind(this));\n\n        domVideo.addEventListener(\"ended\", function () {\n            this.stopped();\n            this.playbackState = MediaPlayer.StoppedState;\n        }.bind(this));\n\n        domVideo.addEventListener(\"progress\", function () {\n            if (domVideo.buffered.length > 0) {\n                this.progress = domVideo.buffered.end(0) / domVideo.duration;\n                this.status = this.progress < 1 ? MediaPlayer.Buffering : MediaPlayer.Buffered;\n            }\n        }.bind(this));\n\n        domVideo.addEventListener(\"stalled\", function () {\n            this.status = MediaPlayer.Stalled;\n        }.bind(this));\n\n        domVideo.addEventListener(\"canplaythrough\", function () {\n            this.status = MediaPlayer.Buffered;\n        }.bind(this));\n\n        domVideo.addEventListener(\"loadstart\", function () {\n            this.status = MediaPlayer.Loading;\n        }.bind(this));\n\n        domVideo.addEventListener(\"durationchanged\", function () {\n            this.duration = domVideo.duration;\n        }.bind(this));\n\n        domVideo.addEventListener(\"volumechanged\", function () {\n            runningEventListener++;\n            this.volume = demoVideo.volume;\n            runningEventListener--;\n        }.bind(this));\n\n        domVideo.addEventListener(\"suspend\", function () {\n            this.error |= MediaPlayer.NetworkError;\n        }.bind(this));\n\n        domVideo.addEventListener(\"error\", function () {\n            this.error |= MediaPlayer.ResourceError;\n        }.bind(this));\n\n        domVideo.addEventListener(\"ratechange\", function () {\n            runningEventListener++;\n            this.playbackRate = domVideo.playbackRate;\n            runningEventListener--;\n        }.bind(this));\n\n        this.pause = function () {\n            domVideo.pause();\n        }.bind(this);\n\n        this.play = function () {\n            domVideo.play();\n        }.bind(this);\n\n        this.seek = function (offset) {\n            domVideo.currentTime = offset * 1000;\n        }.bind(this);\n\n        this.stop = function () {}.bind(this);\n\n        this.mimetypeFromExtension = function (extension) {\n            var mimetypes = {\n                ogg: 'video/ogg',\n                ogv: 'video/ogg',\n                ogm: 'video/ogg',\n                mp4: 'video/mp4',\n                webm: 'video/webm'\n            };\n\n            if (typeof mimetypes[extension] == 'undefined') return \"\";\n            return mimetypes[extension];\n        };\n\n        this.sourceChanged.connect(this, function (source) {\n            var parts = source.split('.');\n            var extension = parts[parts.length - 1];\n\n            domVideo.src = source;\n            if (domVideo.canPlayType(this.mimetypeFromExtension(extension.toLowerCase())) == \"\") this.error |= MediaPlayer.FormatError;\n        }.bind(this));\n\n        this.positionChanged.connect(this, function (currentTime) {\n            if (runningEventListener == 0) domVideo.currentTime = currentTime / 1000;\n        }.bind(this));\n\n        this.volumeChanged.connect(this, function (volume) {\n            if (runningEventListener == 0) domVideo.volume = volume;\n        }.bind(this));\n\n        this.playbackRateChanged.connect(this, function (playbackRate) {\n            if (runningEventListener == 0) domVideo.playbackRate = playbackRate;\n        }.bind(this));\n\n        this.mutedChanged.connect(this, function (newValue) {\n            if (newValue == true) {\n                volulmeBackup = domVideo.volume;\n                this.volume = 0;\n            } else {\n                this.volume = volumeBackup;\n            }\n        }.bind(this));\n\n        this.fillModeChanged.connect(this, function (newValue) {\n            switch (newValue) {\n                case VideoOutput.Stretch:\n                    domVideo.style.objectFit = 'fill';\n                    break;\n                case VideoOutput.PreserveAspectFit:\n                    domVideo.style.objectFit = '';\n                    break;\n                case VideoOutput.PreserveAspectCrop:\n                    domVideo.style.objectFit = 'cover';\n                    break;\n            }\n        }.bind(this));\n    }\n});\n\nfunction QMLContext() {\n    this.nameForObject = function (obj) {\n        for (var name in this) {\n            if (this[name] == obj) return name;\n        }\n    };\n}\n\nQMLComponent.getAttachedObject = function () {\n    // static\n    if (!this.$Component) {\n        this.$Component = new QObject(this);\n        this.$Component.completed = Signal([]);\n        engine.completedSignals.push(this.$Component.completed);\n\n        this.$Component.destruction = Signal([]);\n    }\n    return this.$Component;\n};\n\nQMLComponent.prototype.createObject = function (parent, properties) {\n    var oldState = engine.operationState;\n    engine.operationState = QMLOperationState.Init;\n    // change base path to current component base path\n    var bp = engine.$basePath;engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n    var context = this.$context ? Object.create(this.$context) : new QMLContext();\n\n    if (this.importContextId !== undefined) {\n        context.importContextId = this.importContextId;\n    }\n\n    var item = construct({\n        object: this.$metaObject,\n        parent: parent,\n        context: context,\n        isComponentRoot: true\n    });\n\n    // change base path back\n    //TODO looks a bit hacky\n    engine.$basePath = bp;\n\n    engine.operationState = oldState;\n    return item;\n};\n\nfunction QMLComponent(meta) {\n    if (constructors[meta.object.$class] == QMLComponent) this.$metaObject = meta.object.$children[0];else this.$metaObject = meta.object;\n    this.$context = meta.context;\n\n    var jsImports = [];\n\n    this.finalizeImports = function ($context) {\n        for (var i = 0; i < jsImports.length; ++i) {\n            var importDesc = jsImports[i];\n            var src = importDesc[1];\n            var js;\n\n            if (typeof engine.$basePath != 'undefined') src = engine.$basePath + src;\n            if (typeof qrc[src] != 'undefined') js = qrc[src];else {\n                loadParser();\n                js = qmlweb_jsparse(getUrlContents(src));\n            }\n            if (importDesc[3] !== \"\") {\n                $context[importDesc[3]] = {};\n                importJavascriptInContext(js, $context[importDesc[3]]);\n            } else importJavascriptInContext(js, $context);\n        }\n    }.bind(this);\n\n    if (meta.object.$imports instanceof Array) {\n        var moduleImports = [];\n        var loadImport = function (importDesc) {\n            if (/\\.js$/.test(importDesc[1])) jsImports.push(importDesc);else moduleImports.push(importDesc);\n        }.bind(this);\n\n        for (var i = 0; i < meta.object.$imports.length; ++i) {\n            loadImport(meta.object.$imports[i]);\n        }\n        loadImports(this, moduleImports);\n        if (typeof this.$context != 'undefined' && this.$context != null) this.finalizeImports(this.$context);\n    }\n}\n\nregisterQmlType({\n    global: true,\n    module: 'QtQml',\n    name: 'Component',\n    versions: /.*/,\n    baseClass: 'QtObject',\n    constructor: QMLComponent\n});\n\nregisterQmlType({\n    module: 'QtQml',\n    name: 'Connections',\n    versions: /.*/,\n    baseClass: 'QtObject',\n    properties: {\n        target: 'QtObject',\n        ignoreUnknownSignals: 'bool'\n    }\n}, function () {\n    function _class(meta) {\n        var _this = this;\n\n        _classCallCheck(this, _class);\n\n        callSuper(this, meta);\n        this.target = this.$parent;\n        this.$connections = {};\n\n        var old_target = this.target;\n        var reconnectTarget = function reconnectTarget() {\n            for (var i in _this.$connections) {\n                var c = _this.$connections[i];\n                if (c._currentConnection && old_target && old_target[i] && typeof old_target[i].disconnect === 'function') {\n                    old_target[i].disconnect(c._currentConnection);\n                }\n                c._currentConnection = connectSignal(_this.target, i, c.value, c.objectScope, c.componentScope);\n            }\n            old_target = _this.target;\n        };\n\n        this.targetChanged.connect(reconnectTarget);\n        this.Component.completed.connect(reconnectTarget);\n    }\n\n    _createClass(_class, [{\n        key: \"$setCustomSlot\",\n        value: function $setCustomSlot(propName, value, objectScope, componentScope) {\n            this.$connections[propName] = { value: value, objectScope: objectScope, componentScope: componentScope };\n        }\n    }]);\n\n    return _class;\n}());\n\nglobal.Qt = {\n    rgba: function rgba(r, g, b, a) {\n        return \"rgba(\" + Math.round(r * 255) + \",\" + Math.round(g * 255) + \",\" + Math.round(b * 255) + \",\" + a + \")\";\n    },\n    hsla: function hsla(h, s, l, a) {\n        return \"hsla(\" + Math.round(h * 360) + \",\" + Math.round(s * 100) + \"%,\" + Math.round(l * 100) + \"%,\" + a + \")\";\n    },\n    openUrlExternally: function openUrlExternally(url) {\n        page = window.open(url, '_blank');\n        page.focus();\n    },\n    // Load file, parse and construct as Component (.qml)\n    createComponent: function createComponent(name) {\n        if (name in engine.components) return engine.components[name];\n\n        var nameIsUrl = name.indexOf(\"//\") >= 0 || name.indexOf(\":/\") >= 0; // e.g. // in protocol, or :/ in disk urls (D:/)\n\n        // Do not perform path lookups if name starts with @ sign.\n        // This is used when we load components from qmldir files\n        // because in that case we do not need any lookups.\n        var origName = name;\n        if (name.length > 0 && name[0] == \"@\") {\n            nameIsUrl = true;\n            name = name.substr(1, name.length - 1);\n        }\n\n        var file = nameIsUrl ? name : engine.$basePath + name;\n\n        var src = getUrlContents(file, true);\n        // if failed to load, and provided name is not direct url, try to load from dirs in importPathList()\n        if (src == false && !nameIsUrl) {\n            var moredirs = engine.importPathList();\n\n            for (var i = 0; i < moredirs.length; i++) {\n                file = moredirs[i] + name;\n                src = getUrlContents(file, true);\n                if (src !== false) break;\n            }\n        }\n\n        // When createComponent failed to load content from all probable sources, it should return undefined.\n        if (src === false) return undefined;\n\n        var tree = parseQML(src, file);\n\n        if (tree.$children.length !== 1) console.error(\"A QML component must only contain one root element!\");\n\n        var QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        var component = new QMLComponent({ object: tree, context: _executionContext });\n        component.$basePath = engine.extractBasePath(file);\n        component.$imports = tree.$imports;\n        component.$file = file; // just for debugging\n\n        engine.loadImports(tree.$imports, component.$basePath, component.importContextId);\n\n        engine.components[origName] = component;\n        return component;\n    },\n\n    createQmlObject: function createQmlObject(src, parent, file) {\n        var tree = parseQML(src, file);\n\n        // Create and initialize objects\n\n        var QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        var component = new QMLComponent({ object: tree, parent: parent, context: _executionContext });\n\n        engine.loadImports(tree.$imports, undefined, component.importContextId);\n\n        if (!file) file = Qt.resolvedUrl(\"createQmlObject_function\");\n        component.$basePath = engine.extractBasePath(file);\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // not just for debugging, but for basepath too, see above\n\n        var obj = component.createObject(parent);\n        obj.parent = parent;\n        parent.childrenChanged();\n\n        if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n            // We don't call those on first creation, as they will be called\n            // by the regular creation-procedures at the right time.\n            engine.$initializePropertyBindings();\n\n            engine.callCompletedSignals();\n        }\n\n        return obj;\n    },\n\n    // Returns url resolved relative to the URL of the caller.\n    // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n    resolvedUrl: function resolvedUrl(url) {\n        if (!url || !url.substr) // url is not a string object\n            return url;\n\n        // Must check for cases: D:/, file://, http://, or slash at the beginning.\n        // This means the url is absolute => we have to skip processing (except removing dot segments).\n        if (url == \"\" || url.indexOf(\":/\") != -1 || url.indexOf(\"/\") == 0) return engine.removeDotSegments(url);\n\n        // we have $basePath variable placed in context of \"current\" document\n        // this is done in construct() function\n\n        // let's go to the callers and inspect their arguments\n        // The 2-nd argument of the callers we hope is context object\n        // e.g. see calling signature of bindings and signals\n\n        var detectedBasePath = \"\";\n        var currentCaller = Qt.resolvedUrl.caller;\n        var maxcount = 10;\n        while (maxcount-- > 0 && currentCaller) {\n            if (currentCaller.arguments[1] && currentCaller.arguments[1][\"$basePath\"]) {\n                detectedBasePath = currentCaller.arguments[1][\"$basePath\"];\n                break;\n            }\n            currentCaller = currentCaller.caller;\n        }\n\n        return engine.removeDotSegments(detectedBasePath + url);\n    },\n\n    // Buttons masks\n    LeftButton: 1,\n    RightButton: 2,\n    MiddleButton: 4,\n    // Modifiers masks\n    NoModifier: 0,\n    ShiftModifier: 1,\n    ControlModifier: 2,\n    AltModifier: 4,\n    MetaModifier: 8,\n    KeypadModifier: 16, // Note: Not available in web\n    // Layout directions\n    LeftToRight: 0,\n    RightToLeft: 1,\n    // Orientations\n    Vertical: 0,\n    Horizontal: 1,\n    // Keys\n    Key_Escape: 27,\n    Key_Tab: 9,\n    Key_Backtab: 245,\n    Key_Backspace: 8,\n    Key_Return: 13,\n    Key_Enter: 13,\n    Key_Insert: 45,\n    Key_Delete: 46,\n    Key_Pause: 19,\n    Key_Print: 42,\n    Key_SysReq: 0,\n    Key_Clear: 12,\n    Key_Home: 36,\n    Key_End: 35,\n    Key_Left: 37,\n    Key_Up: 38,\n    Key_Right: 39,\n    Key_Down: 40,\n    Key_PageUp: 33,\n    Key_PageDown: 34,\n    Key_Shift: 16,\n    Key_Control: 17,\n    Key_Meta: 91,\n    Key_Alt: 18,\n    Key_AltGr: 0,\n    Key_CapsLock: 20,\n    Key_NumLock: 144,\n    Key_ScrollLock: 145,\n    Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117, Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122, Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127, Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132, Key_F22: 133, Key_F23: 134, Key_F24: 135, Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0, Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n    Key_Super_L: 0,\n    Key_Super_R: 0,\n    Key_Menu: 0,\n    Key_Hyper_L: 0,\n    Key_Hyper_R: 0,\n    Key_Help: 6,\n    Key_Direction_L: 0,\n    Key_Direction_R: 0,\n    Key_Space: 32,\n    Key_Any: 32,\n    Key_Exclam: 161,\n    Key_QuoteDbl: 162,\n    Key_NumberSign: 163,\n    Key_Dollar: 164,\n    Key_Percent: 165,\n    Key_Ampersant: 166,\n    Key_Apostrophe: 222,\n    Key_ParenLeft: 168,\n    Key_ParenRight: 169,\n    Key_Asterisk: 170,\n    Key_Plus: 171,\n    Key_Comma: 188,\n    Key_Minus: 173,\n    Key_Period: 190,\n    Key_Slash: 191,\n    Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52, Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n    Key_Colon: 58,\n    Key_Semicolon: 59,\n    Key_Less: 60,\n    Key_Equal: 61,\n    Key_Greater: 62,\n    Key_Question: 63,\n    Key_At: 64,\n    Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71, Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78, Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85, Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n    Key_BracketLeft: 219,\n    Key_Backslash: 220,\n    Key_BracketRight: 221,\n    Key_AsciiCircum: 160,\n    Key_Underscore: 167,\n    Key_QuoteLeft: 0,\n    Key_BraceLeft: 174,\n    Key_Bar: 172,\n    Key_BraceRight: 175,\n    Key_AsciiTilde: 176,\n    Key_Back: 0,\n    Key_Forward: 0,\n    Key_Stop: 0,\n    Key_VolumeDown: 182,\n    Key_VolumeUp: 183,\n    Key_VolumeMute: 181,\n    Key_multiply: 106,\n    Key_add: 107,\n    Key_substract: 109,\n    Key_divide: 111,\n    Key_News: 0,\n    Key_OfficeHome: 0,\n    Key_Option: 0,\n    Key_Paste: 0,\n    Key_Phone: 0,\n    Key_Calendar: 0,\n    Key_Reply: 0,\n    Key_Reload: 0,\n    Key_RotateWindows: 0,\n    Key_RotationPB: 0,\n    Key_RotationKB: 0,\n    Key_Save: 0,\n    Key_Send: 0,\n    Key_Spell: 0,\n    Key_SplitScreen: 0,\n    Key_Support: 0,\n    Key_TaskPane: 0,\n    Key_Terminal: 0,\n    Key_Tools: 0,\n    Key_Travel: 0,\n    Key_Video: 0,\n    Key_Word: 0,\n    Key_Xfer: 0,\n    Key_ZoomIn: 0,\n    Key_ZoomOut: 0,\n    Key_Away: 0,\n    Key_Messenger: 0,\n    Key_WebCam: 0,\n    Key_MailForward: 0,\n    Key_Pictures: 0,\n    Key_Music: 0,\n    Key_Battery: 0,\n    Key_Bluetooth: 0,\n    Key_WLAN: 0,\n    Key_UWB: 0,\n    Key_AudioForward: 0,\n    Key_AudioRepeat: 0,\n    Key_AudioRandomPlay: 0,\n    Key_Subtitle: 0,\n    Key_AudioCycleTrack: 0,\n    Key_Time: 0,\n    Key_Hibernate: 0,\n    Key_View: 0,\n    Key_TopMenu: 0,\n    Key_PowerDown: 0,\n    Key_Suspend: 0,\n    Key_ContrastAdjust: 0,\n    Key_MediaLast: 0,\n    Key_unknown: -1,\n    Key_Call: 0,\n    Key_Camera: 0,\n    Key_CameraFocus: 0,\n    Key_Context1: 0,\n    Key_Context2: 0,\n    Key_Context3: 0,\n    Key_Context4: 0,\n    Key_Flip: 0,\n    Key_Hangup: 0,\n    Key_No: 0,\n    Key_Select: 93,\n    Key_Yes: 0,\n    Key_ToggleCallHangup: 0,\n    Key_VoiceDial: 0,\n    Key_LastNumberRedial: 0,\n    Key_Execute: 43,\n    Key_Printer: 42,\n    Key_Play: 250,\n    Key_Sleep: 95,\n    Key_Zoom: 251,\n    Key_Cancel: 3,\n    // Align\n    AlignLeft: 0x0001,\n    AlignRight: 0x0002,\n    AlignHCenter: 0x0004,\n    AlignJustify: 0x0008,\n    AlignTop: 0x0020,\n    AlignBottom: 0x0040,\n    AlignVCenter: 0x0080,\n    AlignCenter: 0x0084,\n    AlignBaseline: 0x0100,\n    AlignAbsolute: 0x0010,\n    AlignLeading: 0x0001,\n    AlignTrailing: 0x0002,\n    AlignHorizontal_Mask: 0x001f,\n    AlignVertical_Mask: 0x01e0,\n    // Screen\n    PrimaryOrientation: 0,\n    PortraitOrientation: 1,\n    LandscapeOrientation: 2,\n    InvertedPortraitOrientation: 4,\n    InvertedLandscapeOrientation: 8,\n    // CursorShape\n    ArrowCursor: 0,\n    UpArrowCursor: 1,\n    CrossCursor: 2,\n    WaitCursor: 3,\n    IBeamCursor: 4,\n    SizeVerCursor: 5,\n    SizeHorCursor: 6,\n    SizeBDiagCursor: 7,\n    SizeFDiagCursor: 8,\n    SizeAllCursor: 9,\n    BlankCursor: 10,\n    SplitVCursor: 11,\n    SplitHCursor: 12,\n    PointingHandCursor: 13,\n    ForbiddenCursor: 14,\n    WhatsThisCursor: 15,\n    BusyCursor: 16,\n    OpenHandCursor: 17,\n    ClosedHandCursor: 18,\n    DragCopyCursor: 19,\n    DragMoveCursor: 20,\n    DragLinkCursor: 21,\n    LastCursor: 21, //DragLinkCursor,\n    BitmapCursor: 24,\n    CustomCursor: 25,\n    // ScrollBar Policy\n    ScrollBarAsNeeded: 0,\n    ScrollBarAlwaysOff: 1,\n    ScrollBarAlwaysOn: 2\n};\n\n// Base object for all qml elements\nfunction QMLBaseObject(meta) {\n    QObject.call(this, meta.parent);\n    var i, prop;\n\n    this.$isComponentRoot = meta.isComponentRoot;\n    this.$context = meta.context;\n\n    // Component get own properties\n    var attributes = [];\n    for (var key in meta.object) {\n        if (meta.object.hasOwnProperty(key) && typeof meta.object[key] != 'undefined' && meta.object[key] != null && (meta.object[key].__proto__.constructor.name == 'QMLPropertyDefinition' || meta.object[key].__proto__.constructor.name == 'QMLAliasDefinition')) {\n            attributes.push(key);\n        }\n    }\n\n    this.Keys = new QObject(this);\n    this.Keys.asteriskPresed = Signal();\n    this.Keys.backPressed = Signal();\n    this.Keys.backtabPressed = Signal();\n    this.Keys.callPressed = Signal();\n    this.Keys.cancelPressed = Signal();\n    this.Keys.deletePressed = Signal();\n    for (var i = 0; i < 10; ++i) {\n        this.Keys['digit' + i + 'Pressed'] = Signal();\n    }this.Keys.escapePressed = Signal();\n    this.Keys.flipPressed = Signal();\n    this.Keys.hangupPressed = Signal();\n    this.Keys.leftPressed = Signal();\n    this.Keys.menuPressed = Signal();\n    this.Keys.noPressed = Signal();\n    this.Keys.pressed = Signal();\n    this.Keys.released = Signal();\n    this.Keys.returnPressed = Signal();\n    this.Keys.rightPressed = Signal();\n    this.Keys.selectPressed = Signal();\n    this.Keys.spacePressed = Signal();\n    this.Keys.tabPressed = Signal();\n    this.Keys.upPressed = Signal();\n    this.Keys.volumeDownPressed = Signal();\n    this.Keys.volumeUpPressed = Signal();\n    this.Keys.yesPressed = Signal();\n\n    this.getAttributes = function () {\n        return attributes;\n    };\n}\n\nregisterQmlType({\n    module: 'QtQml',\n    name: 'QtObject',\n    versions: /.*/,\n    constructor: QMLBaseObject\n});\n\nregisterQmlType({\n    module: 'QtQml',\n    name: 'Timer',\n    versions: /.*/,\n    baseClass: 'QtObject',\n    constructor: function QMLTimer(meta) {\n        callSuper(this, meta);\n        var prevTrigger,\n            self = this;\n\n        createProperty(\"int\", this, \"interval\", { initialValue: 1000 });\n        createProperty(\"bool\", this, \"repeat\");\n        createProperty(\"bool\", this, \"running\");\n        createProperty(\"bool\", this, \"triggeredOnStart\");\n\n        // Create trigger as simple property. Reading the property triggers\n        // the function!\n        this.triggered = Signal();\n\n        engine.$addTicker(ticker);\n        function ticker(now, elapsed) {\n            if (self.running) {\n                if (now - prevTrigger >= self.interval) {\n                    prevTrigger = now;\n                    trigger();\n                }\n            }\n        }\n\n        /* This ensures that if the user toggles the \"running\" property manually,\n         * the timer will trigger. */\n        this.runningChanged.connect(this, function () {\n            if (this.running) {\n                prevTrigger = new Date().getTime();\n                if (this.triggeredOnStart) {\n                    trigger();\n                }\n            }\n        });\n\n        this.start = function () {\n            this.running = true;\n        };\n        this.stop = function () {\n            this.running = false;\n        };\n        this.restart = function () {\n            this.stop();\n            this.start();\n        };\n\n        function trigger() {\n            if (!self.repeat)\n                // We set the value directly in order to be able to emit the runningChanged\n                // signal after triggered, like Qt does it.\n                self.$properties.running.val = false;\n\n            // Trigger this.\n            self.triggered();\n\n            if (!self.repeat)\n                // Emit changed signal manually after setting the value manually above.\n                self.runningChanged();\n        }\n\n        engine.$registerStart(function () {\n            if (self.running) {\n                self.running = false; // toggled back by self.start();\n                self.start();\n            }\n        });\n\n        engine.$registerStop(function () {\n            self.stop();\n        });\n    }\n});\n\nfunction QMLButton(meta) {\n    var _this2 = this;\n\n    callSuper(this, meta);\n\n    var button = this.impl = document.createElement('button');\n    button.style.pointerEvents = 'auto';\n    this.dom.appendChild(button);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"bool\", this, \"enabled\", { initialValue: true });\n    this.clicked = Signal();\n\n    this.Component.completed.connect(this, function () {\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.textChanged.connect(this, function (newVal) {\n        button.textContent = newVal;\n        //TODO: Replace those statically sized borders\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.enabledChanged.connect(this, function (newVal) {\n        button.disabled = !newVal;\n    });\n\n    button.onclick = function () {\n        _this2.clicked();\n    };\n}\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'Button',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLButton\n});\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'CheckBox',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: function QMLCheckbox(meta) {\n        callSuper(this, meta);\n\n        var label = this.impl = document.createElement('label');\n        label.style.pointerEvents = 'auto';\n\n        var checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.style.verticalAlign = 'text-bottom';\n        label.appendChild(checkbox);\n\n        var span = document.createElement('span');\n        label.appendChild(span);\n\n        this.dom.appendChild(label);\n\n        var self = this;\n\n        var QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n        this.font = new QMLFont(this);\n\n        createProperty(\"string\", this, \"text\");\n        createProperty(\"bool\", this, \"checked\");\n        createProperty(\"color\", this, \"color\");\n\n        this.Component.completed.connect(this, function () {\n            this.implicitHeight = label.offsetHeight;\n            this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n        });\n        this.textChanged.connect(this, function (newVal) {\n            span.innerHTML = newVal;\n            this.implicitHeight = label.offsetHeight;\n            this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n        });\n        this.colorChanged.connect(this, function (newVal) {\n            span.style.color = QMLColor(newVal);\n        });\n\n        this.checkedChanged.connect(this, function (newVal) {\n            checkbox.checked = self.checked;\n        });\n\n        checkbox.onchange = function () {\n            self.checked = this.checked;\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'ComboBox',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLComboBox\n});\n\nfunction QMLComboBox(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    createProperty(\"int\", this, \"count\");\n    createProperty(\"int\", this, \"currentIndex\");\n    createProperty(\"string\", this, \"currentText\");\n    createProperty(\"array\", this, \"menu\");\n    createProperty(\"array\", this, \"model\");\n    createProperty(\"bool\", this, \"pressed\");\n\n    this.count = 0;\n    this.currentIndex = 0;\n    this.currentText = \"\";\n    this.menu = [];\n    this.model = [];\n    this.pressed = false;\n\n    var updateCB = function updateCB() {\n        var head = \"<select>\";\n        var tail = \"</select>\";\n        var html = head;\n\n        var model = self.model;\n        var count = model.length;\n        self.count = count;\n\n        for (var i = 0; i < count; i++) {\n            var elt = model[i];\n            //if (elt instanceof Array) { // TODO - optgroups? update model !\n            //    var count_i = elt.length;\n            //    for (var j = 0; j < count_i; j++)\n            //        html += \"<option>\" + elt[j] + \"</option>\";\n            //}\n            //else\n            html += \"<option>\" + elt + \"</option>\";\n        }\n        html += tail;\n        return html;\n    };\n\n    this.accepted = Signal();\n    this.activated = Signal([{ type: \"int\", name: \"index\" }]);\n\n    this.find = function (text) {\n        return self.model.indexOf(text);\n    };\n    this.selectAll = function () {}; // TODO\n    this.textAt = function (index) {\n        return this.model[index];\n    };\n\n    this.Component.completed.connect(this, function () {\n        this.dom.innerHTML = updateCB();\n        var child = this.dom.firstChild;\n        this.implicitWidth = child.offsetWidth;\n        this.implicitHeight = child.offsetHeight;\n    });\n\n    this.modelChanged.connect(updateCB);\n\n    this.dom.onclick = function (e) {\n        var index = self.dom.firstChild.selectedIndex;\n        self.currentIndex = index;\n        self.currentText = self.model[index];\n        self.accepted();\n        self.activated(index);\n    };\n}\n\nfunction QMLScrollView(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    createProperty(\"Item\", this, \"contentItem\");\n    this.$defaultProperty = \"contentItem\";\n    createProperty(\"Item\", this, \"flickableItem\"); //TODO  0) implement it  1) make it read-only\n    createProperty(\"Item\", this, \"viewport\"); //TODO\n    createProperty(\"bool\", this, \"frameVisible\");\n    createProperty(\"bool\", this, \"highlightOnFocus\"); //TODO test\n    createProperty(\"enum\", this, \"verticalScrollBarPolicy\");\n    createProperty(\"enum\", this, \"horizontalScrollBarPolicy\");\n    createProperty(\"Component\", this, \"style\"); //TODO\n\n    this.contentItemChanged.connect(this, function (newItem) {\n        if ((typeof newItem === \"undefined\" ? \"undefined\" : _typeof(newItem)) !== undefined) {\n            newItem.parent = self;\n        }\n    });\n    this.flickableItemChanged.connect(this, function (newItem) {});\n    this.viewportChanged.connect(this, function (newViewport) {});\n    this.frameVisibleChanged.connect(this, function (visible) {\n        this.css.border = visible ? \"1px solid gray\" : \"hidden\";\n    });\n    this.highlightOnFocusChanged.connect(this, function (highlight) {});\n\n    this.horizontalScrollBarPolicyChanged.connect(this, function (newPolicy) {\n        this.css.overflowX = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n    this.verticalScrollBarPolicyChanged.connect(this, function (newPolicy) {\n        this.css.overflowY = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n\n    this.styleChanged.connect(this, function (newStyle) {});\n\n    ////\n    this.childrenChanged.connect(this, function () {\n        if (_typeof(self.contentItem) == undefined && self.children.length == 1) {\n            self.contentItem = self.children[0];\n        }\n    });\n    this.focusChanged.connect(this, function (focus) {\n        this.css.outline = self.highlight && focus ? \"outline: lightblue solid 2px;\" : \"\";\n    });\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n}\n\nQMLScrollView.prototype.scrollBarPolicyToCssOverflow = function (policy) {\n    switch (policy) {\n        case Qt.ScrollBarAsNeeded:\n            return 'auto';\n        case Qt.ScrollBarAlwaysOff:\n            return 'hidden';\n        case Qt.ScrollBarAlwaysOn:\n            return 'scroll';\n    }\n    return 'auto';\n};\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'ScrollView',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLScrollView\n});\n\nfunction QMLTextArea(meta) {\n    callSuper(this, meta);\n    var textarea = this.impl;\n    textarea.style.padding = '5px';\n    textarea.style.borderWidth = '1px';\n    textarea.style.backgroundColor = '#fff';\n}\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'TextArea',\n    versions: /.*/,\n    baseClass: 'QtQuick.TextEdit',\n    constructor: QMLTextArea\n});\n\n/**\n *\n * TextField is used to accept a line of text input.\n * Input constraints can be placed on a TextField item\n * (for example, through a validator or inputMask).\n * Setting echoMode to an appropriate value enables TextField\n * to be used for a password input field.\n *\n * Valid entries for echoMode and alignment are defined in TextInput.\n *\n */\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'TextField',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLTextInput\n});\n\nfunction QMLTextInput(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    var QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    var input = this.impl = document.createElement('input');\n    input.type = 'text';\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n\n    this.setupFocusOnDom(input);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"int\", this, \"maximumLength\");\n    createProperty(\"bool\", this, \"readOnly\");\n    createProperty(\"var\", this, \"validator\");\n    createProperty(\"enum\", this, \"echoMode\");\n    this.accepted = Signal();\n    this.readOnly = false;\n    this.maximumLength = -1;\n    input.disabled = false;\n\n    this.Component.completed.connect(this, function () {\n        this.implicitWidth = input.offsetWidth;\n        this.implicitHeight = input.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function (newVal) {\n        input.value = newVal;\n    });\n\n    this.echoModeChanged.connect(this, function (newVal) {\n        switch (newVal) {\n            case TextField.Normal:\n                input.type = \"text\";\n                break;\n            case TextField.Password:\n                input.type = \"password\";\n                break;\n        }\n    }.bind(this));\n\n    this.maximumLengthChanged.connect(this, function (newVal) {\n        if (newVal < 0) newVal = null;\n        input.maxLength = newVal;\n    });\n\n    this.readOnlyChanged.connect(this, function (newVal) {\n        input.disabled = newVal;\n    });\n\n    this.Keys.pressed.connect(this, function (e) {\n        if ((e.key === Qt.Key_Return || e.key === Qt.Key_Enter) && testValidator()) {\n            self.accepted();\n            e.accepted = true;\n        }\n    }.bind(this));\n\n    function testValidator() {\n        if (typeof self.validator !== 'undefined' && self.validator !== null) return self.validator.validate(self.text);\n        return true;\n    }\n\n    function updateValue(e) {\n        if (self.text !== self.dom.firstChild.value) {\n            self.$canEditReadOnlyProperties = true;\n            self.text = self.dom.firstChild.value;\n            self.$canEditReadOnlyProperties = false;\n        }\n    }\n\n    input.oninput = updateValue;\n    input.onpropertychanged = updateValue;\n}\n\nregisterQmlType({\n    module: 'QtQuick.Window',\n    name: 'Screen',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLScreen\n});\n\nfunction QMLScreen(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    // TODO: rewrite as an attached object and forbid constructing\n\n    createProperty(\"int\", this, \"desktopAvailableHeight\");\n    createProperty(\"int\", this, \"desktopAvailableWidth\");\n    createProperty(\"real\", this, \"devicePixelRatio\");\n    createProperty(\"int\", this, \"height\");\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"enum\", this, \"orientation\");\n    createProperty(\"enum\", this, \"orientationUpdateMask\");\n    createProperty(\"real\", this, \"pixelDensity\");\n    createProperty(\"enum\", this, \"primaryOrientation\");\n    createProperty(\"int\", this, \"width\");\n\n    this.Component.completed.connect(this, updateSC);\n\n    function updateSC() {\n        self.desktopAvailableHeight = window.outerHeight;\n        self.desktopAvailableWidth = window.outerWidth;\n        self.devicePixelRatio = window.devicePixelRatio;\n        self.height = window.innerHeight;\n        self.name = this.name;\n        self.orientation = Qt.PrimaryOrientation;\n        self.orientationUpdateMask = 0;\n        self.pixelDensity = 100.0; // TODO\n        self.primaryOrientation = Qt.PrimaryOrientation;\n        self.width = window.innerWidth;\n    }\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'AnimatedImage',\n    versions: /.*/,\n    baseClass: 'Image',\n    constructor: function QMLAnimatedImage(meta) {\n        callSuper(this, meta);\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Animation',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    enums: {\n        Animation: {\n            Infinite: -1\n        }\n    },\n    properties: {\n        alwaysRunToEnd: 'bool',\n        loops: { type: 'int', initialValue: 1 },\n        paused: 'bool',\n        running: 'bool'\n    }\n}, function () {\n    function _class2(meta) {\n        _classCallCheck(this, _class2);\n\n        callSuper(this, meta);\n    }\n\n    _createClass(_class2, [{\n        key: \"restart\",\n        value: function restart() {\n            this.stop();\n            this.start();\n        }\n    }, {\n        key: \"start\",\n        value: function start() {\n            this.running = true;\n        }\n    }, {\n        key: \"stop\",\n        value: function stop() {\n            this.running = false;\n        }\n    }, {\n        key: \"pause\",\n        value: function pause() {\n            this.paused = true;\n        }\n    }, {\n        key: \"resume\",\n        value: function resume() {\n            this.paused = false;\n        }\n    }, {\n        key: \"complete\",\n        value: function complete() {\n            // To be overridden\n            console.log('Unbound method for', this);\n        }\n    }]);\n\n    return _class2;\n}());\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Behavior',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLBehavior(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"Animation\", this, \"animation\");\n        this.$defaultProperty = \"animation\";\n        createProperty(\"bool\", this, \"enabled\", { initialValue: true });\n\n        this.animationChanged.connect(this, function (newVal) {\n            newVal.target = this.$parent;\n            newVal.property = meta.object.$on;\n            this.$parent.$properties[meta.object.$on].animation = newVal;\n        });\n        this.enabledChanged.connect(this, function (newVal) {\n            this.$parent.$properties[meta.object.$on].animation = newVal ? this.animation : null;\n        });\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'BorderImage',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLBorderImage(meta) {\n        callSuper(this, meta);\n        var self = this;\n\n        this.BorderImage = {\n            // tileMode\n            Stretch: \"stretch\",\n            Repeat: \"repeat\",\n            Round: \"round\",\n            // status\n            Null: 1,\n            Ready: 2,\n            Loading: 3,\n            Error: 4\n        };\n\n        createProperty(\"url\", this, \"source\");\n        createProperty(\"enum\", this, \"status\", { initialValue: this.BorderImage.Null });\n        this.border = new QObject(this);\n        createProperty(\"int\", this.border, \"left\");\n        createProperty(\"int\", this.border, \"right\");\n        createProperty(\"int\", this.border, \"top\");\n        createProperty(\"int\", this.border, \"bottom\");\n        createProperty(\"enum\", this, \"horizontalTileMode\", { initialValue: this.BorderImage.Stretch });\n        createProperty(\"enum\", this, \"verticalTileMode\", { initialValue: this.BorderImage.Stretch });\n\n        this.sourceChanged.connect(this, function () {\n            this.dom.style.borderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        });\n        this.border.leftChanged.connect(this, updateBorder);\n        this.border.rightChanged.connect(this, updateBorder);\n        this.border.topChanged.connect(this, updateBorder);\n        this.border.bottomChanged.connect(this, updateBorder);\n        this.horizontalTileModeChanged.connect(this, updateBorder);\n        this.verticalTileModeChanged.connect(this, updateBorder);\n\n        function updateBorder() {\n            this.dom.style.MozBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n            this.dom.style.MozBorderImageSlice = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left + \" \" + \"fill\";\n            this.dom.style.MozBorderImageRepeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n            this.dom.style.MozBorderImageWidth = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left;\n\n            this.dom.style.webkitBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n            this.dom.style.webkitBorderImageSlice = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left + \" \" + \"fill\";\n            this.dom.style.webkitBorderImageRepeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n            this.dom.style.webkitBorderImageWidth = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left;\n\n            this.dom.style.OBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n            this.dom.style.OBorderImageSlice = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left + \" \" + \"fill\";\n            this.dom.style.OBorderImageRepeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n            this.dom.style.OBorderImageWidth = this.border.top + \"px \" + this.border.right + \"px \" + this.border.bottom + \"px \" + this.border.left + \"px\";\n\n            this.dom.style.borderImageSlice = this.border.top + \" \" + this.border.right + \" \" + this.border.bottom + \" \" + this.border.left + \" \" + \"fill\";\n            this.dom.style.borderImageRepeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n            this.dom.style.borderImageWidth = this.border.top + \"px \" + this.border.right + \"px \" + this.border.bottom + \"px \" + this.border.left + \"px\";\n        }\n    }\n});\n\n// TODO\n// Currently only a skeleton implementation\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Canvas',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function constructor(meta) {\n        callSuper(this, meta);\n\n        var self = this;\n\n        createProperty('bool', this, 'available');\n        createProperty('var', this, 'canvasSize');\n        createProperty('var', this, 'canvasWindow');\n        createProperty('var', this, 'context');\n        createProperty('string', this, 'contextType');\n        createProperty('enum', this, 'renderStrategy');\n        createProperty('enum', this, 'renderTarget');\n        createProperty('var', this, 'tileSize');\n\n        this.available = true;\n        this.canvasSize = [0, 0];\n        this.canvasWindow = [0, 0, 0, 0];\n        this.context = {};\n        this.contextType = \"contextType\";\n        this.renderStrategy = 0;\n        this.renderTarget = 0;\n        this.tileSize = [0, 0];\n\n        this.imageLoaded = Signal();\n        this.paint = Signal([{ type: \"var\", name: \"region\" }]);\n        this.painted = Signal();\n\n        this.cancelRequestAnimationFrame = function (handle) {\n            return false;\n        };\n\n        this.getContext = function (context_id) {\n            var args = arguments.slice(1, arguments.length);\n            return {};\n        };\n\n        this.isImageError = function (image) {\n            return true;\n        };\n\n        this.isImageLoaded = function (image) {\n            return false;\n        };\n\n        this.isImageLoading = function (image) {\n            return false;\n        };\n\n        this.loadImage = function (image) {\n            //loadImageAsync(image);\n            if (this.isImageLoaded(image)) this.imageLoaded();\n        };\n\n        this.markDirty = function (area) {\n            // if dirty\n            this.paint(area);\n        };\n\n        this.requestAnimationFrame = function (callback) {\n            return 0;\n        };\n\n        this.requestPaint = function () {};\n\n        this.save = function (file_name) {\n            return false;\n        };\n\n        this.toDataURL = function (mime_type) {\n            return \"\";\n        };\n\n        this.unloadImage = function (image) {};\n    }\n});\n\nfunction QMLColumn(meta) {\n    callSuper(this, meta);\n}\n\nQMLColumn.prototype.layoutChildren = function () {\n    var curPos = 0,\n        maxWidth = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height)) continue;\n        maxWidth = child.width > maxWidth ? child.width : maxWidth;\n\n        child.y = curPos;\n        curPos += child.height + this.spacing;\n    }\n    this.implicitWidth = maxWidth;\n    this.implicitHeight = curPos - this.spacing; // We want no spacing at the bottom side\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Column',\n    versions: /.*/,\n    baseClass: 'Positioner',\n    constructor: QMLColumn\n});\n\nglobal.DoubleValidator = {\n    StandardNotation: 1, ScientificNotation: 2\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'DoubleValidator',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLDoubleValidator(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"real\", this, \"bottom\");\n        createProperty(\"real\", this, \"top\");\n        createProperty(\"int\", this, \"decimals\");\n        createProperty(\"enum\", this, \"notation\");\n        this.bottom = -Infinity;\n        this.top = Infinity;\n        this.decimals = 1000;\n        this.notation = DoubleValidator.ScientificNotation;\n\n        var standardRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n        var scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n\n        this.getRegExpForNotation = function (notation) {\n            switch (notation) {\n                case DoubleValidator.ScientificNotation:\n                    return scientificRegExp;\n                    break;\n                case DoubleValidator.StandardNotation:\n                    return standardRegExp;\n                    break;\n            }\n            return null;\n        }.bind(this);\n\n        function getDecimalsForNumber(number) {\n            if (Math.round(number) != number) {\n                var str = '' + number;\n\n                return (/\\d*$/.exec(str)[0].length\n                );\n            }\n            return 0;\n        }\n\n        this.validate = function (string) {\n            var regExp = this.getRegExpForNotation(this.notation);\n            var acceptable = regExp.test(string.trim());\n\n            if (acceptable) {\n                var value = parseFloat(string);\n\n                acceptable = this.bottom <= value && this.top >= value;\n                acceptable = acceptable && getDecimalsForNumber(value) <= this.decimals;\n            }\n            return acceptable;\n        }.bind(this);\n    }\n});\n\nglobal.Easing = {\n    Linear: 1,\n    InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,\n    InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,\n    InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,\n    InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,\n    InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,\n    InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,\n    InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,\n    InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,\n    InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,\n    InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41\n};\n\nfunction QMLFlow(meta) {\n    callSuper(this, meta);\n\n    this.Flow = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    };\n\n    createProperty(\"enum\", this, \"flow\", { initialValue: this.Flow.LeftToRight });\n    createProperty(\"enum\", this, \"layoutDirection\", { initialValue: 0 });\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLFlow.prototype.layoutChildren = function () {\n    var curHPos = 0,\n        curVPos = 0,\n        rowSize = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height)) continue;\n\n        if (this.flow == this.Flow.LeftToRight) {\n            if (curHPos + child.width > this.width) {\n                curHPos = 0;\n                curVPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.height > rowSize ? child.height : rowSize;\n\n            child.x = this.layoutDirection == 1 ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curHPos += child.width + this.spacing;\n        } else {\n            if (curVPos + child.height > this.height) {\n                curVPos = 0;\n                curHPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.width > rowSize ? child.width : rowSize;\n\n            child.x = this.layoutDirection == 1 ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curVPos += child.height + this.spacing;\n        }\n    }\n    if (this.flow == 0) this.implicitHeight = curVPos + rowSize;else this.implicitWidth = curHPos + rowSize;\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Flow',\n    versions: /.*/,\n    baseClass: 'Positioner',\n    constructor: QMLFlow\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Font',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLFont(parent) {\n        var _this3 = this;\n\n        QObject.call(this);\n        createProperty(\"bool\", this, \"bold\");\n        createProperty(\"enum\", this, \"capitalization\", { initialValue: 0 });\n        createProperty(\"string\", this, \"family\", { initialValue: 'sans-serif' });\n        createProperty(\"bool\", this, \"italic\");\n        createProperty(\"real\", this, \"letterSpacing\");\n        createProperty(\"int\", this, \"pixelSize\", { initialValue: 13 });\n        createProperty(\"real\", this, \"pointSize\", { initialValue: 10 });\n        createProperty(\"bool\", this, \"strikeout\");\n        createProperty(\"bool\", this, \"underline\");\n        createProperty(\"enum\", this, \"weight\");\n        createProperty(\"real\", this, \"wordSpacing\");\n        var sizeLock = false;\n\n        this.boldChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.fontWeight = parent.font.weight !== undefined ? parent.font.weight : newVal ? \"bold\" : \"normal\";\n        });\n        this.capitalizationChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.fontVariant = newVal == \"smallcaps\" ? \"small-caps\" : \"normal\";\n            newVal = newVal == \"smallcaps\" ? \"none\" : newVal;\n            parent.dom.firstChild.style.textTransform = newVal;\n        });\n        this.familyChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.fontFamily = newVal;\n        });\n        this.italicChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.fontStyle = newVal ? \"italic\" : \"normal\";\n        });\n        this.letterSpacingChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.letterSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n        this.pixelSizeChanged.connect(function (newVal) {\n            if (!sizeLock) {\n                _this3.pointSize = newVal * 0.75;\n            }\n            var val = newVal + 'px';\n            parent.dom.style.fontSize = val;\n            parent.dom.firstChild.style.fontSize = val;\n        });\n        this.pointSizeChanged.connect(function (newVal) {\n            sizeLock = true;\n            _this3.pixelSize = Math.round(newVal / 0.75);\n            sizeLock = false;\n        });\n        this.strikeoutChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.textDecoration = newVal ? \"line-through\" : parent.font.underline ? \"underline\" : \"none\";\n        });\n        this.underlineChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.textDecoration = parent.font.strikeout ? \"line-through\" : newVal ? \"underline\" : \"none\";\n        });\n        this.weightChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.fontWeight = newVal !== undefined ? newVal : parent.font.bold ? \"bold\" : \"normal\";\n        });\n        this.wordSpacingChanged.connect(function (newVal) {\n            parent.dom.firstChild.style.wordSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n    }\n});\n\nglobal.Font = {\n    // Capitalization\n    MixedCase: \"none\",\n    AllUppercase: \"uppercase\",\n    AllLowercase: \"lowercase\",\n    SmallCaps: \"smallcaps\",\n    Capitalize: \"capitalize\",\n    // Weight\n    Light: \"lighter\",\n    Normal: \"normal\",\n    DemiBold: \"600\",\n    Bold: \"bold\",\n    Black: \"bolder\"\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'FontLoader',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLFontLoader(meta) {\n        callSuper(this, meta);\n\n        // Exports.\n        this.FontLoader = {\n            // status\n            Null: 0,\n            Ready: 1,\n            Loading: 2,\n            Error: 3\n        };\n\n        createProperty(\"string\", this, \"name\");\n        createProperty(\"url\", this, \"source\");\n        createProperty(\"enum\", this, \"status\");\n\n        this.status = this.FontLoader.Null;\n\n        var self = this,\n            domStyle = document.createElement('style'),\n            lastName = '',\n            inTouchName = false;\n\n        // Maximum timeout is the maximum time for a font to load. If font isn't loaded in this time, the status is set to Error.\n        // For both cases (with and without FontLoader.js) if the font takes more than the maximum timeout to load,\n        // dimensions recalculations for elements that are using this font will not be triggered or will have no effect.\n\n        // FontLoader.js uses only the last timeout. The state and name properties are set immediately when the font loads.\n        // If the font could not be loaded, the Error status will be set only when this timeout expires.\n        // If the font loading takes more than the timeout, the name property is set, but the status is set to Error.\n\n        // Fallback sets the font name immediately and touches it several times to trigger dimensions recalcuations.\n        // The status is set to Error and should not be used.\n        var timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000]; // 15 seconds maximum\n\n        function cycleTouchName(fontName, i) {\n            if (lastName !== fontName) return;\n            if (i > 0) {\n                var name = self.name;\n                inTouchName = true;\n                // Calling self.nameChanged() is not enough, we have to actually change the value to flush the bindings.\n                self.name = 'sans-serif';\n                self.name = name;\n                inTouchName = false;\n            }\n            if (i < timeouts.length) {\n                setTimeout(function () {\n                    cycleTouchName(fontName, i + 1);\n                }, timeouts[i] - (i > 0 ? timeouts[i - 1] : 0));\n            }\n        }\n\n        function loadFont(fontName) {\n            if (lastName === fontName || inTouchName) return;\n            lastName = fontName;\n\n            if (!fontName) {\n                self.status = self.FontLoader.Null;\n                return;\n            }\n            self.status = self.FontLoader.Loading;\n            if (typeof FontLoader !== 'undefined') {\n                var fontLoader = new FontLoader([fontName], {\n                    \"fontsLoaded\": function fontsLoaded(error) {\n                        if (error !== null) {\n                            if (lastName === fontName && error.notLoadedFontFamilies[0] === fontName) {\n                                self.name = fontName; // Set the name for the case of font loading after the timeout.\n                                self.status = self.FontLoader.Error;\n                            }\n                        }\n                    },\n                    \"fontLoaded\": function fontLoaded(fontFamily) {\n                        if (lastName === fontName && fontFamily == fontName) {\n                            self.name = fontName;\n                            self.status = self.FontLoader.Ready;\n                        }\n                    }\n                }, timeouts[timeouts.length - 1]);\n                FontLoader.testDiv = null; // Else I get problems loading multiple fonts (FontLoader.js bug?)\n                fontLoader.loadFonts();\n            } else {\n                console.warn('FontLoader.js library is not loaded.\\nYou should load https://github.com/smnh/FontLoader if you want to use QtQuick FontLoader elements.');\n                self.status = self.FontLoader.Error; // You should not rely on 'status' property without FontLoader.js.\n                self.name = fontName;\n                cycleTouchName(fontName, 0);\n            }\n        }\n\n        this.sourceChanged.connect(this, function (font_src) {\n            var fontName = 'font_' + new Date().getTime().toString(36) + '_' + Math.round(Math.random() * 1e15).toString(36);\n            domStyle.innerHTML = '@font-face { font-family: \\'' + fontName + '\\'; src: url(\\'' + engine.$resolvePath(font_src) + '\\'); }';\n            document.getElementsByTagName('head')[0].appendChild(domStyle);\n            loadFont(fontName);\n        });\n\n        this.nameChanged.connect(this, loadFont);\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Grid',\n    versions: /.*/,\n    baseClass: 'Positioner',\n    constructor: QMLGrid\n});\n\nfunction QMLGrid(meta) {\n    callSuper(this, meta);\n\n    this.Grid = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    };\n\n    createProperty(\"int\", this, \"columns\");\n    createProperty(\"int\", this, \"rows\");\n    createProperty(\"enum\", this, \"flow\", { initialValue: 0 });\n    createProperty(\"enum\", this, \"layoutDirection\", { initialValue: 0 });\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLGrid.prototype.layoutChildren = function () {\n    var visibleItems = [],\n        r = 0,\n        c = 0,\n        colWidth = [],\n        rowHeight = [],\n        gridWidth = -this.spacing,\n        gridHeight = -this.spacing,\n        curHPos = 0,\n        curVPos = 0;\n\n    // How many items are actually visible?\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (child.visible && child.width && child.height) visibleItems.push(this.children[i]);\n    }\n\n    // How many rows and columns do we need?\n    if (!this.columns && !this.rows) {\n        c = 4;\n        r = Math.ceil(visibleItems.length / 4);\n    } else if (!this.columns) {\n        r = this.rows;\n        c = Math.ceil(visibleItems.length / r);\n    } else {\n        c = this.columns;\n        r = Math.ceil(visibleItems.length / c);\n    }\n\n    // How big are the colums/rows?\n    if (this.flow == 0) for (var i = 0; i < r; i++) {\n        for (var j = 0; j < c; j++) {\n            var item = visibleItems[i * c + j];\n            if (!item) break;\n            if (!colWidth[j] || item.width > colWidth[j]) colWidth[j] = item.width;\n            if (!rowHeight[i] || item.height > rowHeight[i]) rowHeight[i] = item.height;\n        }\n    } else for (var i = 0; i < c; i++) {\n        for (var j = 0; j < r; j++) {\n            var item = visibleItems[i * r + j];\n            if (!item) break;\n            if (!rowHeight[j] || item.height > rowHeight[j]) rowHeight[j] = item.height;\n            if (!colWidth[i] || item.width > colWidth[i]) colWidth[i] = item.width;\n        }\n    }\n\n    for (var i in colWidth) {\n        gridWidth += colWidth[i] + this.spacing;\n    }for (var i in rowHeight) {\n        gridHeight += rowHeight[i] + this.spacing;\n    } // Do actual positioning\n    // When layoutDirection is RightToLeft we need oposite order of coumns\n    var step = this.layoutDirection == 1 ? -1 : 1,\n        startingPoint = this.layoutDirection == 1 ? c - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : c;\n    if (this.flow == 0) for (var i = 0; i < r; i++) {\n        for (var j = startingPoint; j !== endPoint; j += step) {\n            var item = visibleItems[i * c + j];\n            if (!item) break;\n            item.x = curHPos;\n            item.y = curVPos;\n\n            curHPos += colWidth[j] + this.spacing;\n        }\n        curVPos += rowHeight[i] + this.spacing;\n        curHPos = 0;\n    } else for (var i = startingPoint; i !== endPoint; i += step) {\n        for (var j = 0; j < r; j++) {\n            var item = visibleItems[i * r + j];\n            if (!item) break;\n            item.x = curHPos;\n            item.y = curVPos;\n\n            curVPos += rowHeight[j] + this.spacing;\n        }\n        curHPos += colWidth[i] + this.spacing;\n        curVPos = 0;\n    }\n\n    this.implicitWidth = gridWidth;\n    this.implicitHeight = gridHeight;\n};\n\nfunction QMLImage(meta) {\n    callSuper(this, meta);\n    var img = new Image(),\n        self = this;\n\n    // Exports.\n    this.Image = {\n        // fillMode\n        Stretch: 1,\n        PreserveAspectFit: 2,\n        PreserveAspectCrop: 3,\n        Tile: 4,\n        TileVertically: 5,\n        TileHorizontally: 6,\n        // status\n        Null: 1,\n        Ready: 2,\n        Loading: 3,\n        Error: 4\n    };\n\n    // no-op properties\n    createProperty(\"bool\", this, \"asynchronous\", { initialValue: true });\n    createProperty(\"bool\", this, \"cache\", { initialValue: true });\n    createProperty(\"bool\", this, \"smooth\", { initialValue: true });\n\n    createProperty(\"enum\", this, \"fillMode\", { initialValue: this.Image.Stretch });\n    createProperty(\"bool\", this, \"mirror\");\n    createProperty(\"real\", this, \"progress\");\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\", { initialValue: this.Image.Null });\n\n    this.sourceSize = new QObject(this);\n\n    createProperty(\"int\", this.sourceSize, \"width\");\n    createProperty(\"int\", this.sourceSize, \"height\");\n\n    var bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.height = '100%';\n    this.dom.appendChild(bg);\n\n    // Bind status to img element\n    img.onload = function () {\n        var w = img.naturalWidth;\n        var h = img.naturalHeight;\n        self.sourceSize.width = w;\n        self.sourceSize.height = h;\n        self.implicitWidth = w;\n        self.implicitHeight = h;\n\n        self.progress = 1;\n        self.status = self.Image.Ready;\n    };\n    img.onerror = function () {\n        self.status = self.Image.Error;\n    };\n\n    var updateFillMode = function updateFillMode(val) {\n        if (typeof val == 'undefined') val = this.fillMode;\n        switch (val) {\n            default:\n            case this.Image.Stretch:\n                bg.style.backgroundRepeat = 'auto';\n                bg.style.backgroundSize = '100% 100%';\n                bg.style.backgroundPosition = 'auto';\n                break;\n            case this.Image.Tile:\n                bg.style.backgroundRepeat = 'auto';\n                bg.style.backgroundSize = 'auto';\n                bg.style.backgroundPosition = 'auto';\n                break;\n            case this.Image.PreserveAspectFit:\n                bg.style.backgroundRepeat = 'no-repeat';\n                bg.style.backgroundSize = 'contain';\n                bg.style.backgroundPosition = 'center';\n                break;\n            case this.Image.PreserveAspectCrop:\n                bg.style.backgroundRepeat = 'no-repeat';\n                bg.style.backgroundSize = 'cover';\n                bg.style.backgroundPosition = 'center';\n                break;\n            case this.Image.TileVertically:\n                bg.style.backgroundRepeat = 'repeat-y';\n                bg.style.backgroundSize = '100% auto';\n                bg.style.backgroundPosition = 'auto';\n                break;\n            case this.Image.TileHorizontally:\n                bg.style.backgroundRepeat = 'repeat-x';\n                bg.style.backgroundSize = 'auto 100%';\n                bg.style.backgroundPosition = 'auto';\n                break;\n        }\n    };\n    updateFillMode = updateFillMode.bind(this);\n\n    var updateMirroring = function (val) {\n        var transformRule = 'scale(-1,1)';\n        if (!val) {\n            var index = this.transform.indexOf(transformRule);\n\n            if (index >= 0) this.transform.splice(index, 1);\n        } else this.transform.push(transformRule);\n        this.$updateTransform();\n    }.bind(this);\n\n    this.sourceChanged.connect(this, function (val) {\n        this.progress = 0;\n        this.status = this.Image.Loading;\n        bg.style.backgroundImage = \"url('\" + engine.$resolvePath(val) + \"')\";\n        img.src = engine.$resolvePath(val);\n        if (img.complete) this.status = this.Image.Ready;\n        updateFillMode();\n    });\n\n    this.mirrorChanged.connect(this, updateMirroring);\n    this.fillModeChanged.connect(this, updateFillMode);\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Image',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: QMLImage\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'IntValidator',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLIntValidator(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"int\", this, \"bottom\");\n        createProperty(\"int\", this, \"top\");\n        this.bottom = -2147483647;\n        this.top = 2147483647;\n\n        this.validate = function (string) {\n            var regExp = /^(-|\\+)?\\s*[0-9]+$/;\n            var acceptable = regExp.test(string.trim());\n\n            if (acceptable) {\n                var value = parseInt(string);\n\n                acceptable = this.bottom <= value && this.top >= value;\n            }\n            return acceptable;\n        }.bind(this);\n    }\n});\n\nfunction QMLItem(meta) {\n    callSuper(this, meta);\n    var child, o, i;\n\n    if (this.$parent === null) {\n        // This is the root element. Initialize it.\n        this.dom = engine.rootElement || document.body;\n        this.dom.innerHTML = \"\";\n        var self = this;\n        this.dom.style.position = \"relative\"; // Needed to make absolute positioning work\n        this.dom.style.top = \"0\";\n        this.dom.style.left = \"0\";\n        this.dom.style.overflow = \"hidden\"; // No QML stuff should stand out the root element\n    } else {\n        if (!this.dom) // Create a dom element for this item.\n            this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"absolute\";\n    }\n    this.dom.style.pointerEvents = \"none\";\n    /* In case the class is qualified, only use the last part for the css class\n     * name. */\n    var classComponents = meta.object.$class.split(\".\");\n    this.dom.className = classComponents[classComponents.length - 1] + (this.id ? \" \" + this.id : \"\");\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = 'border-box';\n\n    this.parentChanged.connect(this, function (newParent, oldParent) {\n        if (oldParent) {\n            oldParent.children.splice(oldParent.children.indexOf(this), 1);\n            oldParent.childrenChanged();\n            oldParent.dom.removeChild(this.dom);\n        }\n        if (newParent && newParent.children.indexOf(this) == -1) {\n            newParent.children.push(this);\n            newParent.childrenChanged();\n        }\n        if (newParent) newParent.dom.appendChild(this.dom);\n    });\n    this.parentChanged.connect(this, updateHGeometry);\n    this.parentChanged.connect(this, updateVGeometry);\n    this.dataChanged.connect(this, function (newData) {\n        for (var i in newData) {\n            var child = newData[i];\n            if (child.hasOwnProperty(\"parent\")) // Seems to be an Item. TODO: Use real inheritance and ask using instanceof.\n                child.parent = this; // This will also add it to children.\n            else this.resources.push(child);\n        }\n    });\n\n    if (this.$isComponentRoot) createProperty(\"var\", this, \"activeFocus\");\n\n    this.xChanged.connect(this, updateHGeometry);\n    this.yChanged.connect(this, updateVGeometry);\n    this.widthChanged.connect(this, updateHGeometry);\n    this.heightChanged.connect(this, updateVGeometry);\n    this.implicitWidthChanged.connect(this, updateHGeometry);\n    this.implicitHeightChanged.connect(this, updateVGeometry);\n\n    this.setupFocusOnDom = function (element) {\n        var updateFocus = function () {\n            var hasFocus = document.activeElement == this.dom || document.activeElement == this.dom.firstChild;\n\n            if (this.focus != hasFocus) this.focus = hasFocus;\n        }.bind(this);\n        element.addEventListener(\"focus\", updateFocus);\n        element.addEventListener(\"blur\", updateFocus);\n    }.bind(this);\n\n    this.focusChanged.connect(this, function (newVal) {\n        if (newVal == true) {\n            if (this.dom.firstChild != null) this.dom.firstChild.focus();\n            document.qmlFocus = this;\n            this.$context.activeFocus = this;\n        } else if (document.qmlFocus == this) {\n            document.getElementsByTagName(\"BODY\")[0].focus();\n            document.qmlFocus = engine.rootContext().base;\n            this.$context.activeFocus = null;\n        }\n    }.bind(this));\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QObject(this);\n    createProperty(\"var\", this.anchors, \"left\");\n    createProperty(\"var\", this.anchors, \"right\");\n    createProperty(\"var\", this.anchors, \"top\");\n    createProperty(\"var\", this.anchors, \"bottom\");\n    createProperty(\"var\", this.anchors, \"horizontalCenter\");\n    createProperty(\"var\", this.anchors, \"verticalCenter\");\n    createProperty(\"Item\", this.anchors, \"fill\");\n    createProperty(\"Item\", this.anchors, \"centerIn\");\n    createProperty(\"real\", this.anchors, \"margins\");\n    createProperty(\"real\", this.anchors, \"leftMargin\");\n    createProperty(\"real\", this.anchors, \"rightMargin\");\n    createProperty(\"real\", this.anchors, \"topMargin\");\n    createProperty(\"real\", this.anchors, \"bottomMargin\");\n    this.anchors.leftChanged.connect(this, updateHGeometry);\n    this.anchors.rightChanged.connect(this, updateHGeometry);\n    this.anchors.topChanged.connect(this, updateVGeometry);\n    this.anchors.bottomChanged.connect(this, updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, updateVGeometry);\n    this.anchors.fillChanged.connect(this, updateHGeometry);\n    this.anchors.fillChanged.connect(this, updateVGeometry);\n    this.anchors.centerInChanged.connect(this, updateHGeometry);\n    this.anchors.centerInChanged.connect(this, updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, updateVGeometry);\n    this.anchors.marginsChanged.connect(this, updateHGeometry);\n    this.anchors.marginsChanged.connect(this, updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QObject(this);\n    createProperty(\"real\", this.childrenRect, \"x\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"y\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"width\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"height\"); // TODO ro\n\n    this.stateChanged.connect(this, function (newVal, oldVal) {\n        var oldState, newState, i, j, k;\n        for (i = 0; i < this.states.length; i++) {\n            if (this.states[i].name === newVal) newState = this.states[i];else if (this.states[i].name === oldVal) oldState = this.states[i];\n        }var actions = this.$revertActions.slice();\n\n        // Get current values for revert actions\n        for (i in actions) {\n            var action = actions[i];\n            action.from = action.target[action.property];\n        }\n        if (newState) {\n            var changes = newState.$getAllChanges();\n\n            // Get all actions we need to do and create actions to revert them\n            for (i = 0; i < changes.length; i++) {\n                var change = changes[i];\n\n                for (j = 0; j < change.$actions.length; j++) {\n                    var item = change.$actions[j];\n\n                    var action = {\n                        target: change.target,\n                        property: item.property,\n                        origValue: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n                        value: item.value,\n                        from: change.target[item.property],\n                        to: undefined,\n                        explicit: change.explicit\n                    };\n                    var found = false;\n                    for (k in actions) {\n                        if (actions[k].target == action.target && actions[k].property == action.property) {\n                            found = true;\n                            actions[k] = action;\n                            break;\n                        }\n                    }if (!found) actions.push(action);\n\n                    // Look for existing revert action, else create it\n                    var found = false;\n                    for (k = 0; k < this.$revertActions.length; k++) {\n                        if (this.$revertActions[k].target == change.target && this.$revertActions[k].property == item.property) {\n                            if (!change.restoreEntryValues) this.$revertActions.splice(k, 1); // We don't want to revert, so remove it\n                            found = true;\n                            break;\n                        }\n                    }if (!found && change.restoreEntryValues) this.$revertActions.push({\n                        target: change.target,\n                        property: item.property,\n                        value: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n                        from: undefined,\n                        to: change.target[item.property]\n                    });\n                }\n            }\n        }\n\n        // Set all property changes and fetch the actual values afterwards\n        // The latter is needed for transitions. We need to set all properties\n        // before we fetch the values because properties can be interdependent.\n        for (i in actions) {\n            var action = actions[i];\n            action.target.$properties[action.property].set(action.value, QMLProperty.ReasonUser, action.target, newState ? newState.$context : action.target.$context);\n        }\n        for (i in actions) {\n            var action = actions[i];\n            action.to = action.target[action.property];\n            if (action.explicit) {\n                action.target[action.property] = action.target[action.property]; //Remove binding\n                action.value = action.target[action.property];\n            }\n        }\n\n        // Find the best transition to use\n        var transition,\n            rating = 0;\n        for (var i = 0; i < this.transitions.length; i++) {\n            this.transitions[i].$stop(); // We need to stop running transitions, so let's do\n            // it while iterating through the transitions anyway\n            var curTransition = this.transitions[i],\n                curRating = 0;\n            if (curTransition.from == oldVal || curTransition.reversible && curTransition.from == newVal) curRating += 2;else if (curTransition.from == \"*\") curRating++;else continue;\n            if (curTransition.to == newVal || curTransition.reversible && curTransition.to == oldVal) curRating += 2;else if (curTransition.to == \"*\") curRating++;else continue;\n            if (curRating > rating) {\n                rating = curRating;\n                transition = curTransition;\n            }\n        }\n        if (transition) transition.$start(actions);\n    });\n\n    var QMLRotation = getConstructor('QtQuick', '2.0', 'Rotation');\n    var QMLScale = getConstructor('QtQuick', '2.0', 'Scale');\n    var QMLTranslate = getConstructor('QtQuick', '2.0', 'Translate');\n\n    this.$updateTransform = function () {\n        var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\n        var filter = \"\";\n        var transformStyle = \"preserve-3d\";\n\n        for (var i = 0; i < this.transform.length; i++) {\n            var t = this.transform[i];\n            if (t instanceof QMLRotation) transform += \" rotate3d(\" + t.axis.x + \", \" + t.axis.y + \", \" + t.axis.z + \", \" + t.angle + \"deg)\";else if (t instanceof QMLScale) transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";else if (t instanceof QMLTranslate) transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";else if (typeof t.transformType != 'undefined') {\n                if (t.transformType == 'filter') filter += t.operation + '(' + t.parameters + ') ';\n            } else if (typeof t == 'string') transform += t;\n        }\n        if (typeof this.z == \"number\") transform += \" translate3d(0, 0, \" + this.z + \"px)\";\n        this.dom.style.transform = transform;\n        this.dom.style.transformStyle = transformStyle;\n        this.dom.style.MozTransform = transform; // Firefox\n        this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n        this.dom.style.webkitTransformStyle = transformStyle;\n        this.dom.style.OTransform = transform; // Opera\n        this.dom.style.msTransform = transform; // IE\n        this.dom.style.filter = filter;\n        this.dom.style.msFilter = filter; // IE\n        this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n        this.dom.style.MozFilter = filter; // Firefox\n    };\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n    this.visibleChanged.connect(this, function (newVal) {\n        this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n    });\n    this.clipChanged.connect(this, function (newVal) {\n        this.css.overflow = newVal ? \"hidden\" : \"visible\";\n    });\n    this.zChanged.connect(this, function (newVal) {\n        this.$updateTransform();\n    });\n    this.xChanged.connect(this, function (newVal) {\n        this.css.left = newVal + \"px\";\n    });\n    this.yChanged.connect(this, function (newVal) {\n        this.css.top = newVal + \"px\";\n    });\n    this.widthChanged.connect(this, function (newVal) {\n        this.css.width = newVal ? newVal + \"px\" : \"auto\";\n    });\n    this.heightChanged.connect(this, function (newVal) {\n        this.css.height = newVal ? newVal + \"px\" : \"auto\";\n    });\n\n    this.Component.completed.connect(this, this.$calculateOpacity);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n        this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = this.x + 'px';\n    this.css.top = this.y + 'px';\n\n    // Init size of root element\n    if (this.$parent === null) {\n        if (engine.rootElement == undefined) {\n            // Case 1: Qml scene is placed in body tag\n\n            // event handling by addEventListener is probably better than setting window.onresize\n            var updateQmlGeometry = function updateQmlGeometry() {\n                self.implicitHeight = window.innerHeight;\n                self.implicitWidth = window.innerWidth;\n            };\n            window.addEventListener(\"resize\", updateQmlGeometry);\n            updateQmlGeometry();\n        } else {\n            // Case 2: Qml scene is placed in some element tag\n\n            // we have to call `self.implicitHeight =` and `self.implicitWidth =`\n            // each time the rootElement changes it's geometry\n            // to reposition child elements of qml scene\n\n            // it is good to have this as named method of dom element, so we can call it\n            // from outside too, whenever element changes it's geometry (not only on window resize)\n            this.dom.updateQmlGeometry = function () {\n                self.implicitHeight = self.dom.offsetHeight;\n                self.implicitWidth = self.dom.offsetWidth;\n            };\n            window.addEventListener(\"resize\", this.dom.updateQmlGeometry);\n            this.dom.updateQmlGeometry();\n        }\n    }\n}\n\nQMLItem.prototype.$calculateOpacity = function () {\n    // TODO: reset all opacity on layer.enabled changed\n    if (false) {\n        // TODO: check layer.enabled\n        this.css.opacity = this.opacity;\n    }\n    var parentOpacity = this.$parent && this.$parent.$opacity || 1;\n    this.$opacity = this.opacity * parentOpacity;\n    if (this.impl) {\n        this.impl.style.opacity = this.$opacity;\n    }\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Item',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    properties: {\n        $opacity: { type: 'real', initialValue: 1 },\n        parent: 'Item',\n        state: 'string',\n        states: 'list',\n        transitions: 'list',\n        data: 'list',\n        children: 'list',\n        resources: 'list',\n        transform: 'list',\n        x: 'real',\n        y: 'real',\n        z: 'real',\n        width: 'real',\n        height: 'real',\n        implicitWidth: 'real',\n        implicitHeight: 'real',\n        left: 'real',\n        right: 'real',\n        top: 'real',\n        bottom: 'real',\n        horizontalCenter: 'real',\n        verticalCenter: 'real',\n        rotation: 'real',\n        scale: { type: 'real', initialValue: 1 },\n        opacity: { type: 'real', initialValue: 1 },\n        visible: { type: 'bool', initialValue: true },\n        clip: 'bool',\n        focus: 'bool'\n    },\n    defaultProperty: 'data',\n    constructor: QMLItem\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'ListElement',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLListElement(meta) {\n        callSuper(this, meta);\n\n        for (var i in meta.object) {\n            if (i[0] != \"$\") {\n                createProperty(\"variant\", this, i);\n            }\n        }\n        applyProperties(meta.object, this, this, this.$context);\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'ListModel',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLListModel(meta) {\n        callSuper(this, meta);\n        var self = this,\n            firstItem = true;\n        var QMLListElement = getConstructor('QtQuick', '2.0', 'ListElement');\n\n        createProperty(\"int\", this, \"count\");\n        createProperty(\"list\", this, \"$items\");\n        this.$defaultProperty = \"$items\";\n        this.$model = new JSItemModel();\n\n        this.$itemsChanged.connect(this, function (newVal) {\n            this.count = this.$items.length;\n            if (firstItem && newVal.length > 0) {\n                firstItem = false;\n                var roleNames = [];\n                var dict = newVal[0];\n                for (var i in dict instanceof QMLListElement ? dict.$properties : dict) {\n                    if (i != \"index\") roleNames.push(i);\n                }\n                this.$model.setRoleNames(roleNames);\n            }\n        });\n\n        this.$model.data = function (index, role) {\n            return self.$items[index][role];\n        };\n        this.$model.rowCount = function () {\n            return self.$items.length;\n        };\n\n        this.append = function (dict) {\n            var index = this.$items.length;\n            var c = 0;\n\n            if (dict instanceof Array) {\n                for (var key in dict) {\n                    this.$items.push(dict[key]);\n                    c++;\n                }\n            } else {\n                this.$items.push(dict);\n                c = 1;\n            }\n\n            this.$itemsChanged(this.$items);\n            this.$model.rowsInserted(index, index + c);\n        };\n        this.clear = function () {\n            this.$model.modelReset();\n            this.$items.length = 0;\n            this.count = 0;\n        };\n        this.get = function (index) {\n            return this.$items[index];\n        };\n        this.insert = function (index, dict) {\n            this.$items.splice(index, 0, dict);\n            this.$itemsChanged(this.$items);\n            this.$model.rowsInserted(index, index + 1);\n        };\n        this.move = function (from, to, n) {\n            var vals = this.$items.splice(from, n);\n            for (var i = 0; i < vals.length; i++) {\n                this.$items.splice(to + i, 0, vals[i]);\n            }\n            this.$model.rowsMoved(from, from + n, to);\n        };\n        this.remove = function (index) {\n            this.$items.splice(index, 1);\n            this.$model.rowsRemoved(index, index + 1);\n            this.count = this.$items.length;\n        };\n        this.set = function (index, dict) {\n            this.$items[index] = dict;\n            this.$model.dataChanged(index, index);\n        };\n        this.setProperty = function (index, property, value) {\n            this.$items[index][property] = value;\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'ListView',\n    versions: /.*/,\n    baseClass: 'Repeater',\n    constructor: function QMLListView(meta) {\n        callSuper(this, meta);\n        var self = this;\n\n        createProperty(\"enum\", this, \"orientation\");\n        createProperty(\"real\", this, \"spacing\");\n\n        this.container = function () {\n            return self;\n        };\n        this.modelChanged.connect(styleChanged);\n        this.delegateChanged.connect(styleChanged);\n        this.orientationChanged.connect(styleChanged);\n        this.spacingChanged.connect(styleChanged);\n\n        this._childrenInserted.connect(applyStyleOnItem);\n\n        function applyStyleOnItem($item) {\n            $item.dom.style.position = 'initial';\n            if (self.orientation == Qt.Horizontal) {\n                $item.dom.style.display = 'inline-block';\n                if ($item != self.$items[0]) $item.dom.style[\"margin-left\"] = self.spacing + \"px\";\n            } else {\n                $item.dom.style.display = 'block';\n                if ($item != self.$items[0]) $item.dom.style[\"margin-top\"] = self.spacing + \"px\";\n            }\n        }\n\n        function styleChanged() {\n            for (var i = 0; i < self.$items.length; ++i) {\n                applyStyleOnItem(self.$items[i]);\n            }\n        }\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Loader',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function constructor(meta) {\n        var _this4 = this;\n\n        callSuper(this, meta);\n\n        createProperty('bool', this, 'active', { initialValue: true });\n        createProperty('bool', this, 'asynchronous');\n        createProperty('var', this, 'item');\n        createProperty('real', this, 'progress');\n        createProperty('url', this, 'source');\n        createProperty('Component', this, 'sourceComponent');\n        createProperty('enum', this, 'status', { initialValue: 1 });\n\n        var sourceUrl = '';\n\n        this.loaded = Signal();\n\n        var QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n\n        this.activeChanged.connect(function () {\n            if (!_this4.active) {\n                unload();\n                return;\n            }\n            if (_this4.source) {\n                sourceChanged();\n            } else if (_this4.sourceComponent) {\n                sourceComponentChanged();\n            }\n        });\n\n        this.sourceChanged.connect(function (newVal) {\n            // if (newVal == sourceUrl && this.item !== undefined) return // TODO\n            if (!_this4.active) {\n                return;\n            }\n\n            unload();\n\n            // TODO: we require '.qml' for now, that should be fixed\n            if (newVal.length <= 4) {\n                // 0\n                return;\n            }\n            if (newVal.substr(newVal.length - 4, 4) !== '.qml') {\n                return;\n            }\n            var fileName = newVal.substring(0, newVal.length - 4);\n\n            var tree = engine.loadComponent(fileName);\n            var meta = { object: tree, context: _this4, parent: _this4 };\n            var qmlComponent = new QMLComponent(meta);\n            var loadedComponent = createComponentObject(qmlComponent, _this4);\n            _this4.sourceComponent = loadedComponent;\n            sourceUrl = newVal;\n        });\n\n        this.sourceComponentChanged.connect(function (newItem) {\n            if (!_this4.active) {\n                return;\n            }\n\n            unload();\n\n            var qmlComponent = newItem;\n\n            if (newItem instanceof QMLComponent) {\n                var meta = { object: newItem.$metaObject, context: _this4, parent: _this4 };\n                qmlComponent = construct(meta);\n            }\n\n            qmlComponent.parent = _this4;\n            _this4.item = qmlComponent;\n\n            updateGeometry();\n\n            if (_this4.item) {\n                _this4.loaded();\n            }\n        });\n\n        function createComponentObject(qmlComponent, parent) {\n            var newComponent = qmlComponent.createObject(parent);\n\n            newComponent.parent = parent;\n            qmlComponent.finalizeImports();\n\n            if (engine.operationState !== QMLOperationState.Init) {\n                // We don't call those on first creation, as they will be called\n                // by the regular creation-procedures at the right time.\n                engine.$initializePropertyBindings();\n                callOnCompleted(newComponent);\n            }\n\n            return newComponent;\n        }\n\n        var updateGeometry = function updateGeometry() {\n            // Loader size doesn't exist\n            if (!_this4.width) {\n                _this4.width = _this4.item ? _this4.item.width : 0;\n            } else if (_this4.item) {\n                // Loader size exists\n                _this4.item.width = _this4.width;\n            }\n\n            if (!_this4.height) {\n                _this4.height = _this4.item ? _this4.item.height : 0;\n            } else if (_this4.item) {\n                // Loader size exists\n                _this4.item.height = _this4.height;\n            }\n        };\n        this.widthChanged.connect(updateGeometry);\n        this.heightChanged.connect(updateGeometry);\n\n        var unload = function unload() {\n            if (_this4.item) {\n                _this4.item.$delete();\n                _this4.item.parent = undefined;\n                _this4.item = undefined;\n            }\n        };\n\n        function callOnCompleted(child) {\n            child.Component.completed();\n            child.children.forEach(callOnCompleted);\n        }\n\n        this.setSource = function (url, options) {\n            sourceUrl = url;\n            this.props = options;\n            this.source = url;\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'MouseArea',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLMouseArea(meta) {\n        callSuper(this, meta);\n        var self = this;\n\n        this.dom.style.pointerEvents = \"all\";\n\n        // IE does not handle mouse clicks to transparent divs, so we have\n        // to set a background color and make it invisible using opacity\n        // as that doesn't affect the mouse handling.\n        this.dom.style.backgroundColor = \"white\";\n        this.dom.style.opacity = 0;\n\n        createProperty(\"variant\", this, \"acceptedButtons\", { initialValue: Qt.LeftButton });\n        createProperty(\"bool\", this, \"enabled\", { initialValue: true });\n        createProperty(\"bool\", this, \"hoverEnabled\");\n        createProperty(\"real\", this, \"mouseX\");\n        createProperty(\"real\", this, \"mouseY\");\n        createProperty(\"bool\", this, \"pressed\");\n        createProperty(\"bool\", this, \"containsMouse\");\n        createProperty(\"variant\", this, \"pressedButtons\", { initialValue: 0 });\n        createProperty(\"enum\", this, \"cursorShape\", { initialValue: Qt.ArrowCursor });\n\n        this.clicked = Signal([{ type: \"variant\", name: \"mouse\" }]);\n        this.entered = Signal();\n        this.exited = Signal();\n        this.positionChanged = Signal([{ type: \"variant\", name: \"mouse\" }]);\n\n        function eventToMouse(e) {\n            return {\n                accepted: true,\n                button: e.button == 0 ? Qt.LeftButton : e.button == 1 ? Qt.MiddleButton : e.button == 2 ? Qt.RightButton : 0,\n                modifiers: e.ctrlKey * Qt.CtrlModifier | e.altKey * Qt.AltModifier | e.shiftKey * Qt.ShiftModifier | e.metaKey * Qt.MetaModifier,\n                x: e.offsetX || e.layerX,\n                y: e.offsetY || e.layerY\n            };\n        }\n        function handleClick(e) {\n            var mouse = eventToMouse(e);\n\n            if (self.enabled && self.acceptedButtons & mouse.button) {\n                self.clicked(mouse);\n            }\n            // This decides whether to show the browser's context menu on right click or not\n            return !(self.acceptedButtons & Qt.RightButton);\n        }\n        this.dom.onclick = handleClick;\n        this.dom.oncontextmenu = handleClick;\n        this.dom.onmousedown = function (e) {\n            if (self.enabled) {\n                var mouse = eventToMouse(e);\n                self.mouseX = mouse.x;\n                self.mouseY = mouse.y;\n                self.pressed = true;\n            }\n            self.pressedButtons = mouse.button;\n        };\n        this.dom.onmouseup = function (e) {\n            self.pressed = false;\n            self.pressedButtons = 0;\n        };\n        this.dom.onmouseover = function (e) {\n            self.containsMouse = true;\n            self.entered();\n        };\n        this.dom.onmouseout = function (e) {\n            self.containsMouse = false;\n            self.exited();\n        };\n        this.dom.onmousemove = function (e) {\n            if (self.enabled && (self.hoverEnabled || self.pressed)) {\n                var mouse = eventToMouse(e);\n                self.positionChanged(mouse);\n                self.mouseX = mouse.x;\n                self.mouseY = mouse.y;\n            }\n        };\n\n        function cursorShapeToCSS() {\n            switch (self.cursorShape) {\n                case Qt.ArrowCursor:\n                    return 'default';\n                case Qt.UpArrowCursor:\n                    return 'n-resize';\n                case Qt.CrossCursor:\n                    return 'crosshair';\n                case Qt.WaitCursor:\n                    return 'wait';\n                case Qt.IBeamCursor:\n                    return 'text';\n                case Qt.SizeVerCursor:\n                    return 'ew-resize';\n                case Qt.SizeHorCursor:\n                    return 'ns-resize';\n                case Qt.SizeBDiagCursor:\n                    return 'nesw-resize';\n                case Qt.SizeFDiagCursor:\n                    return 'nwse-resize';\n                case Qt.SizeAllCursor:\n                    return 'all-scroll';\n                case Qt.BlankCursor:\n                    return 'none';\n                case Qt.SplitVCursor:\n                    return 'row-resize';\n                case Qt.SplitHCursor:\n                    return 'col-resize';\n                case Qt.PointingHandCursor:\n                    return 'pointer';\n                case Qt.ForbiddenCursor:\n                    return 'not-allowed';\n                case Qt.WhatsThisCursor:\n                    return 'help';\n                case Qt.BusyCursor:\n                    return 'progress';\n                case Qt.OpenHandCursor:\n                    return 'grab';\n                case Qt.ClosedHandCursor:\n                    return 'grabbing';\n                case Qt.DragCopyCursor:\n                    return 'copy';\n                case Qt.DragMoveCursor:\n                    return 'move';\n                case Qt.DragLinkCursor:\n                    return 'alias';\n                //case Qt.BitmapCursor: return 'auto';\n                //case Qt.CustomCursor: return 'auto';\n            }\n            return 'auto';\n        }\n\n        this.cursorShapeChanged.connect(function () {\n            self.dom.style.cursor = cursorShapeToCSS();\n        });\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'NumberAnimation',\n    versions: /.*/,\n    baseClass: 'PropertyAnimation',\n    constructor: function QMLNumberAnimation(meta) {\n        callSuper(this, meta);\n        var at = 0,\n            loop = 0,\n            self = this;\n\n        engine.$addTicker(ticker);\n\n        function ticker(now, elapsed) {\n            if ((self.running || loop === -1) && !self.paused) {\n                // loop === -1 is a marker to just finish this run\n                if (at == 0 && loop == 0 && !self.$actions.length) self.$redoActions();\n                at += elapsed / self.duration;\n                if (at >= 1) self.complete();else for (var i in self.$actions) {\n                    var action = self.$actions[i],\n                        value = self.easing.$valueForProgress(at) * (action.to - action.from) + action.from;\n                    action.target.$properties[action.property].set(value, QMLProperty.ReasonAnimation);\n                }\n            }\n        }\n\n        function startLoop() {\n            for (var i in this.$actions) {\n                var action = this.$actions[i];\n                action.from = action.from !== undefined ? action.from : action.target[action.property];\n            }\n            at = 0;\n        }\n\n        this.runningChanged.connect(this, function (newVal) {\n            if (newVal) {\n                startLoop.call(this);\n                this.paused = false;\n            } else if (this.alwaysRunToEnd && at < 1) {\n                loop = -1; // -1 is used as a marker to stop\n            } else {\n                loop = 0;\n                this.$actions = [];\n            }\n        });\n\n        this.complete = function () {\n            for (var i in this.$actions) {\n                var action = this.$actions[i];\n                action.target.$properties[action.property].set(action.to, QMLProperty.ReasonAnimation);\n            }\n\n            if (++loop == this.loops) this.running = false;else if (!this.running) this.$actions = [];else startLoop.call(this);\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'ParallelAnimation',\n    versions: /.*/,\n    baseClass: 'Animation',\n    constructor: function QMLParallelAnimation(meta) {\n        callSuper(this, meta);\n        var curIndex, passedLoops, i;\n\n        this.Animation = { Infinite: Math.Infinite };\n        createProperty(\"list\", this, \"animations\");\n        this.$defaultProperty = \"animations\";\n        this.$runningAnimations = 0;\n\n        this.animationsChanged.connect(this, function () {\n            for (i = 0; i < this.animations.length; i++) {\n                if (!this.animations[i].runningChanged.isConnected(this, animationFinished)) this.animations[i].runningChanged.connect(this, animationFinished);\n            }\n        });\n\n        function animationFinished(newVal) {\n            this.$runningAnimations += newVal ? 1 : -1;\n            if (this.$runningAnimations === 0) this.running = false;\n        }\n\n        this.start = function () {\n            if (!this.running) {\n                this.running = true;\n                for (i = 0; i < this.animations.length; i++) {\n                    this.animations[i].start();\n                }\n            }\n        };\n        this.stop = function () {\n            if (this.running) {\n                for (i = 0; i < this.animations.length; i++) {\n                    this.animations[i].stop();\n                }this.running = false;\n            }\n        };\n        this.complete = this.stop;\n\n        engine.$registerStart(function () {\n            if (self.running) {\n                self.running = false; // toggled back by start();\n                self.start();\n            }\n        });\n        engine.$registerStop(function () {\n            self.stop();\n        });\n    }\n});\n\nfunction QMLPositioner(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"spacing\");\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, QMLPositioner.slotChildrenChanged);\n\n    this.layoutChildren();\n}\n\nQMLPositioner.slotChildrenChanged = function () {\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.widthChanged.isConnected(this, this.layoutChildren)) child.widthChanged.connect(this, this.layoutChildren);\n        if (!child.heightChanged.isConnected(this, this.layoutChildren)) child.heightChanged.connect(this, this.layoutChildren);\n        if (!child.visibleChanged.isConnected(this, this.layoutChildren)) child.visibleChanged.connect(this, this.layoutChildren);\n    }\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Positioner',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: QMLPositioner\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'PropertyAnimation',\n    versions: /.*/,\n    baseClass: 'Animation',\n    constructor: function QMLPropertyAnimation(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"int\", this, \"duration\", { initialValue: 250 });\n        createProperty(\"real\", this, \"from\");\n        createProperty(\"string\", this, \"properties\");\n        createProperty(\"string\", this, \"property\");\n        createProperty(\"QtObject\", this, \"target\");\n        createProperty(\"list\", this, \"targets\");\n        createProperty(\"real\", this, \"to\");\n\n        this.easing = new QObject(this);\n        createProperty(\"enum\", this.easing, \"type\", { initialValue: Easing.Linear });\n        createProperty(\"real\", this.easing, \"amplitude\", { initialValue: 1 });\n        createProperty(\"real\", this.easing, \"overshoot\", { initialValue: 0.3 });\n        createProperty(\"real\", this.easing, \"period\", { initialValue: 1.70158 });\n\n        this.easing.$valueForProgress = function (t) {\n            switch (this.type) {\n                // Quad\n                case Easing.InQuad:\n                    return Math.pow(t, 2);\n                case Easing.OutQuad:\n                    return -Math.pow(t - 1, 2) + 1;\n                case Easing.InOutQuad:\n                    if (t < 0.5) return 2 * Math.pow(t, 2);\n                    return -2 * Math.pow(t - 1, 2) + 1;\n                case Easing.OutInQuad:\n                    if (t < 0.5) return -2 * Math.pow(t - 0.5, 2) + 0.5;\n                    return 2 * Math.pow(t - 0.5, 2) + 0.5;\n                // Cubic\n                case Easing.InCubic:\n                    return Math.pow(t, 3);\n                case Easing.OutCubic:\n                    return Math.pow(t - 1, 3) + 1;\n                case Easing.InOutCubic:\n                    if (t < 0.5) return 4 * Math.pow(t, 3);\n                    return 4 * Math.pow(t - 1, 3) + 1;\n                case Easing.OutInCubic:\n                    return 4 * Math.pow(t - 0.5, 3) + 0.5;\n                // Quart\n                case Easing.InQuart:\n                    return Math.pow(t, 4);\n                case Easing.OutQuart:\n                    return -Math.pow(t - 1, 4) + 1;\n                case Easing.InOutQuart:\n                    if (t < 0.5) return 8 * Math.pow(t, 4);\n                    return -8 * Math.pow(t - 1, 4) + 1;\n                case Easing.OutInQuart:\n                    if (t < 0.5) return -8 * Math.pow(t - 0.5, 4) + 0.5;\n                    return 8 * Math.pow(t - 0.5, 4) + 0.5;\n                // Quint\n                case Easing.InQuint:\n                    return Math.pow(t, 5);\n                case Easing.OutQuint:\n                    return Math.pow(t - 1, 5) + 1;\n                case Easing.InOutQuint:\n                    if (t < 0.5) return 16 * Math.pow(t, 5);\n                    return 16 * Math.pow(t - 1, 5) + 1;\n                case Easing.OutInQuint:\n                    if (t < 0.5) return 16 * Math.pow(t - 0.5, 5) + 0.5;\n                    return 16 * Math.pow(t - 0.5, 5) + 0.5;\n                // Sine\n                case Easing.InSine:\n                    return -Math.cos(0.5 * Math.PI * t) + 1;\n                case Easing.OutSine:\n                    return Math.sin(0.5 * Math.PI * t);\n                case Easing.InOutSine:\n                    return -0.5 * Math.cos(Math.PI * t) + 0.5;\n                case Easing.OutInSine:\n                    if (t < 0.5) return 0.5 * Math.sin(Math.PI * t);\n                    return -0.5 * Math.sin(Math.PI * t) + 1;\n                // Expo\n                case Easing.InExpo:\n                    return 1 / 1023 * (Math.pow(2, 10 * t) - 1);\n                case Easing.OutExpo:\n                    return -(1024 / 1023) * (Math.pow(2, -10 * t) - 1);\n                case Easing.InOutExpo:\n                    if (t < 0.5) return 1 / 62 * (Math.pow(2, 10 * t) - 1);\n                    return -(512 / 31) * Math.pow(2, -10 * t) + 63 / 62;\n                case Easing.OutInExpo:\n                    if (t < 0.5) return -(16 / 31) * (Math.pow(2, -10 * t) - 1);\n                    return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;\n                // Circ\n                case Easing.InCirc:\n                    return 1 - Math.sqrt(1 - t * t);\n                case Easing.OutCirc:\n                    return Math.sqrt(1 - Math.pow(t - 1, 2));\n                case Easing.InOutCirc:\n                    if (t < 0.5) return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));\n                    return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n                case Easing.OutInCirc:\n                    if (t < 0.5) return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n                    return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n                // Elastic\n                case Easing.InElastic:\n                    return -this.amplitude * Math.pow(2, 10 * t - 10) * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n                case Easing.OutElastic:\n                    return this.amplitude * Math.pow(2, -10 * t) * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude)) + 1;\n                case Easing.InOutElastic:\n                    if (t < 0.5) return -0.5 * this.amplitude * Math.pow(2, 20 * t - 10) * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n                    return -0.5 * this.amplitude * Math.pow(2, -20 * t + 10) * Math.sin(4 * t * Math.PI / this.period + Math.asin(1 / this.amplitude)) + 1;\n                case Easing.OutInElastic:\n                    if (t < 0.5) return 0.5 * this.amplitude * Math.pow(2, -20 * t) * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude)) + 0.5;\n                    return -0.5 * this.amplitude * Math.pow(2, 20 * t - 20) * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude)) + 0.5;\n                // Back\n                case Easing.InBack:\n                    return (this.overshoot + 1) * Math.pow(t, 3) - this.overshoot * Math.pow(t, 2);\n                case Easing.OutBack:\n                    return (this.overshoot + 1) * Math.pow(t - 1, 3) + this.overshoot * Math.pow(t - 1, 2) + 1;\n                case Easing.InOutBack:\n                    if (t < 0.5) return 4 * (this.overshoot + 1) * Math.pow(t, 3) - 2 * this.overshoot * Math.pow(t, 2);\n                    return 0.5 * (this.overshoot + 1) * Math.pow(2 * t - 2, 3) + this.overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;\n                case Easing.OutInBack:\n                    if (t < 0.5) return 0.5 * ((this.overshoot + 1) * Math.pow(2 * t - 1, 3) + this.overshoot * Math.pow(2 * t - 1, 2) + 1);\n                    return 4 * (this.overshoot + 1) * Math.pow(t - 0.5, 3) - 2 * this.overshoot * Math.pow(t - 0.5, 2) + 0.5;\n                // Bounce\n                case Easing.InBounce:\n                    if (t < 1 / 11) return -this.amplitude * (121 / 16) * (t * t - 1 / 11 * t);\n                    if (t < 3 / 11) return -this.amplitude * (121 / 16) * (t * t - 4 / 11 * t + 3 / 121);\n                    if (t < 7 / 11) return -this.amplitude * (121 / 16) * (t * t - 10 / 11 * t + 21 / 121);\n                    return -(121 / 16) * (t * t - 2 * t + 1) + 1;\n                case Easing.OutBounce:\n                    if (t < 4 / 11) return 121 / 16 * t * t;\n                    if (t < 8 / 11) return this.amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;\n                    if (t < 10 / 11) return this.amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;\n                    return this.amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;\n                case Easing.InOutBounce:\n                    if (t < 1 / 22) return -this.amplitude * (121 / 8) * (t * t - 1 / 22 * t);\n                    if (t < 3 / 22) return -this.amplitude * (121 / 8) * (t * t - 2 / 11 * t + 3 / 484);\n                    if (t < 7 / 22) return -this.amplitude * (121 / 8) * (t * t - 5 / 11 * t + 21 / 484);\n                    if (t < 11 / 22) return -(121 / 8) * (t * t - t + 0.25) + 0.5;\n                    if (t < 15 / 22) return 121 / 8 * (t * t - t) + 137 / 32;\n                    if (t < 19 / 22) return this.amplitude * (121 / 8) * (t * t - 17 / 11 * t + 285 / 484) + 1;\n                    if (t < 21 / 22) return this.amplitude * (121 / 8) * (t * t - 20 / 11 * t + 399 / 484) + 1;\n                    return this.amplitude * (121 / 8) * (t * t - 43 / 22 * t + 21 / 22) + 1;\n                case Easing.OutInBounce:\n                    if (t < 4 / 22) return 121 / 8 * t * t;\n                    if (t < 8 / 22) return -this.amplitude * (121 / 8) * (t * t - 6 / 11 * t + 8 / 121) + 0.5;\n                    if (t < 10 / 22) return -this.amplitude * (121 / 8) * (t * t - 9 / 11 * t + 20 / 121) + 0.5;\n                    if (t < 11 / 22) return -this.amplitude * (121 / 8) * (t * t - 21 / 22 * t + 5 / 22) + 0.5;\n                    if (t < 12 / 22) return this.amplitude * (121 / 8) * (t * t - 23 / 22 * t + 3 / 11) + 0.5;\n                    if (t < 14 / 22) return this.amplitude * (121 / 8) * (t * t - 13 / 11 * t + 42 / 121) + 0.5;\n                    if (t < 18 / 22) return this.amplitude * (121 / 8) * (t * t - 16 / 11 * t + 63 / 121) + 0.5;\n                    return -(121 / 8) * (t * t - 2 * t + 117 / 121) + 0.5;\n                // Default\n                default:\n                    console.log(\"Unsupported animation type: \", this.type);\n                // Linear\n                case Easing.Linear:\n                    return t;\n            }\n        };\n\n        this.$redoActions = function () {\n            this.$actions = [];\n            for (var i = 0; i < this.$targets.length; i++) {\n                for (var j in this.$props) {\n                    this.$actions.push({\n                        target: this.$targets[i],\n                        property: this.$props[j],\n                        from: this.from,\n                        to: this.to\n                    });\n                }\n            }\n        };\n        function redoProperties() {\n            this.$props = this.properties.split(\",\");\n\n            // Remove whitespaces\n            for (var i = 0; i < this.$props.length; i++) {\n                var matches = this.$props[i].match(/\\w+/);\n                if (matches) {\n                    this.$props[i] = matches[0];\n                } else {\n                    this.$props.splice(i, 1);\n                    i--;\n                }\n            }\n            // Merge properties and property\n            if (this.property && this.$props.indexOf(this.property) === -1) this.$props.push(this.property);\n        }\n        function redoTargets() {\n            this.$targets = this.targets.slice();\n\n            if (this.target && this.$targets.indexOf(this.target) === -1) this.$targets.push(this.target);\n        }\n\n        this.duration = 250;\n        this.easing.type = Easing.Linear;\n        this.easing.amplitude = 1;\n        this.easing.period = 0.3;\n        this.easing.overshoot = 1.70158;\n        this.$props = [];\n        this.$targets = [];\n        this.$actions = [];\n        this.properties = \"\";\n        this.targets = [];\n\n        this.targetChanged.connect(this, redoTargets);\n        this.targetsChanged.connect(this, redoTargets);\n        this.propertyChanged.connect(this, redoProperties);\n        this.propertiesChanged.connect(this, redoProperties);\n\n        if (meta.object.$on !== undefined) {\n            this.property = meta.object.$on;\n            this.target = this.$parent;\n        }\n    }\n});\n\nfunction QMLPropertyChanges(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"QtObject\", this, \"target\");\n    createProperty(\"bool\", this, \"explicit\");\n    createProperty(\"bool\", this, \"restoreEntryValues\", { initialValue: true });\n\n    this.$actions = [];\n\n    this.$setCustomData = function (propName, value) {\n        this.$actions.push({\n            property: propName,\n            value: value\n        });\n    };\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'PropertyChanges',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: QMLPropertyChanges\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Rectangle',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: QMLRectangle\n});\n\nfunction QMLRectangle(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"color\", this, \"color\", { initialValue: 'white' });\n    createProperty(\"real\", this, \"radius\");\n\n    this.border = new QObject(this);\n    createProperty(\"color\", this.border, \"color\", { initialValue: 'black' });\n    createProperty(\"int\", this.border, \"width\", { initialValue: 1 });\n\n    var bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.position = 'absolute';\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = '0px';\n    bg.style.borderWidth = '0px';\n    bg.style.borderStyle = 'solid';\n    bg.style.borderColor = 'black';\n    bg.style.backgroundColor = 'white';\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, function (newVal) {\n        bg.style.backgroundColor = QMLColor(newVal);\n    });\n    this.radiusChanged.connect(this, function (newVal) {\n        bg.style.borderRadius = newVal + 'px';\n    });\n    this.border.colorChanged.connect(this, function (newVal) {\n        bg.style.borderColor = QMLColor(newVal);\n        if (bg.style.borderWidth == '0px') {\n            bg.style.borderWidth = this.border.width + 'px';\n        }\n        this.$updateBorder(this.border.width);\n    });\n    this.border.widthChanged.connect(this, function (newVal) {\n        // ignore negative border width\n        if (newVal >= 0) {\n            this.$updateBorder(newVal);\n        } else {\n            bg.style.borderWidth = \"0px\";\n        }\n    });\n    this.widthChanged.connect(this, function (newVal) {\n        this.$updateBorder(this.border.width);\n    });\n    this.heightChanged.connect(this, function (newVal) {\n        this.$updateBorder(this.border.width);\n    });\n}\n\nQMLRectangle.prototype.$updateBorder = function (newBorderWidth) {\n    var bg = this.dom.firstChild;\n\n    // ignore negative and 0px border width\n    if (newBorderWidth == \"0px\" || newBorderWidth < 0) {\n        return;\n    }\n    // no Rectangle border width was set yet\n    if (newBorderWidth == \"1\" && bg.style.borderWidth == \"0px\" || typeof newBorderWidth === \"undefined\" && bg.style.borderWidth == \"0px\") {\n        return;\n    }\n\n    var topBottom = typeof newBorderWidth === \"undefined\" ? bg.style.borderWidth : newBorderWidth + 'px';\n    var leftRight = topBottom;\n\n    bg.style.borderTopWidth = topBottom;\n    bg.style.borderBottomWidth = topBottom;\n    bg.style.borderLeftWidth = leftRight;\n    bg.style.borderRightWidth = leftRight;\n\n    // hide border if any of dimensions is less then one\n    if (this.width <= 0 || this.height <= 0 || typeof this.width === \"undefined\" || typeof this.height === \"undefined\") {\n        bg.style.borderWidth = '0px';\n    } else {\n        // check if border is not greater than Rectangle size\n        // react by change of width or height of div (in css)\n\n        if (2 * this.border.width > this.height) {\n            topBottom = this.height / 2 + 'px';\n            bg.style.height = '0px';\n        } else {\n            if (this.height - 2 * this.border.width < this.border.width) {\n                if (this.height > 2) {\n                    bg.style.height = (this.height % 2 ? -1 : -2 + this.height + (this.height - 2 * this.border.width)) + 'px';\n                }\n            }\n        }\n\n        if (2 * this.border.width > this.width) {\n            leftRight = this.width / 2 + 'px';\n            bg.style.width = '0px';\n        } else {\n            if (this.width - 2 * this.border.width < this.border.width) {\n                if (this.width > 2) {\n                    bg.style.width = (this.width % 2 ? -1 : -2 + this.width + (this.width - 2 * this.border.width)) + 'px';\n                }\n            }\n        }\n\n        bg.style.borderTopWidth = topBottom;\n        bg.style.borderBottomWidth = topBottom;\n        bg.style.borderLeftWidth = leftRight;\n        bg.style.borderRightWidth = leftRight;\n    }\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'RegExpValidator',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLRegExpValidator(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"var\", this, \"regExp\");\n\n        this.validate = function (string) {\n            if (typeof this.regExp == 'undefined' || this.regExp == null) return true;\n            return this.regExp.test(string);\n        }.bind(this);\n    }\n});\n\nfunction QMLRepeater(meta) {\n    callSuper(this, meta);\n    var self = this;\n    var QMLListModel = getConstructor('QtQuick', '2.0', 'ListModel');\n\n    this.parent = meta.parent; // TODO: some (all ?) of the components including Repeater needs to know own parent at creation time. Please consider this major change.\n\n    createProperty(\"Component\", this, \"delegate\");\n    this.container = function () {\n        return this.parent;\n    };\n    this.$defaultProperty = \"delegate\";\n    createProperty(\"variant\", this, \"model\", { initialValue: 0 });\n    createProperty(\"int\", this, \"count\");\n    this.$completed = false;\n    this.$items = []; // List of created items\n    this._childrenInserted = Signal();\n\n    this.modelChanged.connect(applyModel);\n    this.delegateChanged.connect(applyModel);\n    this.parentChanged.connect(applyModel);\n\n    this.itemAt = function (index) {\n        return this.$items[index];\n    };\n\n    function callOnCompleted(child) {\n        child.Component.completed();\n        for (var i = 0; i < child.$tidyupList.length; i++) {\n            if (child.$tidyupList[i] instanceof QMLBaseObject) callOnCompleted(child.$tidyupList[i]);\n        }\n    }\n    function insertChildren(startIndex, endIndex) {\n        if (endIndex <= 0) return;\n\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n\n        for (var index = startIndex; index < endIndex; index++) {\n            var newItem = self.delegate.createObject();\n            createProperty('int', newItem, 'index', { initialValue: index });\n            newItem.parent = self.parent;\n            self.delegate.finalizeImports(); // To properly import JavaScript in the context of a component\n\n            if (typeof model == \"number\" || model instanceof Array) {\n                if (typeof newItem.$properties[\"modelData\"] == 'undefined') {\n                    createProperty(\"variant\", newItem, \"modelData\");\n                }\n                var value = model instanceof Array ? model[index] : typeof model == \"number\" ? index : \"undefined\";\n                newItem.$properties[\"modelData\"].set(value, true, newItem, model.$context);\n            } else {\n                for (var i = 0; i < model.roleNames.length; i++) {\n                    var roleName = model.roleNames[i];\n                    if (typeof newItem.$properties[roleName] == 'undefined') createProperty(\"variant\", newItem, roleName);\n                    newItem.$properties[roleName].set(model.data(index, roleName), true, newItem, self.model.$context);\n                }\n            }\n\n            self.$items.splice(index, 0, newItem);\n\n            // TODO debug this. Without check to Init, Completed sometimes called twice.. But is this check correct?\n            if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n                // We don't call those on first creation, as they will be called\n                // by the regular creation-procedures at the right time.\n                callOnCompleted(newItem);\n            }\n        }\n        if (engine.operationState !== QMLOperationState.Init) {\n            // We don't call those on first creation, as they will be called\n            // by the regular creation-procedures at the right time.\n            engine.$initializePropertyBindings();\n        }\n\n        if (index > 0) {\n            self.container().childrenChanged();\n        }\n\n        for (var i = endIndex; i < self.$items.length; i++) {\n            self.$items[i].index = i;\n        }self.count = self.$items.length;\n    }\n\n    function onModelDataChanged(startIndex, endIndex, roles) {\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n\n        if (!roles) roles = model.roleNames;\n        for (var index = startIndex; index <= endIndex; index++) {\n            for (var i in roles) {\n                self.$items[index].$properties[roles[i]].set(model.data(index, roles[i]), QMLProperty.ReasonInit, self.$items[index], self.model.$context);\n            }\n        }\n    }\n    function onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\n        var vals = self.$items.splice(sourceStartIndex, sourceEndIndex - sourceStartIndex);\n        for (var i = 0; i < vals.length; i++) {\n            self.$items.splice(destinationIndex + i, 0, vals[i]);\n        }\n        var smallestChangedIndex = sourceStartIndex < destinationIndex ? sourceStartIndex : destinationIndex;\n        for (var i = smallestChangedIndex; i < self.$items.length; i++) {\n            self.$items[i].index = i;\n        }\n    }\n    function onRowsRemoved(startIndex, endIndex) {\n        removeChildren(startIndex, endIndex);\n        for (var i = startIndex; i < self.$items.length; i++) {\n            self.$items[i].index = i;\n        }\n        self.count = self.$items.length;\n    }\n    function onModelReset() {\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n        removeChildren(0, self.$items.length);\n    }\n    function applyModel() {\n        if (!self.delegate || !self.parent) return;\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n        if (model instanceof JSItemModel) {\n            if (model.dataChanged.isConnected(onModelDataChanged) == false) model.dataChanged.connect(onModelDataChanged);\n            if (model.rowsInserted.isConnected(insertChildren) == false) model.rowsInserted.connect(insertChildren);\n            if (model.rowsMoved.isConnected(onRowsMoved) == false) model.rowsMoved.connect(onRowsMoved);\n            if (model.rowsRemoved.isConnected(onRowsRemoved) == false) model.rowsRemoved.connect(onRowsRemoved);\n            if (model.modelReset.isConnected(onModelReset) == false) model.modelReset.connect(onModelReset);\n\n            removeChildren(0, self.$items.length);\n            insertChildren(0, model.rowCount());\n        } else if (typeof model == \"number\") {\n            // must be more elegant here.. do not delete already created models..\n            //removeChildren(0, self.$items.length);\n            //insertChildren(0, model);\n\n            if (self.$items.length > model) {\n                // have more than we need\n                removeChildren(model, self.$items.length);\n            } else {\n                // need more\n                insertChildren(self.$items.length, model);\n            }\n        } else if (model instanceof Array) {\n            removeChildren(0, self.$items.length);\n            insertChildren(0, model.length);\n        }\n    }\n\n    function removeChildren(startIndex, endIndex) {\n        var removed = self.$items.splice(startIndex, endIndex - startIndex);\n        for (var index in removed) {\n            removed[index].$delete();\n            removeChildProperties(removed[index]);\n        }\n    }\n    function removeChildProperties(child) {\n        engine.completedSignals.splice(engine.completedSignals.indexOf(child.Component.completed), 1);\n        for (var i = 0; i < child.children.length; i++) {\n            removeChildProperties(child.children[i]);\n        }\n    }\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Repeater',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: QMLRepeater\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Rotation',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLRotation(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"real\", this, \"angle\");\n\n        this.axis = new QObject(this);\n        createProperty(\"real\", this.axis, \"x\");\n        createProperty(\"real\", this.axis, \"y\");\n        createProperty(\"real\", this.axis, \"z\", { initialValue: 1 });\n\n        this.origin = new QObject(this);\n        createProperty(\"real\", this.origin, \"x\");\n        createProperty(\"real\", this.origin, \"y\");\n\n        function updateOrigin() {\n            this.$parent.dom.style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n            this.$parent.dom.style.MozTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Firefox\n            this.$parent.dom.style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Chrome, Safari and Opera\n        }\n        this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.origin.xChanged.connect(this, updateOrigin);\n        this.origin.yChanged.connect(this, updateOrigin);\n        this.$parent.$updateTransform();\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Row',\n    versions: /.*/,\n    baseClass: 'Positioner',\n    constructor: QMLRow\n});\n\nfunction QMLRow(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"enum\", this, \"layoutDirection\", { initialValue: 0 });\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLRow.prototype.layoutChildren = function () {\n    var curPos = 0,\n        maxHeight = 0,\n\n    // When layoutDirection is RightToLeft we need oposite order\n    i = this.layoutDirection == 1 ? this.children.length - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : this.children.length,\n        step = this.layoutDirection == 1 ? -1 : 1;\n    for (; i !== endPoint; i += step) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height)) continue;\n        maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n        child.x = curPos;\n        curPos += child.width + this.spacing;\n    }\n    this.implicitHeight = maxHeight;\n    this.implicitWidth = curPos - this.spacing; // We want no spacing at the right side\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Scale',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLScale(meta) {\n        var _this5 = this;\n\n        callSuper(this, meta);\n\n        createProperty(\"real\", this, \"xScale\");\n        createProperty(\"real\", this, \"yScale\");\n\n        this.origin = new QObject(this);\n        createProperty(\"real\", this.origin, \"x\");\n        createProperty(\"real\", this.origin, \"y\");\n\n        var updateOrigin = function updateOrigin() {\n            _this5.$parent.dom.style.transformOrigin = _this5.origin.x + \"px \" + _this5.origin.y + \"px\";\n            _this5.$parent.dom.style.MozTransformOrigin = _this5.origin.x + \"px \" + _this5.origin.y + \"px\"; // Firefox\n            _this5.$parent.dom.style.webkitTransformOrigin = _this5.origin.x + \"px \" + _this5.origin.y + \"px\"; // Chrome, Safari and Opera\n        };\n        this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.origin.xChanged.connect(this, updateOrigin);\n        this.origin.yChanged.connect(this, updateOrigin);\n\n        this.xScale = 0;\n        this.yScale = 0;\n        this.origin.x = 0;\n        this.origin.y = 0;\n\n        /* QML default origin is top-left, while CSS default origin is centre, so\n         * updateOrigin must be called to set the initial transformOrigin. */\n        updateOrigin();\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'SequentialAnimation',\n    versions: /.*/,\n    baseClass: 'Animation',\n    constructor: function QMLSequentialAnimation(meta) {\n        callSuper(this, meta);\n        var curIndex,\n            passedLoops,\n            i,\n            self = this;\n\n        createProperty(\"list\", this, \"animations\");\n        this.$defaultProperty = \"animations\";\n\n        function nextAnimation(proceed) {\n            var anim;\n            if (self.running && !proceed) {\n                curIndex++;\n                if (curIndex < self.animations.length) {\n                    anim = self.animations[curIndex];\n                    console.log(\"nextAnimation\", self, curIndex, anim);\n                    anim.start();\n                } else {\n                    passedLoops++;\n                    if (passedLoops >= self.loops) {\n                        self.complete();\n                    } else {\n                        curIndex = -1;\n                        nextAnimation();\n                    }\n                }\n            }\n        }\n\n        this.animationsChanged.connect(this, function () {\n            for (i = 0; i < this.animations.length; i++) {\n                if (!this.animations[i].runningChanged.isConnected(nextAnimation)) this.animations[i].runningChanged.connect(nextAnimation);\n            }\n        });\n\n        this.start = function () {\n            if (!this.running) {\n                this.running = true;\n                curIndex = -1;\n                passedLoops = 0;\n                nextAnimation();\n            }\n        };\n        this.stop = function () {\n            if (this.running) {\n                this.running = false;\n                if (curIndex < this.animations.length) {\n                    this.animations[curIndex].stop();\n                }\n            }\n        };\n\n        this.complete = function () {\n            if (this.running) {\n                if (curIndex < this.animations.length) {\n                    // Stop current animation\n                    this.animations[curIndex].stop();\n                }\n                this.running = false;\n            }\n        };\n\n        engine.$registerStart(function () {\n            if (self.running) {\n                self.running = false; // toggled back by start();\n                self.start();\n            }\n        });\n        engine.$registerStop(function () {\n            self.stop();\n        });\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'State',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLState(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"string\", this, \"name\");\n        createProperty(\"list\", this, \"changes\");\n        this.$defaultProperty = \"changes\";\n        createProperty(\"string\", this, \"extend\");\n        createProperty(\"bool\", this, \"when\");\n        this.$item = this.$parent;\n\n        this.whenChanged.connect(this, function (newVal) {\n            if (newVal) this.$item.state = this.name;else if (this.$item.state == this.name) this.$item.state = \"\";\n        });\n\n        this.$getAllChanges = function () {\n            if (this.extend) {\n                for (var i = 0; i < this.$item.states.length; i++) {\n                    if (this.$item.states[i].name == this.extend) return this.$item.states[i].$getAllChanges().concat(this.changes);\n                }\n            } else return this.changes;\n        };\n    }\n});\n\nwindow.SystemPalette = {\n    Active: \"active\",\n    Inactive: \"inactive\",\n    Disabled: \"disabled\"\n};\n\nwindow.platformsDetectors = [\n//{ name: 'W8',      regexp: /Windows NT 6\\.2/ },\n//{ name: 'W7',      regexp: /Windows NT 6\\.1/ },\n//{ name: 'Windows', regexp: /Windows NT/ },\n{ name: 'OSX', regexp: /Macintosh/ }];\n\nwindow.systemPalettes = {};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'SystemPalette',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLSystemPalette(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"enum\", this, \"colorGroup\");\n\n        var attrs = ['alternateBase', 'base', 'button', 'buttonText', 'dark', 'highlight', 'highlightedText', 'light', 'mid', 'midlight', 'shadow', 'text', 'window', 'windowText'];\n        var platform = 'OSX';\n\n        for (var i = 0; i < attrs.length; ++i) {\n            createProperty(\"color\", this, attrs[i], { readOnly: true });\n        }createProperty(\"enum\", this, \"colorGroup\");\n\n        this.colorGroupChanged.connect(this, function (newVal) {\n            this.$canEditReadOnlyProperties = true;\n            for (var i = 0; i < attrs.length; ++i) {\n                this[attrs[i]] = systemPalettes[platform][newVal][attrs[i]];\n            }\n            delete this.$canEditReadOnlyProperties;\n        }.bind(this));\n\n        // Detect OS\n        for (var i = 0; i < platformsDetectors.length; ++i) {\n            if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n                platforms = platformsDetectors[i].name;\n                break;\n            }\n        }\n    }\n});\n\nwindow.systemPalettes['OSX'] = {\n    'active': {\n        'alternateBase': '#f6f6f6',\n        'base': '#ffffff',\n        'button': '#ededed',\n        'buttonText': '#000000',\n        'dark': '#bfbfbf',\n        'highlight': '#fbed73',\n        'highlightText': '#000000',\n        'light': '#ffffff',\n        'mid': '#a9a9a9',\n        'midlight': '#f6f6f6',\n        'shadow': '#8b8b8b',\n        'text': '#000000',\n        'window': '#ededed',\n        'windowText': '#000000'\n    },\n    'inactive': {\n        'alternateBase': '#f6f6f6',\n        'base': '#ffffff',\n        'button': '#ededed',\n        'buttonText': '#000000',\n        'dark': '#bfbfbf',\n        'highlight': '#d0d0d0',\n        'highlightText': '#000000',\n        'light': '#ffffff',\n        'mid': '#a9a9a9',\n        'midlight': '#f6f6f6',\n        'shadow': '#8b8b8b',\n        'text': '#000000',\n        'window': '#ededed',\n        'windowText': '#000000'\n    },\n    'disabled': {\n        'alternateBase': '#f6f6f6',\n        'base': '#ededed',\n        'button': '#ededed',\n        'buttonText': '#949494',\n        'dark': '#bfbfbf',\n        'highlight': '#d0d0d0',\n        'highlightText': '#7f7f7f',\n        'light': '#ffffff',\n        'mid': '#a9a9a9',\n        'midlight': '#f6f6f6',\n        'shadow': '#8b8b8b',\n        'text': '#7f7f7f',\n        'window': '#ededed',\n        'windowText': '#7f7f7f'\n    }\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Text',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLText(meta) {\n        callSuper(this, meta);\n\n        var fc = this.impl = document.createElement('span');\n        fc.style.pointerEvents = 'none';\n        fc.style.width = '100%';\n        fc.style.height = '100%';\n        this.dom.appendChild(fc);\n\n        this.Text = {\n            // Wrap Mode\n            NoWrap: 0,\n            WordWrap: 1,\n            WrapAnywhere: 2,\n            Wrap: 3,\n            WrapAtWordBoundaryOrAnywhere: 3, // COMPAT\n            // Horizontal-Alignment\n            AlignLeft: \"left\",\n            AlignRight: \"right\",\n            AlignHCenter: \"center\",\n            AlignJustify: \"justify\",\n            // Style\n            Normal: 0,\n            Outline: 1,\n            Raised: 2,\n            Sunken: 3\n        };\n\n        var QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n        this.font = new QMLFont(this);\n\n        createProperty(\"color\", this, \"color\");\n        createProperty(\"string\", this, \"text\");\n        createProperty(\"real\", this, \"lineHeight\");\n        createProperty(\"enum\", this, \"wrapMode\");\n        createProperty(\"enum\", this, \"horizontalAlignment\");\n        createProperty(\"enum\", this, \"style\");\n        createProperty(\"color\", this, \"styleColor\");\n\n        this.colorChanged.connect(this, function (newVal) {\n            fc.style.color = QMLColor(newVal);\n        });\n        this.textChanged.connect(this, function (newVal) {\n            fc.innerHTML = newVal;\n        });\n        this.lineHeightChanged.connect(this, function (newVal) {\n            fc.style.lineHeight = newVal + \"px\";\n        });\n        this.wrapModeChanged.connect(this, function (newVal) {\n            switch (newVal) {\n                case 0:\n                    fc.style.whiteSpace = \"pre\";\n                    break;\n                case 1:\n                    fc.style.whiteSpace = \"pre-wrap\";\n                    fc.style.wordWrap = \"normal\";\n                    break;\n                case 2:\n                    fc.style.whiteSpace = \"pre-wrap\";\n                    fc.style.wordBreak = \"break-all\";\n                    break;\n                case 3:\n                    fc.style.whiteSpace = \"pre-wrap\";\n                    fc.style.wordWrap = \"break-word\";\n            };\n            // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n            // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n            if (this.horizontalAlignment == \"justify\") fc.style.whiteSpace = \"normal\";\n        });\n        this.horizontalAlignmentChanged.connect(this, function (newVal) {\n            this.dom.style.textAlign = newVal;\n            // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n            // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n            if (newVal == \"justify\") fc.style.whiteSpace = \"normal\";\n        });\n        this.styleChanged.connect(this, function (newVal) {\n            switch (newVal) {\n                case 0:\n                    fc.style.textShadow = \"none\";\n                    break;\n                case 1:\n                    var color = this.styleColor;\n                    fc.style.textShadow = \"1px 0 0 \" + color + \", -1px 0 0 \" + color + \", 0 1px 0 \" + color + \", 0 -1px 0 \" + color;\n                    break;\n                case 2:\n                    fc.style.textShadow = \"1px 1px 0 \" + this.styleColor;\n                    break;\n                case 3:\n                    fc.style.textShadow = \"-1px -1px 0 \" + this.styleColor;\n            };\n        });\n        this.styleColorChanged.connect(this, function (newVal) {\n            newVal = QMLColor(newVal);\n            switch (this.style) {\n                case 0:\n                    fc.style.textShadow = \"none\";\n                    break;\n                case 1:\n                    fc.style.textShadow = \"1px 0 0 \" + newVal + \", -1px 0 0 \" + newVal + \", 0 1px 0 \" + newVal + \", 0 -1px 0 \" + newVal;\n                    break;\n                case 2:\n                    fc.style.textShadow = \"1px 1px 0 \" + newVal;\n                    break;\n                case 3:\n                    fc.style.textShadow = \"-1px -1px 0 \" + newVal;\n            };\n        });\n\n        this.font.family = \"sans-serif\";\n        this.font.pointSize = 10;\n        this.wrapMode = this.Text.NoWrap;\n        this.color = \"black\";\n        this.text = \"\";\n\n        this.textChanged.connect(this, updateImplicit);\n        this.font.boldChanged.connect(this, updateImplicit);\n        this.font.pixelSizeChanged.connect(this, updateImplicit);\n        this.font.pointSizeChanged.connect(this, updateImplicit);\n        this.font.familyChanged.connect(this, updateImplicit);\n        this.font.letterSpacingChanged.connect(this, updateImplicit);\n        this.font.wordSpacingChanged.connect(this, updateImplicit);\n\n        this.Component.completed.connect(this, updateImplicit);\n\n        function updateImplicit() {\n            if (_typeof(this.text) == undefined || this.text === \"\" || !this.dom) {\n                this.implicitHeigh = this.implicitWidth = 0;\n            } else {\n                this.implicitHeight = fc.offsetHeight;\n                this.implicitWidth = fc.offsetWidth;\n            }\n        }\n    }\n});\n\nfunction QMLTextEdit(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    // Properties\n    createProperty('bool', this, 'activeFocusOnPress');\n    createProperty('url', this, 'baseUrl');\n    createProperty('bool', this, 'canPaste');\n    createProperty('bool', this, 'canRedo');\n    createProperty('bool', this, 'canUndo');\n    createProperty('color', this, 'color');\n    createProperty('real', this, 'contentHeight');\n    createProperty('real', this, 'contentWidth');\n    createProperty('Component', this, 'cursorDelegate');\n    createProperty('int', this, 'cursorPosition');\n    createProperty('rectangle', this, 'cursorRectangle');\n    createProperty('bool', this, 'cursorVisible');\n    createProperty('enum', this, 'effectiveHorizontalAlignment');\n    createProperty('enum', this, 'horizontalAlignment');\n    createProperty('string', this, 'hoveredLink');\n    createProperty('bool', this, 'inputMethodComposing');\n    createProperty('enum', this, 'inputMethodHints');\n    createProperty('int', this, 'length');\n    createProperty('int', this, 'lineCount');\n    createProperty('enum', this, 'mouseSelectionMode');\n    createProperty('bool', this, 'persistentSelection');\n    createProperty('bool', this, 'readOnly');\n    createProperty('enum', this, 'renderType');\n    createProperty('bool', this, 'selectByKeyboard');\n    createProperty('bool', this, 'selectByMouse');\n    createProperty('string', this, 'selectedText');\n    createProperty('color', this, 'selectedTextColor');\n    createProperty('color', this, 'selectionColor');\n    createProperty('int', this, 'selectionEnd');\n    createProperty('int', this, 'selectionStart');\n    createProperty('string', this, 'text');\n    createProperty('TextDocument', this, 'textDocument');\n    createProperty('enum', this, 'textFormat');\n    createProperty('real', this, 'textMargin');\n    createProperty('enum', this, 'verticalAlignment');\n    createProperty('enum', this, 'wrapMode');\n\n    var QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    this.activeFocusOnPress = true;\n    this.baseUrl = undefined;\n    this.canPaste = false;\n    this.canRedo = false;\n    this.canUndo = false;\n    this.color = 'white';\n    this.contentHeight = 0;\n    this.contentWidth = 0;\n    this.cursorDelegate = undefined;\n    this.cursorPosition = 0;\n    this.cursorRectangle = undefined;\n    this.cursorVisible = true;\n    this.effectiveHorizontalAlignment = undefined;\n    this.horizontalAlignment = undefined;\n    this.hoveredLink = undefined;\n    this.inputMethodComposing = undefined;\n    this.inputMethodHints = undefined;\n    this.length = 0;\n    this.lineCount = 0;\n    this.mouseSelectionMode = undefined;\n    this.persistentSelection = false;\n    this.readOnly = false;\n    this.renderType = undefined;\n    this.selectByKeyboard = true;\n    this.selectByMouse = false;\n    this.selectedText = undefined;\n    this.selectedTextColor = 'yellow';\n    this.selectionColor = 'pink';\n    this.selectionEnd = 0;\n    this.selectionStart = 0;\n    this.text = '';\n    this.textDocument = undefined;\n    this.textFormat = undefined;\n    this.textMargin = 0;\n    this.verticalAlignment = undefined;\n    this.wrapMode = undefined;\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    var textarea = this.impl = document.createElement('textarea');\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = 'border-box';\n    textarea.style.borderWidth = '0';\n    textarea.style.background = 'none';\n    textarea.style.outline = 'none';\n    textarea.style.resize = 'none';\n    textarea.style.padding = '0'; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, function () {\n        this.implicitWidth = textarea.offsetWidth;\n        this.implicitHeight = textarea.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function (newVal) {\n        textarea.value = newVal;\n    });\n\n    // Signals\n    this.linkActivated = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n    this.linkHovered = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n\n    // Methods\n    this.append = function append(text) {\n        this.text += text;\n    };\n\n    this.copy = function copy() {\n        // TODO\n    };\n\n    this.cut = function cut() {\n        this.text = this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);\n        // TODO\n    };\n\n    this.deselect = function deselect() {\n        //this.selectionStart = -1;\n        //this.selectionEnd = -1;\n        //this.selectedText = null;\n    };\n\n    this.getFormattedText = function getFormattedText(start, end) {\n        this.text = this.text.slice(start, end);\n        // TODO\n        // process text\n        return text;\n    };\n\n    this.getText = function getText(start, end) {\n        return this.text.slice(start, end);\n    };\n\n    this.insert = function getText(position, text) {\n        // TODO\n    };\n\n    this.isRightToLeft = function isRightToLeft(start, end) {\n        // TODO\n    };\n\n    this.linkAt = function linkAt(x, y) {\n        // TODO\n    };\n\n    this.moveCursorSelection = function moveCursorSelection(x, y) {\n        // TODO\n    };\n\n    this.paste = function paste() {\n        // TODO\n    };\n\n    this.positionAt = function positionAt(x, y) {\n        // TODO\n    };\n\n    this.positionToRectangle = function positionToRectangle(position) {\n        // TODO\n    };\n\n    this.redo = function redo() {\n        // TODO\n    };\n\n    this.remove = function remove(start, end) {\n        // TODO\n    };\n\n    this.select = function select(start, end) {\n        // TODO\n    };\n\n    this.selectAll = function selectAll() {\n        // TODO\n    };\n\n    this.selectWord = function selectWord() {\n        // TODO\n    };\n\n    this.undo = function undo() {\n        // TODO\n    };\n\n    var getLineCount = function getLineCount(self) {\n        return self.text.split(/\\n/).length;\n    };\n\n    this.Component.completed.connect(this, function () {\n        this.selectByKeyboard = !this.readOnly;\n        updateValue();\n    });\n\n    // Transfer dom style to firstChild,\n    // then clear corresponding dom style\n    function updateCss(self) {\n        var supported = ['border', 'borderRadius', 'borderWidth', 'borderColor', 'backgroundColor'];\n\n        var child_style = self.dom.firstChild.style;\n        for (n = 0; n < supported.length; n++) {\n            var o = supported[n];\n            var v = self.css[o];\n            if (v) {\n                child_style[o] = v;\n                self.css[o] = null;\n            }\n        }\n    }\n\n    function updateValue(e) {\n        if (self.text != self.dom.firstChild.value) {\n            self.text = self.dom.firstChild.value;\n        }\n        self.length = self.text.length;\n        self.lineCount = getLineCount(self);\n        updateCss(self);\n    }\n\n    textarea.oninput = updateValue;\n    textarea.onpropertychanged = updateValue;\n\n    this.colorChanged.connect(this, function (newVal) {\n        textarea.style.color = newVal;\n    });\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'TextEdit',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: QMLTextEdit\n});\n\nglobal.TextInput = {\n    Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3\n};\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'TextInput',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function QMLTextInput(meta) {\n        callSuper(this, meta);\n\n        var self = this;\n\n        var QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n        this.font = new QMLFont(this);\n\n        var input = this.impl = document.createElement('input');\n        input.type = 'text';\n        input.disabled = true;\n        input.style.pointerEvents = \"auto\";\n        // In some browsers text-inputs have a margin by default, which distorts\n        // the positioning, so we need to manually set it to 0.\n        input.style.margin = \"0\";\n        input.style.padding = \"0\";\n        input.style.width = \"100%\";\n        input.style.height = \"100%\";\n        this.dom.appendChild(input);\n\n        this.setupFocusOnDom(input);\n\n        createProperty(\"string\", this, \"text\");\n        createProperty(\"int\", this, \"maximumLength\", { initialValue: -1 });\n        createProperty(\"bool\", this, \"readOnly\");\n        createProperty(\"var\", this, \"validator\");\n        createProperty(\"enum\", this, \"echoMode\");\n        this.accepted = Signal();\n        input.disabled = false;\n\n        this.Component.completed.connect(this, function () {\n            this.implicitWidth = input.offsetWidth;\n            this.implicitHeight = input.offsetHeight;\n        });\n\n        this.textChanged.connect(this, function (newVal) {\n            // We have to check if value actually changes.\n            // If we do not have this check, then after user updates text input following occurs:\n            // user update gui text -> updateValue called -> textChanged called -> gui value updates again -> caret position moves to the right!\n            if (input.value != newVal) input.value = newVal;\n        });\n\n        this.echoModeChanged.connect(this, function (newVal) {\n            switch (newVal) {\n                case TextInput.Normal:\n                    input.type = \"text\";\n                    break;\n                case TextInput.Password:\n                    input.type = \"password\";\n                    break;\n                case TextInput.NoEcho:\n                    // Not supported, use password, that's nearest\n                    input.type = \"password\";\n                    break;\n                case TextInput.PasswordEchoOnEdit:\n                    // Not supported, use password, that's nearest\n                    input.type = \"password\";\n                    break;\n            }\n        }.bind(this));\n\n        this.maximumLengthChanged.connect(this, function (newVal) {\n            if (newVal < 0) newVal = null;\n            input.maxLength = newVal;\n        });\n\n        this.readOnlyChanged.connect(this, function (newVal) {\n            input.disabled = newVal;\n        });\n\n        this.Keys.pressed.connect(this, function (e) {\n            if ((e.key == Qt.Key_Return || e.key == Qt.Key_Enter) && testValidator()) {\n                self.accepted();\n                e.accepted = true;\n            }\n        }.bind(this));\n\n        function testValidator() {\n            if (typeof self.validator != 'undefined' && self.validator != null) return self.validator.validate(self.text);\n            return true;\n        }\n\n        function updateValue(e) {\n            if (self.text != self.dom.firstChild.value) {\n                self.$canEditReadOnlyProperties = true;\n                self.text = self.dom.firstChild.value;\n                self.$canEditReadOnlyProperties = false;\n            }\n        }\n\n        input.oninput = updateValue;\n        input.onpropertychanged = updateValue;\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Transition',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLTransition(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"list\", this, \"animations\");\n        this.$defaultProperty = \"animations\";\n        createProperty(\"string\", this, \"from\", { initialValue: '*' });\n        createProperty(\"string\", this, \"to\", { initialValue: '*' });\n        createProperty(\"bool\", this, \"reversible\");\n        this.$item = this.$parent;\n\n        this.$start = function (actions) {\n            for (var i = 0; i < this.animations.length; i++) {\n                var animation = this.animations[i];\n                animation.$actions = [];\n                for (var j in actions) {\n                    var action = actions[j];\n                    if ((animation.$targets.length === 0 || animation.$targets.indexOf(action.target) !== -1) && (animation.$props.length === 0 || animation.$props.indexOf(action.property) !== -1)) animation.$actions.push(action);\n                }\n                animation.start();\n            }\n        };\n        this.$stop = function () {\n            for (var i = 0; i < this.animations.length; i++) {\n                this.animations[i].stop();\n            }\n        };\n    }\n});\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Translate',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLTranslate(meta) {\n        callSuper(this, meta);\n\n        createProperty(\"real\", this, \"x\");\n        createProperty(\"real\", this, \"y\");\n\n        this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n        this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n\n        this.x = 0;\n        this.y = 0;\n    }\n});\n\n// WARNING: Can have wrong behavior if url is changed while the socket is in Connecting state.\n// TODO: Recheck everything.\n\nregisterQmlType({\n    module: 'QtWebSockets',\n    name: 'WebSocket',\n    versions: /.*/,\n    baseClass: 'QtQml.QtObject',\n    constructor: function QMLWebSocket(meta) {\n        callSuper(this, meta);\n\n        // Exports.\n        this.WebSocket = {\n            // status\n            Connecting: 0,\n            Open: 1,\n            Closing: 2,\n            Closed: 3,\n            Error: 4\n        };\n\n        createProperty(\"bool\", this, \"active\");\n        createProperty(\"enum\", this, \"status\");\n        createProperty(\"string\", this, \"errorString\");\n        createProperty(\"url\", this, \"url\");\n\n        this.textMessageReceived = Signal([{ type: \"string\", name: \"message\" }]);\n\n        this.status = this.WebSocket.Closed;\n\n        var self = this,\n            socket,\n            reconnect = false;\n\n        this.sendTextMessage = function (message) {\n            if (this.status == this.WebSocket.Open) socket.send(message);\n        };\n\n        function connectSocket() {\n            reconnect = false;\n\n            if (!self.url || !self.active) return;\n\n            self.status = self.WebSocket.Connecting;\n            socket = new WebSocket(self.url);\n            socket.onopen = function () {\n                self.status = self.WebSocket.Open;\n            };\n            socket.onclose = function () {\n                self.status = self.WebSocket.Closed;\n                if (reconnect) connectSocket();\n            };\n            socket.onerror = function (error) {\n                self.errorString = error.message;\n                self.status = self.WebSocket.Error;\n            };\n            socket.onmessage = function (message) {\n                self.textMessageReceived(message.data);\n            };\n        };\n\n        function reconnectSocket() {\n            reconnect = true;\n            if (self.status == self.WebSocket.Open) {\n                self.status = self.WebSocket.Closing;\n                socket.close();\n            } else if (self.status != self.WebSocket.Closing) {\n                connectSocket();\n            }\n        };\n\n        this.statusChanged.connect(this, function (status) {\n            if (status != self.WebSocket.Error) self.errorString = \"\";\n        });\n        this.activeChanged.connect(this, reconnectSocket);\n        this.urlChanged.connect(this, reconnectSocket);\n    }\n});\n}(typeof global != 'undefined' ? global : window));\n\n\n",null,"/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nQMLMethod.prototype = new QMLBinding();\nfunction QMLMethod(src) {\n    this.src = src;\n}\n\n/**\n * Create an object representing a QML property definition.\n * @param {String} type The type of the property\n * @param {Array} value The default value of the property\n * @return {Object} Object representing the defintion\n */\nfunction QMLPropertyDefinition(type, value) {\n    this.type = type;\n    this.value = value;\n}\n\nfunction QMLAliasDefinition(objName, propName) {\n    this.objectName = objName;\n    this.propertyName = propName;\n}\n\n/**\n * Create an object representing a QML signal definition.\n * @param {Array} params The parameters the signal ships\n * @return {Object} Object representing the defintion\n */\nfunction QMLSignalDefinition(params) {\n    this.parameters = params;\n}\n\n/**\n * Create an object representing a group of QML properties (like anchors).\n * @return {Object} Object representing the group\n */\nfunction QMLMetaPropertyGroup() {}\n\n/**\n * Create an object representing a QML element.\n * @param {String} type The type of the element\n * @param {String} onProp The name of the property specified with the \"on\" keyword\n */\nfunction QMLMetaElement(type, onProp) {\n    this.$class = type;\n    this.$children = [];\n    this.$on = onProp;\n}\n\n// Convert parser tree to the format understood by engine\nfunction convertToEngine(tree) {\n\n    // Help logger\n    function amIn(str, tree) {\n        console.log(str);\n        if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n    }\n\n    var walkers = {\n        \"toplevel\": function(imports, statement) {\n            var item = { $class: \"Component\" };\n            item.$imports = imports;\n            item.$children = [ walk(statement) ];\n            return item;\n        },\n        \"qmlelem\": function(elem, onProp, statements) {\n            var item = new QMLMetaElement(elem, onProp);\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                switch (statement[0]) {\n                    case \"qmldefaultprop\":\n                        item.$defaultProperty = name;\n                    case \"qmlprop\":\n                    case \"qmlpropdef\":\n                    case \"qmlaliasdef\":\n                    case \"qmlmethod\":\n                    case \"qmlsignaldef\":\n                        item[name] = val;\n                        break;\n                    case \"qmlelem\":\n                        item.$children.push(val);\n                        break;\n                    case \"qmlobjdef\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        item[name][statement[2]] = val;\n                        break;\n                    case \"qmlobj\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        for (var i in val)\n                            item[name][i] = val[i];\n                        break;\n                    default:\n                        console.log(\"Unknown statement\", statement);\n\n                }\n            }\n            // Make $children be either a single item or an array, if it's more than one\n            if (item.$children.length === 1)\n                item.$children = item.$children[0];\n\n            return item;\n        },\n        \"qmlprop\": function(name, tree, src) {\n            if (name == \"id\") {\n                // id property\n                return tree[1][1];\n            }\n            return bindout(tree, src);\n        },\n        \"qmlobjdef\": function(name, property, tree, src) {\n            return bindout(tree, src);\n        },\n        \"qmlobj\": function(elem, statements) {\n            var item = {};\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                if (statement[0] == \"qmlprop\")\n                    item[name] = val;\n            }\n\n            return item;\n        },\n        \"qmlmethod\": function(name, tree, src) {\n            return new QMLMethod(src);\n        },\n        \"qmlpropdef\": function(name, type, tree, src) {\n            return new QMLPropertyDefinition(type, tree ? bindout(tree, src) : undefined);\n        },\n        \"qmlaliasdef\": function(name, objName, propName) {\n            return new QMLAliasDefinition(objName, propName);\n        },\n        \"qmlsignaldef\": function(name, params) {\n            return new QMLSignalDefinition(params);\n        },\n        \"qmldefaultprop\": function(tree) {\n            return walk(tree);\n        },\n        \"name\": function(src) {\n            if (src == \"true\" || src == \"false\")\n                return src == \"true\";\n            return new QMLBinding(src, [\"name\", src]);\n        },\n        \"num\": function(src) {\n            return +src;\n        },\n        \"string\": function(src) {\n            return String(src);\n        },\n        \"array\": function(tree, src) {\n            var a = [];\n            var isList = false;\n            var hasBinding = false;\n            for (var i in tree) {\n                var val = bindout(tree[i]);\n                a.push(val);\n\n                if (val instanceof QMLMetaElement)\n                    isList = true;\n                else if (val instanceof QMLBinding)\n                    hasBinding = true;\n            }\n\n            if (hasBinding) {\n                if (isList)\n                    throw new TypeError(\"An array may either contain bindings or Element definitions.\");\n                return new QMLBinding(src, tree);\n            }\n\n            return a;\n        }\n    };\n\n    function walk(tree) {\n        var type = tree[0];\n        var walker = walkers[type];\n        if (!walker) {\n            console.log(\"No walker for \" + type);\n            return;\n        } else {\n            return walker.apply(type, tree.slice(1));\n        }\n    }\n\n    return walk(tree);\n\n    // Try to bind out tree and return static variable instead of binding\n    function bindout(tree, binding) {\n        if (tree[0] === \"stat\") // We want to process the content of the statement\n            tree = tree[1];     // (but still handle the case, we get the content directly)\n        var type = tree[0];\n        var walker = walkers[type];\n        if (walker) {\n            return walker.apply(type, tree.slice(1));\n        } else {\n            return new QMLBinding(binding, tree);\n        }\n    }\n\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n    loadParser();\n    qmlweb_parse.nowParsingFile = file;\n    var parsetree = qmlweb_parse(src, qmlweb_parse.QmlDocument);\n    return convertToEngine(parsetree);\n}\n\nfunction loadParser() {\n  if (typeof qmlweb_parse !== 'undefined')\n    return;\n\n  console.log('Loading parser...');\n  var tags = document.getElementsByTagName('script');\n  for (let i in tags) {\n    if (tags[i].src && tags[i].src.indexOf('/qt.') !== -1) {\n      let src = tags[i].src.replace('/qt.', '/qmlweb.parser.');\n      // TODO: rewrite to async loading\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', src, false);\n      xhr.send(null);\n      if (xhr.status !== 200 && xhr.status !== 0) { // 0 if accessing with file://\n          throw new Error('Could not load QmlWeb parser!');\n      }\n      (new Function(xhr.responseText))();\n      return;\n    }\n  }\n}\n","// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\nvar evaluatingProperty;\nvar evaluatingPropertyStack = [];\nvar evaluatingPropertyPaused = false;\nvar evaluatingPropertyStackOfStacks = [];\n\nvar _executionContext = null;\n\n// All object constructors\nvar constructors = {\n  'int': QMLInteger,\n  real: Number,\n  'double': Number,\n  string: String,\n  'bool': Boolean,\n  list: QMLList,\n  color: QMLColor,\n  'enum': Number,\n  url: String,\n  variant: QMLVariant,\n  'var': QMLVariant\n};\n\nconst modules = {\n  Main: constructors\n};\n\nconst dependants = {};\n\n// Helper. Adds a type to the constructor list\nglobal.registerGlobalQmlType = function (name, type) {\n  global[type.name]  = type;\n  constructors[name] = type;\n  modules.Main[name] = type;\n};\n\n// Helper. Register a type to a module\nglobal.registerQmlType = function(options, constructor) {\n  if (constructor !== undefined) {\n    options.constructor = constructor;\n  }\n\n  if (typeof options.baseClass === 'string') {\n    // TODO: Does not support version specification (yet?)\n    var baseModule, baseName;\n    const dot = options.baseClass.lastIndexOf('.');\n    if (dot === -1) {\n      baseModule = options.module;\n      baseName = options.baseClass;\n    } else {\n      baseModule = options.baseClass.substring(0, dot);\n      baseName = options.baseClass.substring(dot + 1);\n    }\n    const found = (modules[baseModule] || [])\n                    .filter(descr => descr.name === baseName);\n    if (found.length > 0) {\n      // Ok, we found our base class\n      options.baseClass = found[0].constructor;\n    } else {\n      // Base class not found, delay the loading\n      const baseId = [baseModule, baseName].join('.');\n      if (!dependants.hasOwnProperty(baseId)) {\n        dependants[baseId] = [];\n      }\n      dependants[baseId].push(options);\n      return;\n    }\n  }\n\n  if (typeof options === 'function') {\n    options = {\n      module: options.module,\n      name: options.element,\n      versions: options.versions,\n      baseClass: options.baseClass,\n      enums: options.enums,\n      properties: options.properties,\n      constructor: options\n    }\n  };\n\n  options.constructor.$qmlTypeInfo = {\n    enums: options.enums,\n    defaultProperty: options.defaultProperty,\n    properties: options.properties\n  };\n\n  if (options.global) {\n    registerGlobalQmlType(options.name, options.constructor);\n  }\n\n    var moduleDescriptor = {\n      name:        options.name,\n      versions:    options.versions,\n      constructor: options.constructor\n    };\n\n    if (typeof modules[options.module] == 'undefined')\n      modules[options.module] = [];\n    modules[options.module].push(moduleDescriptor);\n\n\n    if (typeof options.baseClass !== 'undefined') {\n      inherit(options.constructor, options.baseClass);\n    }\n\n  const id = [options.module, options.name].join('.');\n  if (dependants.hasOwnProperty(id)) {\n    dependants[id].forEach(opt => global.registerQmlType(opt));\n    dependants[id].length = 0;\n  }\n};\n\nglobal.getConstructor = function (moduleName, version, name) {\n  if (typeof modules[moduleName] != 'undefined') {\n    for (var i = 0 ; i < modules[moduleName].length ; ++i) {\n      var type = modules[moduleName][i];\n\n      if (type.name == name && type.versions.test(version))\n        return type.constructor;\n    }\n  }\n  return null;\n};\n\nglobal.collectConstructorsForModule = function (moduleName, version) {\n  var constructors = {};\n\n  if (typeof modules[moduleName] == 'undefined') {\n    console.warn(\"module `\" + moduleName + \"` not found\");\n    return constructors;\n  }\n  for (var i = 0 ; i < modules[moduleName].length ; ++i) {\n    var module = modules[moduleName][i];\n\n    if (module.versions.test(version)) {\n      constructors[module.name] = module.constructor;\n    }\n  }\n  return constructors;\n};\n\nglobal.mergeObjects = function (obj1, obj2) {\n  var mergedObject = {};\n\n  if (typeof obj1 != 'undefined' && obj1 != null) {\n    for (var key in obj1) { mergedObject[key] = obj1[key]; }\n  }\n  if (typeof obj2 != 'undefined' && obj2 != null) {\n    for (var key in obj2) { mergedObject[key] = obj2[key]; }\n  }\n  return mergedObject;\n}\n\nvar importContextIds = 0;\nglobal.perImportContextConstructors = {};\n\nglobal.loadImports = function (self, imports) {\n  constructors = mergeObjects(modules.Main, null);\n  if (imports.filter(row => row[1] === 'QtQml').length === 0 &&\n      imports.filter(row => row[1] === 'QtQuick').length === 1) {\n    imports.push(['qmlimport', 'QtQml', 2, '', true]);\n  }\n  for (var i = 0 ; i < imports.length ; ++i) {\n    var moduleName = imports[i][1],\n        moduleVersion = imports[i][2],\n        moduleAlias = imports[i][3],\n        moduleConstructors = collectConstructorsForModule(moduleName, moduleVersion);\n\n    if (moduleAlias !== \"\")\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\n    else\n      constructors = mergeObjects(constructors, moduleConstructors);\n  }\n  self.importContextId = importContextIds++;\n  perImportContextConstructors[self.importContextId] = constructors;\n}\n\nglobal.inherit = function(constructor, baseClass) {\n  var oldProto = constructor.prototype;\n  constructor.prototype = Object.create(baseClass.prototype);\n  Object.getOwnPropertyNames(oldProto).forEach(prop => {\n    constructor.prototype[prop] = oldProto[prop];\n  });\n  constructor.prototype.constructor = baseClass;\n}\n\nfunction callSuper(self, meta) {\n  const info = meta.super.$qmlTypeInfo || {};\n  meta.super = meta.super.prototype.constructor;\n  meta.super.call(self, meta);\n\n  if (info.enums) {\n    // TODO: not exported to the whole file scope yet\n    Object.keys(info.enums).forEach(name => {\n      self[name] = info.enums[name];\n    });\n  }\n  if (info.properties) {\n    Object.keys(info.properties).forEach(name => {\n      let desc = info.properties[name];\n      if (typeof desc === 'string') {\n        desc = {type: desc};\n      }\n      createProperty(desc.type, self, name, desc);\n    });\n  }\n  if (info.defaultProperty) {\n    self.$defaultProperty = info.defaultProperty;\n  }\n}\n\n/**\n * QML Object constructor.\n * @param {Object} meta Meta information about the object and the creation context\n * @return {Object} New qml object\n */\nfunction construct(meta) {\n    var item,\n        component;\n\n    var constructors = perImportContextConstructors[meta.context.importContextId];\n\n    var classComponents = meta.object.$class.split(\".\")\n    for(var ci=0; ci<classComponents.length; ++ci) {\n        var c = classComponents[ci];\n        constructors = constructors[c]\n        if (constructors === undefined) {\n            break;\n        }\n    }\n\n    if (constructors !== undefined) {\n        var constructor = constructors;\n        meta.super = constructor;\n        item = new constructor(meta);\n        meta.super = undefined;\n    } else {\n        // Load component from file. Please look at import.js for main notes.\n        // Actually, we have to use that order:\n        // 1) try to load component from current basePath\n        // 2) from importPathList\n        // 3) from directories in imports statements and then\n        // 4) from qmldir files\n        // Currently we support only 1,2 and 4 and use order: 4,1,2\n        // TODO: engine.qmldirs is global for all loaded components. That's not qml's original behaviour.\n        var qdirInfo = engine.qmldirs[meta.object.$class]; // Are we have info on that component in some imported qmldir files?\n\n        var oldExecutionContext = _executionContext;\n        _executionContext = meta.context;\n\n        if (qdirInfo) {\n            // We have that component in some qmldir, load it from qmldir's url\n            component = Qt.createComponent( \"@\" + qdirInfo.url);\n        }\n        else {\n            var filePath;\n            if (classComponents.length === 2) {\n                filePath = engine.qualifiedImportPath(\n                    meta.context.importContextId, classComponents[0]) +\n                        classComponents[1];\n            } else {\n                filePath = classComponents[0];\n            }\n            component = Qt.createComponent(filePath + \".qml\");\n        }\n\n        _executionContext = oldExecutionContext;\n\n        if (component) {\n            var item = component.createObject(meta.parent);\n\n            if (typeof item.dom != 'undefined')\n                item.dom.className += \" \" + classComponents[classComponents.length-1] + (meta.object.id ? \" \" + meta.object.id : \"\");\n            var dProp; // Handle default properties\n        } else {\n            throw new Error(\"No constructor found for \" + meta.object.$class);\n        }\n    }\n\n    // id\n    if (meta.object.id)\n        setupGetterSetter(meta.context, meta.object.id, function() { return item; }, function() {});\n\n    // keep path in item for probale use it later in Qt.resolvedUrl\n    item.$context[\"$basePath\"] = engine.$basePath; //gut\n\n    // We want to use the item's scope, but this Component's imports\n    item.$context.importContextId = meta.context.importContextId;\n\n    // Apply properties (Bindings won't get evaluated, yet)\n    applyProperties(meta.object, item, item, item.$context);\n\n    return item;\n}\n\n/**\n * Create property getters and setters for object.\n * @param {Object} obj Object for which gsetters will be set\n * @param {String} propName Property name\n * @param {Object} [options] Options that allow finetuning of the property\n */\nfunction createProperty(type, obj, propName, options = {}) {\n    var prop = new QMLProperty(type, obj, propName);\n    var getter, setter;\n\n    obj[propName + \"Changed\"] = prop.changed;\n    obj.$properties[propName] = prop;\n    obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n    getter = function()       { return obj.$properties[propName].get(); };\n    if (!options.readOnly)\n      setter = function(newVal) { obj.$properties[propName].set(newVal, QMLProperty.ReasonUser); };\n    else {\n      setter = function(newVal) {\n        if (obj.$canEditReadOnlyProperties != true)\n          throw \"property '\" + propName + \"' has read only access\";\n        obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n      }\n    }\n    setupGetterSetter(obj, propName, getter, setter);\n    if (obj.$isComponentRoot)\n        setupGetterSetter(obj.$context, propName, getter, setter);\n}\n\n/**\n * Set up simple getter function for property\n */\n\nfunction setupGetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    get: func,\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction setupSetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    set: func,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n  Object.defineProperty(obj, propName, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\n    if (!item[signalName]) {\n        console.warn(\"No signal called \" + signalName + \" found!\");\n        return;\n    }\n    else if (typeof item[signalName].connect != 'function') {\n        console.warn(signalName + \" is not a signal!\");\n        return;\n    }\n    if (!value.eval) {\n        var params = \"\";\n        for (var j in item[signalName].parameters) {\n            params += j==0 ? \"\" : \", \";\n            params += item[signalName].parameters[j].name;\n        }\n        value.src = \"(function(\" + params + \") { _executionContext = __executionContext;\" + value.src + \"})\";\n        value.isFunction = false;\n        value.compile();\n    }\n    var slot = value.eval(objectScope, componentScope);\n    item[signalName].connect(item, slot);\n    return slot;\n}\n\n/**\n * Apply properties from metaObject to item.\n * @param {Object} metaObject Source of properties\n * @param {Object} item Target of property apply\n * @param {Object} objectScope Scope in which properties should be evaluated\n * @param {Object} componentScope Component scope in which properties should be evaluated\n */\nfunction applyProperties(metaObject, item, objectScope, componentScope) {\n    var i;\n    objectScope = objectScope || item;\n    _executionContext = componentScope;\n\n    if (metaObject.$children && metaObject.$children.length !== 0) {\n        if (item.$defaultProperty)\n            item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);\n        else\n            throw \"Cannot assign to unexistant default property\";\n    }\n    // We purposefully set the default property AFTER using it, in order to only have it applied for\n    // instanciations of this component, but not for its internal children\n    if (metaObject.$defaultProperty)\n        item.$defaultProperty = metaObject.$defaultProperty;\n\n    for (i in metaObject) {\n        var value = metaObject[i];\n        if (i == \"id\" || i == \"$class\") { // keep them\n          item[i] = value;\n          continue;\n        }\n\n        // skip global id's and internal values\n        if (i == \"id\" || i[0] == \"$\") {\n            continue;\n        }\n        // slots\n        if (i.indexOf(\"on\") == 0 && i[2].toUpperCase() == i[2]) {\n            var signalName =  i[2].toLowerCase() + i.slice(3);\n            if (!connectSignal(item, signalName, value, objectScope, componentScope)) {\n                if (item.$setCustomSlot) {\n                    item.$setCustomSlot(signalName, value, objectScope, componentScope);\n                }\n            }\n            continue;\n        }\n\n        if (value instanceof Object) {\n            if (value instanceof QMLSignalDefinition) {\n                item[i] = Signal(value.parameters);\n                if (item.$isComponentRoot)\n                    componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLMethod) {\n                value.compile();\n                item[i] = value.eval(objectScope, componentScope);\n                if (item.$isComponentRoot)\n                    componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLAliasDefinition) {\n                // TODO: 1. Alias must be able to point to prop or id of local object,eg: property alias q: t\n                //       2. Alias may have same name as id it points to: property alias someid: someid\n                //       3. Alias proxy (or property proxy) to proxy prop access to selected incapsulated object. (think twice).\n                createProperty(\"alias\", item, i);\n                item.$properties[i].componentScope = componentScope;\n                item.$properties[i].val = value;\n                item.$properties[i].get = function() {\n                    var obj = this.componentScope[this.val.objectName];\n                    return this.val.propertyName ? obj.$properties[this.val.propertyName].get() : obj;\n                }\n                item.$properties[i].set = function(newVal, reason, objectScope, componentScope) {\n                    if (!this.val.propertyName)\n                        throw \"Cannot set alias property pointing to an QML object.\";\n                    this.componentScope[this.val.objectName].$properties[this.val.propertyName].set(newVal, reason, objectScope, componentScope);\n                }\n\n                if (value.propertyName) {\n                  var con = function(prop) {\n                    var obj = prop.componentScope[prop.val.objectName];\n                    if (!obj) {\n                      console.error(\"qtcore: target object \",prop.val.objectName,\" not found for alias \",prop );\n                    } else {\n                      var targetProp = obj.$properties[prop.val.propertyName];\n                      if (!targetProp) {\n                        console.error(\"qtcore: target property [\",prop.val.objectName,\"].\",prop.val.propertyName,\" not found for alias \",prop.name );\n                      } else {\n                        // targetProp.changed.connect( prop.changed );\n                        // it is not sufficient to connect to `changed` of source property\n                        // we have to propagate own changed to it too\n                        // seems the best way to do this is to make them identical?..\n                        // prop.changed = targetProp.changed;\n                        // obj[i + \"Changed\"] = prop.changed;\n                        // no. because those object might be destroyed later.\n                        ( function() {\n                          var loopWatchdog = false;\n                          targetProp.changed.connect( item, function() {\n                              if (loopWatchdog) return; loopWatchdog = true;\n                              prop.changed.apply( item,arguments );\n                              loopWatchdog = false;\n                          } );\n                          prop.changed.connect( obj, function() {\n                              if (loopWatchdog) return; loopWatchdog = true;\n                              targetProp.changed.apply( obj, arguments );\n                              loopWatchdog = false;\n                          } );\n                        } ) ();\n                      }\n                    }\n                  }\n                  engine.pendingOperations.push( [con,item.$properties[i]] );\n                }\n\n                continue;\n            } else if (value instanceof QMLPropertyDefinition) {\n                createProperty(value.type, item, i);\n                item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);\n                continue;\n            } else if (item[i] && value instanceof QMLMetaPropertyGroup) {\n                // Apply properties one by one, otherwise apply at once\n                applyProperties(value, item[i], objectScope, componentScope);\n                continue;\n            }\n        }\n        if (item.$properties && i in item.$properties)\n            item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);\n        else if (i in item)\n            item[i] = value;\n        else if (item.$setCustomData)\n            item.$setCustomData(i, value);\n        else\n            console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\n    }\n}\n\n// ItemModel. EXPORTED.\nJSItemModel = function() {\n    this.roleNames = [];\n\n    this.setRoleNames = function(names) {\n        this.roleNames = names;\n    }\n\n    this.dataChanged = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.rowsInserted = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.rowsMoved = Signal([\n        {type:\"int\", name:\"sourceStartIndex\"},\n        {type:\"int\", name:\"sourceEndIndex\"},\n        {type:\"int\", name:\"destinationIndex\"}\n    ]);\n    this.rowsRemoved = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.modelReset = Signal();\n}\n\n// -----------------------------------------------------------------------------\n// Stuff below defines QML things\n// -----------------------------------------------------------------------------\n\n","// TODO\nfunction QMLColor(val) {\n  if (typeof val === \"number\") {\n    // we assume it is int value and must be converted to css hex with padding\n    // http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript\n    val = \"#\" + (Math.round(val) + 0x1000000).toString(16).substr(-6).toUpperCase();\n  } else {\n    if(typeof val === \"array\" && val.length >= 3) {\n      // array like [r,g,b] where r,g,b are in 0..1 range\n      var m = 255;\n      val = \"rgb(\" + Math.round(m * val[0]) + \",\" + Math.round(m * val[1]) + \",\" + Math.round(m * val[2]) + \")\";\n    }\n  }\n  return val;\n};\n","function QMLInteger(val) {\n    return (val|0);\n}\n","function QMLList(meta) {\n    var list = [];\n    if (meta.object instanceof Array)\n        for (var i in meta.object)\n            list.push(construct({object: meta.object[i], parent: meta.parent, context: meta.context }));\n    else if (meta.object instanceof QMLMetaElement)\n        list.push(construct({object: meta.object, parent: meta.parent, context: meta.context }));\n\n    return list;\n}\n","class QMLProperty {\n  constructor(type, obj, name) {\n    this.obj = obj;\n    this.name = name;\n    this.changed = Signal([], {obj:obj});\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n    this.needsUpdate = true;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this object.\n    this.$tidyupList = [];\n  }\n}\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\nfunction pushEvalStack() {\n  evaluatingPropertyStackOfStacks.push( evaluatingPropertyStack );\n  evaluatingPropertyStack = [];\n  evaluatingProperty = undefined;\n//  console.log(\"evaluatingProperty=>undefined due to push stck \");\n}\n\nfunction popEvalStack() {\n  evaluatingPropertyStack = evaluatingPropertyStackOfStacks.pop() || [];\n  evaluatingProperty = evaluatingPropertyStack[ evaluatingPropertyStack.length-1 ];\n}\n\nfunction pushEvaluatingProperty( prop ) {\n    // TODO say warnings if already on stack. This means binding loop. BTW actually we do not loop because needsUpdate flag is reset before entering update again.\n    if (evaluatingPropertyStack.indexOf( prop ) >= 0) {\n      console.error(\"Property binding loop detected for property \",prop.name, [prop].slice(0));\n    }\n    evaluatingProperty = prop;\n    evaluatingPropertyStack.push( prop ); //keep stack of props\n}\n\nfunction popEvaluatingProperty() {\n\n    evaluatingPropertyStack.pop();\n    evaluatingProperty = evaluatingPropertyStack[ evaluatingPropertyStack.length-1 ];\n}\n\n// Updater recalculates the value of a property if one of the\n// dependencies changed\nQMLProperty.prototype.update = function() {\n    this.needsUpdate = false;\n\n    if (!this.binding)\n        return;\n\n    var oldVal = this.val;\n\n    try {\n      pushEvaluatingProperty(this);\n      if (!this.binding.eval)\n        this.binding.compile();\n      this.val = this.binding.eval(this.objectScope, this.componentScope);\n    } catch (e) {\n      console.log(\"QMLProperty.update binding error:\", e, Function.prototype.toString.call(this.binding.eval))\n    } finally {\n      popEvaluatingProperty();\n    }\n\n    if (this.animation) {\n        this.animation.$actions = [{\n            target: this.animation.target || this.obj,\n            property: this.animation.property || this.name,\n            from: this.animation.from || oldVal,\n            to: this.animation.to || this.val\n        }];\n        this.animation.restart();\n    }\n\n    if (this.val !== oldVal)\n        this.changed(this.val, oldVal, this.name);\n}\n\n// Define getter\nQMLProperty.prototype.get = function() {\n    //if (this.needsUpdate && !evaluatingPropertyPaused) {\n    if (this.needsUpdate && engine.operationState !== QMLOperationState.Init) {\n      this.update();\n    }\n\n    // If this call to the getter is due to a property that is dependant on this\n    // one, we need it to take track of changes\n    if (evaluatingProperty && !this.changed.isConnected(evaluatingProperty, QMLProperty.prototype.update)) {\n        // console.log( this,evaluatingPropertyStack.slice(0),this.val );\n        this.changed.connect(evaluatingProperty, QMLProperty.prototype.update);\n    }\n\n    return this.val;\n}\n\nconst typeInitialValues = {\n  int: 0,\n  real: 0,\n  double: 0,\n  string: '',\n  bool: false,\n  list: [],\n  url: ''\n};\n\n// Define setter\nQMLProperty.prototype.set = function(newVal, reason, objectScope, componentScope) {\n    var i,\n        oldVal = this.val;\n\n    if (newVal instanceof QMLBinding) {\n        if (!objectScope || !componentScope)\n            throw \"Internal error: binding assigned without scope\";\n        this.binding = newVal;\n        this.objectScope = objectScope;\n        this.componentScope = componentScope;\n\n        if (engine.operationState !== QMLOperationState.Init) {\n            if (!newVal.eval)\n                newVal.compile();\n            try {\n              pushEvaluatingProperty(this);\n\n              this.needsUpdate = false;\n              newVal = this.binding.eval(objectScope, componentScope);\n            } finally {\n              popEvaluatingProperty();\n            }\n        } else {\n            engine.bindedProperties.push(this);\n            return;\n        }\n    } else {\n        if (reason != QMLProperty.ReasonAnimation)\n            this.binding = null;\n        if (newVal instanceof Array)\n            newVal = newVal.slice(); // Copies the array\n    }\n\n    if (reason === QMLProperty.ReasonInit && typeof newVal === 'undefined') {\n      if (typeInitialValues.hasOwnProperty(this.type)) {\n        newVal = typeInitialValues[this.type];\n      }\n    }\n\n    if (constructors[this.type] == QMLList) {\n        this.val = QMLList({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof QMLMetaElement) {\n        const QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        if (constructors[newVal.$class] == QMLComponent || constructors[this.type] == QMLComponent)\n            this.val = new QMLComponent({ object: newVal, parent: this.obj, context: componentScope });\n        else\n            this.val = construct({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof Object || !newVal) {\n        this.val = newVal;\n    } else {\n        this.val = constructors[this.type](newVal);\n    }\n\n    if (this.val !== oldVal) {\n        if (this.animation && reason == QMLProperty.ReasonUser) {\n            this.animation.running = false;\n            this.animation.$actions = [{\n                target: this.animation.target || this.obj,\n                property: this.animation.property || this.name,\n                from: this.animation.from || oldVal,\n                to: this.animation.to || this.val\n            }];\n            this.animation.running = true;\n        }\n        if (this.obj.$syncPropertyToRemote instanceof Function && reason == QMLProperty.ReasonUser) { // is a remote object from e.g. a QWebChannel\n            this.obj.$syncPropertyToRemote(this.name, newVal);\n        } else {\n            this.changed(this.val, oldVal, this.name);\n        }\n    }\n}\n","function QMLVariant(val) {\n    return val;\n}\n","// Base object for all qml thingies\nvar objectIds = 0;\nfunction QObject(parent) {\n    this.$parent = parent;\n    if (parent && parent.$tidyupList)\n        parent.$tidyupList.push(this);\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n\n    this.objectId = objectIds++;\n    this.$delete = function() {\n        if (this.$Component)\n          this.$Component.destruction();\n\n        while (this.$tidyupList.length > 0) {\n            var item = this.$tidyupList[0];\n            if (item.$delete) // It's a QObject\n                item.$delete();\n            else // It must be a signal\n                item.disconnect(this);\n        }\n\n        for (var i in this.$properties) {\n            var prop = this.$properties[i];\n            while (prop.$tidyupList.length > 0)\n                prop.$tidyupList[0].disconnect(prop);\n        }\n\n        if (this.$parent && this.$parent.$tidyupList)\n            this.$parent.$tidyupList.splice(this.$parent.$tidyupList.indexOf(this), 1);\n\n        // must do this:\n        // 1) parent will be notified and erase object from it's children.\n        // 2) DOM node will be removed.\n        this.parent = undefined;\n    }\n\n    // must have `destroy` method\n    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n    this.destroy = this.$delete;\n}\n","function updateHGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingHGeometry)\n        return;\n    this.$updatingHGeometry = true;\n\n    var t, w, width, x, left, hC, right,\n        lM = anchors.leftMargin || anchors.margins,\n        rM = anchors.rightMargin || anchors.margins;\n\n    // Width\n    if (this.$isUsingImplicitWidth && propName == \"implicitWidth\")\n        width = this.implicitWidth;\n    else if (propName == \"width\")\n        this.$isUsingImplicitWidth = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.left.changed.isConnected(this, updateHGeometry))\n            t.$properties.left.changed.connect(this, updateHGeometry);\n        if (!t.$properties.right.changed.isConnected(this, updateHGeometry))\n            t.$properties.right.changed.connect(this, updateHGeometry);\n        if (!t.$properties.width.changed.isConnected(this, updateHGeometry))\n            t.$properties.width.changed.connect(this, updateHGeometry);\n\n        this.$isUsingImplicitWidth = false;\n        width = t.width - lM - rM;\n        x = t.left - (this.parent ? this.parent.left : 0) + lM;\n        left = t.left + lM;\n        right = t.right - rM;\n        hC = (left + right) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.horizontalCenter.changed.isConnected(this, updateHGeometry))\n            t.$properties.horizontalCenter.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        hC = t.horizontalCenter;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else if ((t = anchors.left) !== undefined) {\n        left = t + lM\n        if ((u = anchors.right) !== undefined) {\n            right = u - rM;\n            this.$isUsingImplicitWidth = false;\n            width = right - left;\n            x = left - (this.parent ? this.parent.left : 0);\n            hC = (right + left) / 2;\n        } else if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (hC - left) * 2;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = 2 * hC - left;\n        } else {\n            w = width || this.width;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = left + w;\n            hC = left + w / 2;\n        }\n    } else if ((t = anchors.right) !== undefined) {\n        right = t - rM;\n        if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (right - hC) * 2;\n            x = 2 * hC - right - (this.parent ? this.parent.left : 0);\n            left = 2 * hC - right;\n        } else {\n            w = width || this.width;\n            x = right - w - (this.parent ? this.parent.left : 0);\n            left = right - w;\n            hC = right - w / 2;\n        }\n    } else if ((hC = anchors.horizontalCenter) !== undefined) {\n        w = width || this.width;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.left.changed.isConnected(this, updateHGeometry))\n            this.parent.$properties.left.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        left = this.x + (this.parent ? this.parent.left : 0);\n        right = left + w;\n        hC = left + w / 2;\n    }\n\n    if (left !== undefined)\n        this.left = left;\n    if (hC !== undefined)\n        this.horizontalCenter = hC;\n    if (right !== undefined)\n        this.right = right;\n    if (x !== undefined)\n        this.x = x;\n    if (width !== undefined)\n        this.width = width;\n\n    this.$updatingHGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateVGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingVGeometry)\n        return;\n    this.$updatingVGeometry = true;\n\n    var t, w, height, y, top, vC, bottom,\n        tM = anchors.topMargin || anchors.margins,\n        bM = anchors.bottomMargin || anchors.margins;\n\n    // Height\n    if (this.$isUsingImplicitHeight && propName == \"implicitHeight\")\n        height = this.implicitHeight;\n    else if (propName == \"height\")\n        this.$isUsingImplicitHeight = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.top.changed.isConnected(this, updateVGeometry))\n            t.$properties.top.changed.connect(this, updateVGeometry);\n        if (!t.$properties.bottom.changed.isConnected(this, updateVGeometry))\n            t.$properties.bottom.changed.connect(this, updateVGeometry);\n        if (!t.$properties.height.changed.isConnected(this, updateVGeometry))\n            t.$properties.height.changed.connect(this, updateVGeometry);\n\n        this.$isUsingImplicitHeight = false;\n        height = t.height - tM - bM;\n        y = t.top - (this.parent ? this.parent.top : 0) + tM;\n        top = t.top + tM;\n        bottom = t.bottom - bM;\n        vC = (top + bottom) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.verticalCenter.changed.isConnected(this, updateVGeometry))\n            t.$properties.verticalCenter.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        vC = t.verticalCenter;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else if ((t = anchors.top) !== undefined) {\n        top = t + tM\n        if ((u = anchors.bottom) !== undefined) {\n            bottom = u - bM;\n            this.$isUsingImplicitHeight = false;\n            height = bottom - top;\n            y = top - (this.parent ? this.parent.top : 0);\n            vC = (bottom + top) / 2;\n        } else if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (vC - top) * 2;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = 2 * vC - top;\n        } else {\n            w = height || this.height;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = top + w;\n            vC = top + w / 2;\n        }\n    } else if ((t = anchors.bottom) !== undefined) {\n        bottom = t - bM;\n        if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (bottom - vC) * 2;\n            y = 2 * vC - bottom - (this.parent ? this.parent.top : 0);\n            top = 2 * vC - bottom;\n        } else {\n            w = height || this.height;\n            y = bottom - w - (this.parent ? this.parent.top : 0);\n            top = bottom - w;\n            vC = bottom - w / 2;\n        }\n    } else if ((vC = anchors.verticalCenter) !== undefined) {\n        w = height || this.height;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.top.changed.isConnected(this, updateVGeometry))\n            this.parent.$properties.top.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        top = this.y + (this.parent ? this.parent.top : 0);\n        bottom = top + w;\n        vC = top + w / 2;\n    }\n\n    if (top !== undefined)\n        this.top = top;\n    if (vC !== undefined)\n        this.verticalCenter = vC;\n    if (bottom !== undefined)\n        this.bottom = bottom;\n    if (y !== undefined)\n        this.y = y;\n    if (height !== undefined)\n        this.height = height;\n\n    this.$updatingVGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateChildrenRect(component) {\n    var children = component !== undefined ? component.children : undefined\n    if ( children == undefined || children.length == 0 )\n        return;\n\n    var maxWidth = 0;\n    var maxHeight = 0;\n    var minX = children.length>0 ? children[0].x : 0;\n    var minY = children.length>0 ? children[0].y : 0;\n    var child;\n\n    for (var i=0;i<children.length; i++){\n        child = children[i];\n        maxWidth = Math.max(maxWidth, child.x + child.width);\n        maxHeight = Math.max(maxHeight, child.y + child.heighth);\n        minX = Math.min(minX, child.x);\n        minY = Math.min(minX, child.y);\n    }\n\n    component.childrenRect.x = minX;\n    component.childrenRect.y = minY;\n    component.childrenRect.width = maxWidth;\n    component.childrenRect.height = maxHeight;\n}\n\n","function QMLDomElement(meta) {\n    callSuper(this, meta);\n    var tagName = meta.object.tagName || 'div';\n    this.dom = document.createElement(tagName);\n\n    createProperty('string', this, 'tagName');\n\n    // TODO: support properties, styles, perhaps changing the tagName\n}\n\nregisterQmlType({\n    module: 'QmlWeb.Dom',\n    name: 'DomElement',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLDomElement\n});\n","function QMLContext() {\n    this.nameForObject = function(obj) {\n        for (var name in this) {\n            if (this[name] == obj)\n                return name;\n        }\n    }\n}\n\nQMLComponent.getAttachedObject = function() { // static\n    if (!this.$Component) {\n        this.$Component = new QObject(this);\n        this.$Component.completed = Signal([]);\n        engine.completedSignals.push(this.$Component.completed);\n\n        this.$Component.destruction = Signal([]);\n    }\n    return this.$Component;\n}\n\nQMLComponent.prototype.createObject = function(parent, properties) {\n    var oldState = engine.operationState;\n    engine.operationState = QMLOperationState.Init;\n    // change base path to current component base path\n    var bp = engine.$basePath; engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n    var context = this.$context ? Object.create(this.$context) : new QMLContext();\n\n    if (this.importContextId !== undefined) {\n        context.importContextId = this.importContextId;\n    }\n\n    var item = construct({\n        object: this.$metaObject,\n        parent: parent,\n        context: context,\n        isComponentRoot: true\n    });\n\n    // change base path back\n    //TODO looks a bit hacky\n    engine.$basePath = bp;\n\n    engine.operationState = oldState;\n    return item;\n}\n\nfunction QMLComponent(meta) {\n    if (constructors[meta.object.$class] == QMLComponent)\n        this.$metaObject = meta.object.$children[0];\n    else\n        this.$metaObject = meta.object;\n    this.$context = meta.context;\n\n    var jsImports = [];\n\n    this.finalizeImports = (function($context) {\n      for (var i = 0 ; i < jsImports.length ; ++i) {\n        var importDesc = jsImports[i];\n        var src = importDesc[1];\n        var js;\n\n        if (typeof engine.$basePath != 'undefined')\n          src = engine.$basePath + src;\n        if (typeof qrc[src] != 'undefined')\n          js = qrc[src];\n        else {\n          loadParser();\n          js = qmlweb_jsparse(getUrlContents(src));\n        }\n        if (importDesc[3] !== \"\") {\n          $context[importDesc[3]] = {};\n          importJavascriptInContext(js, $context[importDesc[3]]);\n        }\n        else\n          importJavascriptInContext(js, $context);\n      }\n    }).bind(this);\n\n    if (meta.object.$imports instanceof Array)\n    {\n      var moduleImports = [];\n      var loadImport    = (function(importDesc) {\n        if (/\\.js$/.test(importDesc[1]))\n          jsImports.push(importDesc);\n        else\n          moduleImports.push(importDesc);\n      }).bind(this);\n\n      for (var i = 0 ; i < meta.object.$imports.length ; ++i) {\n        loadImport(meta.object.$imports[i]);\n      }\n      loadImports(this, moduleImports);\n      if (typeof this.$context != 'undefined' && this.$context != null)\n        this.finalizeImports(this.$context);\n    }\n}\n\nregisterQmlType({\n  global: true,\n  module: 'QtQml',\n  name: 'Component',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: QMLComponent\n});\n","// Base object for all qml elements\nfunction QMLBaseObject(meta) {\n    QObject.call(this, meta.parent);\n    var i,\n        prop;\n\n    this.$isComponentRoot = meta.isComponentRoot;\n    this.$context = meta.context;\n\n    // Component get own properties\n    var attributes = [];\n    for (var key in meta.object) {\n      if (meta.object.hasOwnProperty(key) &&\n          typeof meta.object[key] != 'undefined' && meta.object[key] != null &&\n          (meta.object[key].__proto__.constructor.name == 'QMLPropertyDefinition' ||\n           meta.object[key].__proto__.constructor.name == 'QMLAliasDefinition')) {\n        attributes.push(key);\n      }\n    }\n\n    this.Keys = new QObject(this);\n    this.Keys.asteriskPresed = Signal();\n    this.Keys.backPressed = Signal();\n    this.Keys.backtabPressed = Signal();\n    this.Keys.callPressed = Signal();\n    this.Keys.cancelPressed = Signal();\n    this.Keys.deletePressed = Signal();\n    for (var i = 0 ; i < 10 ; ++i)\n      this.Keys['digit'+i+'Pressed'] = Signal();\n    this.Keys.escapePressed = Signal();\n    this.Keys.flipPressed = Signal();\n    this.Keys.hangupPressed = Signal();\n    this.Keys.leftPressed = Signal();\n    this.Keys.menuPressed = Signal();\n    this.Keys.noPressed = Signal();\n    this.Keys.pressed = Signal();\n    this.Keys.released = Signal();\n    this.Keys.returnPressed = Signal();\n    this.Keys.rightPressed = Signal();\n    this.Keys.selectPressed = Signal();\n    this.Keys.spacePressed = Signal();\n    this.Keys.tabPressed = Signal();\n    this.Keys.upPressed = Signal();\n    this.Keys.volumeDownPressed = Signal();\n    this.Keys.volumeUpPressed = Signal();\n    this.Keys.yesPressed = Signal();\n\n    this.getAttributes = function() { return (attributes); }\n}\n\nregisterQmlType({\n    module: 'QtQml',\n    name: 'QtObject',\n    versions: /.*/,\n    constructor: QMLBaseObject\n});\n","function QMLButton(meta) {\n    callSuper(this, meta);\n\n    const button = this.impl = document.createElement('button');\n    button.style.pointerEvents = 'auto';\n    this.dom.appendChild(button);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n    this.clicked = Signal();\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.textChanged.connect(this, function(newVal) {\n        button.textContent = newVal;\n        //TODO: Replace those statically sized borders\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.enabledChanged.connect(this, function(newVal) {\n        button.disabled = !newVal;\n    });\n\n    button.onclick = () => {\n        this.clicked();\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick.Controls',\n  name: 'Button',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: QMLButton\n});\n","registerQmlType({\n    module: 'QtQuick.Controls',\n    name: 'ComboBox',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLComboBox\n});\n\nfunction QMLComboBox(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    createProperty(\"int\", this, \"count\");\n    createProperty(\"int\", this, \"currentIndex\");\n    createProperty(\"string\", this, \"currentText\");\n    createProperty(\"array\", this, \"menu\");\n    createProperty(\"array\", this, \"model\");\n    createProperty(\"bool\", this, \"pressed\");\n\n    this.count = 0;\n    this.currentIndex = 0;\n    this.currentText = \"\";\n    this.menu = [];\n    this.model = [];\n    this.pressed = false;\n\n    var updateCB = function(){\n        var head = \"<select>\";\n        var tail = \"</select>\";\n        var html = head;\n\n        var model = self.model;\n        var count = model.length;\n        self.count = count;\n\n        for (var i = 0; i < count; i++) {\n            var elt = model[i];\n            //if (elt instanceof Array) { // TODO - optgroups? update model !\n            //    var count_i = elt.length;\n            //    for (var j = 0; j < count_i; j++)\n            //        html += \"<option>\" + elt[j] + \"</option>\";\n            //}\n            //else\n            html += \"<option>\" + elt + \"</option>\";\n        }\n        html += tail;\n        return html;\n    };\n\n    this.accepted = Signal();\n    this.activated = Signal([{type: \"int\", name: \"index\"}]);\n\n    this.find = function(text) {\n        return self.model.indexOf(text)\n    };\n    this.selectAll = function () {};    // TODO\n    this.textAt = function(index) {\n        return this.model[index];\n    };\n\n    this.Component.completed.connect(this, function () {\n        this.dom.innerHTML = updateCB();\n        var child = this.dom.firstChild;\n        this.implicitWidth = child.offsetWidth;\n        this.implicitHeight = child.offsetHeight;\n    });\n\n    this.modelChanged.connect(updateCB);\n\n    this.dom.onclick = function (e) {\n        var index = self.dom.firstChild.selectedIndex;\n        self.currentIndex = index ;\n        self.currentText = self.model[index];\n        self.accepted();\n        self.activated(index);\n    };\n}\n","function QMLScrollView(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    createProperty(\"Item\", this, \"contentItem\");\n    this.$defaultProperty = \"contentItem\";\n    createProperty(\"Item\", this, \"flickableItem\"); //TODO  0) implement it  1) make it read-only\n    createProperty(\"Item\", this, \"viewport\"); //TODO\n    createProperty(\"bool\", this, \"frameVisible\");\n    createProperty(\"bool\", this, \"highlightOnFocus\"); //TODO test\n    createProperty(\"enum\", this, \"verticalScrollBarPolicy\");\n    createProperty(\"enum\", this, \"horizontalScrollBarPolicy\");\n    createProperty(\"Component\", this, \"style\"); //TODO\n\n    this.contentItemChanged.connect(this, function(newItem){\n        if (typeof newItem !== undefined) {\n            newItem.parent = self;\n        }\n    });\n    this.flickableItemChanged.connect(this, function(newItem) {\n    });\n    this.viewportChanged.connect(this, function(newViewport) {\n    });\n    this.frameVisibleChanged.connect(this, function(visible) {\n        this.css.border= visible ? \"1px solid gray\" : \"hidden\";\n    });\n    this.highlightOnFocusChanged.connect(this, function(highlight) {\n    });\n\n    this.horizontalScrollBarPolicyChanged.connect(this, function(newPolicy) {\n        this.css.overflowX = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n    this.verticalScrollBarPolicyChanged.connect(this, function(newPolicy) {\n        this.css.overflowY = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n\n    this.styleChanged.connect(this, function(newStyle){});\n\n    ////\n    this.childrenChanged.connect(this, function(){\n       if (typeof self.contentItem == undefined && self.children.length == 1) {\n           self.contentItem = self.children[0];\n       }\n    });\n    this.focusChanged.connect(this, function(focus){\n        this.css.outline = self.highlight && focus ? \"outline: lightblue solid 2px;\" : \"\";\n    });\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n}\n\nQMLScrollView.prototype.scrollBarPolicyToCssOverflow = function(policy) {\n    switch (policy) {\n        case Qt.ScrollBarAsNeeded:\n            return 'auto';\n        case Qt.ScrollBarAlwaysOff:\n            return 'hidden';\n        case Qt.ScrollBarAlwaysOn:\n            return 'scroll';\n    }\n    return 'auto';\n};\n\nregisterQmlType({\n  module:   'QtQuick.Controls',\n  name:     'ScrollView',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: QMLScrollView\n});\n","function QMLTextArea(meta) {\n  callSuper(this, meta);\n  const textarea = this.impl;\n  textarea.style.padding = '5px';\n  textarea.style.borderWidth = '1px';\n  textarea.style.backgroundColor = '#fff';\n}\n\nregisterQmlType({\n  module: 'QtQuick.Controls',\n  name: 'TextArea',\n  versions: /.*/,\n  baseClass: 'QtQuick.TextEdit',\n  constructor: QMLTextArea\n});\n","/**\n *\n * TextField is used to accept a line of text input.\n * Input constraints can be placed on a TextField item\n * (for example, through a validator or inputMask).\n * Setting echoMode to an appropriate value enables TextField\n * to be used for a password input field.\n *\n * Valid entries for echoMode and alignment are defined in TextInput.\n *\n */\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'TextField',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLTextInput\n});\n\nfunction QMLTextInput(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    const QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    const input = this.impl = document.createElement('input');\n    input.type = 'text';\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n\n    this.setupFocusOnDom(input);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"int\", this, \"maximumLength\");\n    createProperty(\"bool\", this, \"readOnly\");\n    createProperty(\"var\", this, \"validator\");\n    createProperty(\"enum\", this, \"echoMode\");\n    this.accepted = Signal();\n    this.readOnly = false;\n    this.maximumLength = -1;\n    input.disabled = false;\n\n    this.Component.completed.connect(this, function () {\n        this.implicitWidth = input.offsetWidth;\n        this.implicitHeight = input.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function (newVal) {\n        input.value = newVal;\n    });\n\n    this.echoModeChanged.connect(this, (function (newVal) {\n        switch (newVal) {\n        case TextField.Normal:\n            input.type = \"text\";\n            break;\n        case TextField.Password:\n            input.type = \"password\";\n            break;\n        }\n    }).bind(this));\n\n    this.maximumLengthChanged.connect(this, function (newVal) {\n        if (newVal < 0)\n            newVal = null;\n        input.maxLength = newVal;\n    });\n\n    this.readOnlyChanged.connect(this, function (newVal) {\n        input.disabled = newVal;\n    });\n\n    this.Keys.pressed.connect(this, (function (e) {\n        if ((e.key === Qt.Key_Return || e.key === Qt.Key_Enter) &&\n            testValidator()) {\n            self.accepted();\n            e.accepted = true;\n        }\n    }).bind(this));\n\n    function testValidator() {\n        if (typeof self.validator !== 'undefined' && self.validator !== null)\n            return self.validator.validate(self.text);\n        return true;\n    }\n\n    function updateValue(e) {\n        if (self.text !== self.dom.firstChild.value) {\n            self.$canEditReadOnlyProperties = true;\n            self.text = self.dom.firstChild.value;\n            self.$canEditReadOnlyProperties = false;\n        }\n    }\n\n    input.oninput = updateValue;\n    input.onpropertychanged = updateValue;\n}\n","registerQmlType({\n    module: 'QtQuick.Window',\n    name: 'Screen',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLScreen\n});\n\nfunction QMLScreen(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    // TODO: rewrite as an attached object and forbid constructing\n\n    createProperty(\"int\", this, \"desktopAvailableHeight\");\n    createProperty(\"int\", this, \"desktopAvailableWidth\");\n    createProperty(\"real\", this, \"devicePixelRatio\");\n    createProperty(\"int\", this, \"height\");\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"enum\", this, \"orientation\");\n    createProperty(\"enum\", this, \"orientationUpdateMask\");\n    createProperty(\"real\", this, \"pixelDensity\");\n    createProperty(\"enum\", this, \"primaryOrientation\");\n    createProperty(\"int\", this, \"width\");\n\n    this.Component.completed.connect(this, updateSC);\n\n    function updateSC() {\n        self.desktopAvailableHeight = window.outerHeight;\n        self.desktopAvailableWidth = window.outerWidth;\n        self.devicePixelRatio = window.devicePixelRatio;\n        self.height = window.innerHeight;\n        self.name = this.name;\n        self.orientation =  Qt.PrimaryOrientation;\n        self.orientationUpdateMask = 0;\n        self.pixelDensity = 100.0;  // TODO\n        self.primaryOrientation =  Qt.PrimaryOrientation;\n        self.width = window.innerWidth;\n    }\n}\n","function QMLColumn(meta) {\n    callSuper(this, meta);\n}\n\nQMLColumn.prototype.layoutChildren = function() {\n    var curPos = 0,\n        maxWidth = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n        maxWidth = child.width > maxWidth ? child.width : maxWidth;\n\n        child.y = curPos;\n        curPos += child.height + this.spacing;\n    }\n    this.implicitWidth = maxWidth;\n    this.implicitHeight = curPos - this.spacing; // We want no spacing at the bottom side\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Column',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLColumn\n});\n","function QMLFlow(meta) {\n    callSuper(this, meta);\n\n    this.Flow = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    }\n\n    createProperty(\"enum\", this, \"flow\", {initialValue: this.Flow.LeftToRight});\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLFlow.prototype.layoutChildren = function() {\n    var curHPos = 0,\n        curVPos = 0,\n        rowSize = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n\n        if (this.flow == this.Flow.LeftToRight) {\n            if (curHPos + child.width > this.width) {\n                curHPos = 0;\n                curVPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.height > rowSize ? child.height : rowSize;\n\n            child.x = this.layoutDirection == 1\n                    ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curHPos += child.width + this.spacing;\n        } else {\n            if (curVPos + child.height > this.height) {\n                curVPos = 0;\n                curHPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.width > rowSize ? child.width : rowSize;\n\n            child.x = this.layoutDirection == 1\n                    ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curVPos += child.height + this.spacing;\n        }\n    }\n    if (this.flow == 0)\n        this.implicitHeight = curVPos + rowSize;\n    else\n        this.implicitWidth = curHPos + rowSize;\n}\n\nregisterQmlType({\n  module:      'QtQuick',\n  name:        'Flow',\n  versions:    /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLFlow\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name: 'Grid',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLGrid\n});\n\nfunction QMLGrid(meta) {\n    callSuper(this, meta);\n\n    this.Grid = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    }\n\n    createProperty(\"int\", this, \"columns\");\n    createProperty(\"int\", this, \"rows\");\n    createProperty(\"enum\", this, \"flow\", {initialValue: 0});\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLGrid.prototype.layoutChildren = function() {\n    var visibleItems = [],\n        r = 0, c = 0,\n        colWidth = [],\n        rowHeight = [],\n        gridWidth = -this.spacing,\n        gridHeight = -this.spacing,\n        curHPos = 0,\n        curVPos = 0;\n\n    // How many items are actually visible?\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (child.visible && child.width && child.height)\n            visibleItems.push(this.children[i]);\n    }\n\n    // How many rows and columns do we need?\n    if (!this.columns && !this.rows) {\n        c = 4;\n        r = Math.ceil(visibleItems.length / 4);\n    } else if (!this.columns) {\n        r = this.rows;\n        c = Math.ceil(visibleItems.length / r);\n    } else {\n        c = this.columns;\n        r = Math.ceil(visibleItems.length / c);\n    }\n\n    // How big are the colums/rows?\n    if (this.flow == 0)\n        for (var i = 0; i < r; i++) {\n            for (var j = 0; j < c; j++) {\n                var item = visibleItems[i*c+j];\n                if (!item)\n                    break;\n                if (!colWidth[j] || item.width > colWidth[j])\n                    colWidth[j] = item.width;\n                if (!rowHeight[i] || item.height > rowHeight[i])\n                    rowHeight[i] = item.height;\n            }\n        }\n    else\n        for (var i = 0; i < c; i++) {\n            for (var j = 0; j < r; j++) {\n                var item = visibleItems[i*r+j];\n                if (!item)\n                    break;\n                if (!rowHeight[j] || item.height > rowHeight[j])\n                    rowHeight[j] = item.height;\n                if (!colWidth[i] || item.width > colWidth[i])\n                    colWidth[i] = item.width;\n            }\n        }\n\n    for (var i in colWidth)\n        gridWidth += colWidth[i] + this.spacing;\n    for (var i in rowHeight)\n        gridHeight += rowHeight[i] + this.spacing;\n\n    // Do actual positioning\n    // When layoutDirection is RightToLeft we need oposite order of coumns\n    var step = this.layoutDirection == 1 ? -1 : 1,\n        startingPoint = this.layoutDirection == 1 ? c - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : c;\n    if (this.flow == 0)\n        for (var i = 0; i < r; i++) {\n            for (var j = startingPoint; j !== endPoint; j += step) {\n                var item = visibleItems[i*c+j];\n                if (!item)\n                    break;\n                item.x = curHPos;\n                item.y = curVPos;\n\n                curHPos += colWidth[j] + this.spacing;\n            }\n            curVPos += rowHeight[i] + this.spacing;\n            curHPos = 0;\n        }\n    else\n        for (var i = startingPoint; i !== endPoint; i += step) {\n            for (var j = 0; j < r; j++) {\n                var item = visibleItems[i*r+j];\n                if (!item)\n                    break;\n                item.x = curHPos;\n                item.y = curVPos;\n\n                curVPos += rowHeight[j] + this.spacing;\n            }\n            curHPos += colWidth[i] + this.spacing;\n            curVPos = 0;\n        }\n\n    this.implicitWidth = gridWidth;\n    this.implicitHeight = gridHeight;\n}\n","function QMLImage(meta) {\n    callSuper(this, meta);\n    var img = new Image(),\n        self = this;\n\n    // Exports.\n    this.Image = {\n        // fillMode\n        Stretch: 1,\n        PreserveAspectFit: 2,\n        PreserveAspectCrop: 3,\n        Tile: 4,\n        TileVertically: 5,\n        TileHorizontally: 6,\n        // status\n        Null: 1,\n        Ready: 2,\n        Loading: 3,\n        Error: 4\n    }\n\n    // no-op properties\n    createProperty(\"bool\", this, \"asynchronous\", {initialValue: true});\n    createProperty(\"bool\", this, \"cache\", {initialValue: true});\n    createProperty(\"bool\", this, \"smooth\", {initialValue: true});\n\n    createProperty(\"enum\", this, \"fillMode\", {initialValue: this.Image.Stretch});\n    createProperty(\"bool\", this, \"mirror\");\n    createProperty(\"real\", this, \"progress\");\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\", {initialValue: this.Image.Null});\n\n    this.sourceSize = new QObject(this);\n\n    createProperty(\"int\", this.sourceSize, \"width\");\n    createProperty(\"int\", this.sourceSize, \"height\");\n\n    const bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.height = '100%';\n    this.dom.appendChild(bg);\n\n    // Bind status to img element\n    img.onload = function() {\n        var w = img.naturalWidth;\n        var h = img.naturalHeight;\n        self.sourceSize.width = w;\n        self.sourceSize.height = h;\n        self.implicitWidth = w;\n        self.implicitHeight = h;\n\n        self.progress = 1;\n        self.status = self.Image.Ready;\n    }\n    img.onerror = function() {\n        self.status = self.Image.Error;\n    }\n\n    var updateFillMode = function(val) {\n      if (typeof val == 'undefined')\n        val = this.fillMode;\n      switch (val) {\n        default:\n        case this.Image.Stretch:\n          bg.style.backgroundRepeat   = 'auto';\n          bg.style.backgroundSize     = '100% 100%';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.Tile:\n          bg.style.backgroundRepeat   = 'auto';\n          bg.style.backgroundSize     = 'auto';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.PreserveAspectFit:\n          bg.style.backgroundRepeat   = 'no-repeat';\n          bg.style.backgroundSize     = 'contain';\n          bg.style.backgroundPosition = 'center';\n          break ;\n        case this.Image.PreserveAspectCrop:\n          bg.style.backgroundRepeat   = 'no-repeat';\n          bg.style.backgroundSize     = 'cover';\n          bg.style.backgroundPosition = 'center';\n          break ;\n        case this.Image.TileVertically:\n          bg.style.backgroundRepeat   = 'repeat-y';\n          bg.style.backgroundSize     = '100% auto';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.TileHorizontally:\n          bg.style.backgroundRepeat   = 'repeat-x';\n          bg.style.backgroundSize     = 'auto 100%';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n      }\n    }\n    updateFillMode = updateFillMode.bind(this);\n\n    var updateMirroring = (function(val) {\n      var transformRule = 'scale(-1,1)';\n      if (!val)\n      {\n        var index = this.transform.indexOf(transformRule);\n\n        if (index >= 0)\n          this.transform.splice(index, 1);\n      }\n      else\n        this.transform.push(transformRule);\n      this.$updateTransform();\n    }).bind(this);\n\n    this.sourceChanged.connect(this, function(val) {\n        this.progress = 0;\n        this.status = this.Image.Loading;\n        bg.style.backgroundImage=\"url('\" + engine.$resolvePath(val) + \"')\";\n        img.src = engine.$resolvePath(val);\n        if (img.complete)\n          this.status = this.Image.Ready;\n        updateFillMode();\n    });\n\n    this.mirrorChanged.connect  (this, updateMirroring);\n    this.fillModeChanged.connect(this, updateFillMode);\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Image',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLImage\n});\n","function QMLItem(meta) {\n    callSuper(this, meta);\n    var child,\n        o, i;\n\n    if (this.$parent === null) { // This is the root element. Initialize it.\n        this.dom = engine.rootElement || document.body;\n        this.dom.innerHTML = \"\";\n        var self = this;\n        this.dom.style.position = \"relative\"; // Needed to make absolute positioning work\n        this.dom.style.top = \"0\";\n        this.dom.style.left = \"0\";\n        this.dom.style.overflow = \"hidden\"; // No QML stuff should stand out the root element\n    } else {\n        if (!this.dom) // Create a dom element for this item.\n            this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"absolute\";\n    }\n    this.dom.style.pointerEvents = \"none\";\n    /* In case the class is qualified, only use the last part for the css class\n     * name. */\n    var classComponents = meta.object.$class.split(\".\");\n    this.dom.className = classComponents[classComponents.length-1] + (this.id ? \" \" + this.id : \"\");\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = 'border-box';\n\n    this.parentChanged.connect(this, function(newParent, oldParent) {\n        if (oldParent) {\n            oldParent.children.splice(oldParent.children.indexOf(this), 1);\n            oldParent.childrenChanged();\n            oldParent.dom.removeChild(this.dom);\n        }\n        if (newParent && newParent.children.indexOf(this) == -1) {\n            newParent.children.push(this);\n            newParent.childrenChanged();\n        }\n        if (newParent)\n            newParent.dom.appendChild(this.dom);\n    });\n    this.parentChanged.connect(this, updateHGeometry);\n    this.parentChanged.connect(this, updateVGeometry);\n    this.dataChanged.connect(this, function(newData) {\n        for (var i in newData) {\n            var child = newData[i];\n            if (child.hasOwnProperty(\"parent\")) // Seems to be an Item. TODO: Use real inheritance and ask using instanceof.\n                child.parent = this; // This will also add it to children.\n            else\n                this.resources.push(child);\n        }\n    });\n\n    if (this.$isComponentRoot)\n      createProperty(\"var\", this, \"activeFocus\");\n\n    this.xChanged.connect(this, updateHGeometry);\n    this.yChanged.connect(this, updateVGeometry);\n    this.widthChanged.connect(this, updateHGeometry);\n    this.heightChanged.connect(this, updateVGeometry);\n    this.implicitWidthChanged.connect(this, updateHGeometry);\n    this.implicitHeightChanged.connect(this, updateVGeometry);\n\n    this.setupFocusOnDom = (function(element) {\n      var updateFocus = (function() {\n        var hasFocus = document.activeElement == this.dom || document.activeElement == this.dom.firstChild;\n\n        if (this.focus != hasFocus)\n          this.focus = hasFocus;\n      }).bind(this);\n      element.addEventListener(\"focus\", updateFocus);\n      element.addEventListener(\"blur\",  updateFocus);\n    }).bind(this);\n\n    this.focusChanged.connect(this, (function(newVal) {\n      if (newVal == true) {\n        if (this.dom.firstChild != null)\n          this.dom.firstChild.focus();\n        document.qmlFocus = this;\n        this.$context.activeFocus = this;\n      } else if (document.qmlFocus == this) {\n        document.getElementsByTagName(\"BODY\")[0].focus();\n        document.qmlFocus = engine.rootContext().base;\n        this.$context.activeFocus = null;\n      }\n    }).bind(this));\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QObject(this);\n    createProperty(\"var\", this.anchors, \"left\");\n    createProperty(\"var\", this.anchors, \"right\");\n    createProperty(\"var\", this.anchors, \"top\");\n    createProperty(\"var\", this.anchors, \"bottom\");\n    createProperty(\"var\", this.anchors, \"horizontalCenter\");\n    createProperty(\"var\", this.anchors, \"verticalCenter\");\n    createProperty(\"Item\", this.anchors, \"fill\");\n    createProperty(\"Item\", this.anchors, \"centerIn\");\n    createProperty(\"real\", this.anchors, \"margins\");\n    createProperty(\"real\", this.anchors, \"leftMargin\");\n    createProperty(\"real\", this.anchors, \"rightMargin\");\n    createProperty(\"real\", this.anchors, \"topMargin\");\n    createProperty(\"real\", this.anchors, \"bottomMargin\");\n    this.anchors.leftChanged.connect(this, updateHGeometry);\n    this.anchors.rightChanged.connect(this, updateHGeometry);\n    this.anchors.topChanged.connect(this, updateVGeometry);\n    this.anchors.bottomChanged.connect(this, updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, updateVGeometry);\n    this.anchors.fillChanged.connect(this, updateHGeometry);\n    this.anchors.fillChanged.connect(this, updateVGeometry);\n    this.anchors.centerInChanged.connect(this, updateHGeometry);\n    this.anchors.centerInChanged.connect(this, updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, updateVGeometry);\n    this.anchors.marginsChanged.connect(this, updateHGeometry);\n    this.anchors.marginsChanged.connect(this, updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QObject(this);\n    createProperty(\"real\", this.childrenRect, \"x\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"y\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"width\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"height\"); // TODO ro\n\n    this.stateChanged.connect(this, function(newVal, oldVal) {\n        var oldState, newState, i, j, k;\n        for (i = 0; i < this.states.length; i++)\n            if (this.states[i].name === newVal)\n                newState = this.states[i];\n            else if (this.states[i].name === oldVal)\n                oldState = this.states[i];\n\n        var actions = this.$revertActions.slice();\n\n        // Get current values for revert actions\n        for (i in actions) {\n            var action  = actions[i];\n            action.from = action.target[action.property];\n        }\n        if (newState) {\n            var changes = newState.$getAllChanges();\n\n            // Get all actions we need to do and create actions to revert them\n            for (i = 0; i < changes.length; i++) {\n                var change = changes[i];\n\n                for (j = 0; j < change.$actions.length; j++) {\n                    var item = change.$actions[j];\n\n                    var action = {\n                        target: change.target,\n                        property: item.property,\n                        origValue: change.target.$properties[item.property].binding\n                                    || change.target.$properties[item.property].val,\n                        value: item.value,\n                        from: change.target[item.property],\n                        to: undefined,\n                        explicit: change.explicit\n                    };\n                    var found = false;\n                    for (k in actions)\n                        if (actions[k].target == action.target\n                            && actions[k].property == action.property) {\n                            found = true;\n                            actions[k] = action;\n                            break;\n                        }\n                    if (!found)\n                        actions.push(action);\n\n                    // Look for existing revert action, else create it\n                    var found = false;\n                    for (k = 0; k < this.$revertActions.length; k++)\n                        if (this.$revertActions[k].target == change.target\n                            && this.$revertActions[k].property == item.property) {\n                            if (!change.restoreEntryValues)\n                                this.$revertActions.splice(k, 1); // We don't want to revert, so remove it\n                            found = true;\n                            break;\n                        }\n                    if (!found && change.restoreEntryValues)\n                        this.$revertActions.push({\n                            target: change.target,\n                            property: item.property,\n                            value: change.target.$properties[item.property].binding\n                                        || change.target.$properties[item.property].val,\n                            from: undefined,\n                            to: change.target[item.property]\n                        });\n                }\n            }\n        }\n\n        // Set all property changes and fetch the actual values afterwards\n        // The latter is needed for transitions. We need to set all properties\n        // before we fetch the values because properties can be interdependent.\n        for (i in actions) {\n            var action = actions[i];\n            action.target.$properties[action.property].set(action.value, QMLProperty.ReasonUser, action.target,\n                                                           newState ? newState.$context: action.target.$context);\n        }\n        for (i in actions) {\n            var action = actions[i];\n            action.to = action.target[action.property];\n            if (action.explicit) {\n                action.target[action.property] = action.target[action.property]; //Remove binding\n                action.value = action.target[action.property];\n            }\n        }\n\n        // Find the best transition to use\n        var transition,\n            rating = 0;\n        for (var i = 0; i < this.transitions.length; i++) {\n            this.transitions[i].$stop(); // We need to stop running transitions, so let's do\n                                        // it while iterating through the transitions anyway\n            var curTransition = this.transitions[i],\n                curRating = 0;\n            if (curTransition.from == oldVal || curTransition.reversible && curTransition.from == newVal)\n                curRating += 2;\n            else if (curTransition.from == \"*\")\n                curRating++;\n            else\n                continue;\n            if (curTransition.to == newVal || curTransition.reversible && curTransition.to == oldVal)\n                curRating += 2;\n            else if (curTransition.to == \"*\")\n                curRating++;\n            else\n                continue;\n            if (curRating > rating) {\n                rating = curRating;\n                transition = curTransition;\n            }\n        }\n        if (transition)\n            transition.$start(actions);\n    });\n\n    var QMLRotation  = getConstructor('QtQuick', '2.0', 'Rotation');\n    var QMLScale     = getConstructor('QtQuick', '2.0', 'Scale');\n    var QMLTranslate = getConstructor('QtQuick', '2.0', 'Translate');\n\n    this.$updateTransform = function() {\n            var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\n            var filter = \"\";\n            var transformStyle = \"preserve-3d\";\n\n            for (var i = 0; i < this.transform.length; i++) {\n                var t = this.transform[i];\n                if (t instanceof QMLRotation)\n                    transform += \" rotate3d(\" + t.axis.x + \", \" + t.axis.y + \", \" + t.axis.z + \", \" + t.angle + \"deg)\";\n                else if (t instanceof QMLScale)\n                    transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\n                else if (t instanceof QMLTranslate)\n                    transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\n                else if (typeof t.transformType != 'undefined') {\n                    if (t.transformType == 'filter')\n                      filter += t.operation + '(' + t.parameters + ') ';\n                }\n                else if (typeof t == 'string')\n                    transform += t;\n            }\n            if (typeof this.z == \"number\")\n              transform += \" translate3d(0, 0, \" + this.z + \"px)\";\n            this.dom.style.transform = transform;\n            this.dom.style.transformStyle = transformStyle;\n            this.dom.style.MozTransform = transform;    // Firefox\n            this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n            this.dom.style.webkitTransformStyle = transformStyle;\n            this.dom.style.OTransform = transform;      // Opera\n            this.dom.style.msTransform = transform;     // IE\n            this.dom.style.filter = filter;\n            this.dom.style.msFilter = filter;     // IE\n            this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n            this.dom.style.MozFilter = filter;    // Firefox\n    }\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n    this.visibleChanged.connect(this, function(newVal) {\n        this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n    });\n    this.clipChanged.connect(this, function(newVal) {\n        this.css.overflow = newVal ? \"hidden\" : \"visible\";\n    });\n    this.zChanged.connect(this, function(newVal) {\n        this.$updateTransform();\n    });\n    this.xChanged.connect(this, function(newVal) {\n        this.css.left = newVal + \"px\";\n    });\n    this.yChanged.connect(this, function(newVal) {\n        this.css.top = newVal + \"px\";\n    });\n    this.widthChanged.connect(this, function(newVal) {\n        this.css.width = newVal ? newVal + \"px\" : \"auto\";\n    });\n    this.heightChanged.connect(this, function(newVal) {\n        this.css.height = newVal ? newVal + \"px\" : \"auto\";\n    });\n\n    this.Component.completed.connect(this, this.$calculateOpacity);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = this.x + 'px';\n    this.css.top = this.y + 'px';\n\n    // Init size of root element\n    if (this.$parent === null) {\n        if (engine.rootElement == undefined) {\n            // Case 1: Qml scene is placed in body tag\n\n            // event handling by addEventListener is probably better than setting window.onresize\n            var updateQmlGeometry = function() {\n                self.implicitHeight = window.innerHeight;\n                self.implicitWidth = window.innerWidth;\n            }\n            window.addEventListener( \"resize\", updateQmlGeometry );\n            updateQmlGeometry();\n        } else {\n            // Case 2: Qml scene is placed in some element tag\n\n            // we have to call `self.implicitHeight =` and `self.implicitWidth =`\n            // each time the rootElement changes it's geometry\n            // to reposition child elements of qml scene\n\n            // it is good to have this as named method of dom element, so we can call it\n            // from outside too, whenever element changes it's geometry (not only on window resize)\n            this.dom.updateQmlGeometry = function() {\n              self.implicitHeight = self.dom.offsetHeight;\n              self.implicitWidth = self.dom.offsetWidth;\n            };\n            window.addEventListener( \"resize\", this.dom.updateQmlGeometry );\n            this.dom.updateQmlGeometry();\n        }\n    }\n}\n\nQMLItem.prototype.$calculateOpacity = function() {\n  // TODO: reset all opacity on layer.enabled changed\n  if (false) { // TODO: check layer.enabled\n    this.css.opacity = this.opacity;\n  }\n  const parentOpacity = (this.$parent && this.$parent.$opacity) || 1;\n  this.$opacity = this.opacity * parentOpacity;\n  if (this.impl) {\n    this.impl.style.opacity = this.$opacity;\n  }\n};\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'Item',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  properties: {\n    $opacity: {type: 'real', initialValue: 1},\n    parent: 'Item',\n    state: 'string',\n    states: 'list',\n    transitions: 'list',\n    data: 'list',\n    children: 'list',\n    resources: 'list',\n    transform: 'list',\n    x: 'real',\n    y: 'real',\n    z: 'real',\n    width: 'real',\n    height: 'real',\n    implicitWidth: 'real',\n    implicitHeight: 'real',\n    left: 'real',\n    right: 'real',\n    top: 'real',\n    bottom: 'real',\n    horizontalCenter: 'real',\n    verticalCenter: 'real',\n    rotation: 'real',\n    scale: {type: 'real', initialValue: 1},\n    opacity: {type: 'real', initialValue: 1},\n    visible: {type: 'bool', initialValue: true},\n    clip: 'bool',\n    focus: 'bool'\n  },\n  defaultProperty: 'data',\n  constructor: QMLItem\n});\n","function QMLPositioner(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"spacing\");\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, QMLPositioner.slotChildrenChanged);\n\n    this.layoutChildren();\n}\n\nQMLPositioner.slotChildrenChanged = function() {\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.widthChanged.isConnected(this, this.layoutChildren))\n            child.widthChanged.connect(this, this.layoutChildren);\n        if (!child.heightChanged.isConnected(this, this.layoutChildren))\n            child.heightChanged.connect(this, this.layoutChildren);\n        if (!child.visibleChanged.isConnected(this, this.layoutChildren))\n            child.visibleChanged.connect(this, this.layoutChildren);\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Positioner',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLPositioner\n});\n","function QMLPropertyChanges(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"QtObject\", this, \"target\");\n    createProperty(\"bool\", this, \"explicit\");\n    createProperty(\"bool\", this, \"restoreEntryValues\", {initialValue: true});\n\n    this.$actions = [];\n\n    this.$setCustomData = function(propName, value) {\n        this.$actions.push({\n            property: propName,\n            value: value\n        });\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'PropertyChanges',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: QMLPropertyChanges\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Rectangle',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLRectangle\n});\n\nfunction QMLRectangle(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"color\", this, \"color\", {initialValue: 'white'});\n    createProperty(\"real\", this, \"radius\");\n\n    this.border = new QObject(this);\n    createProperty(\"color\", this.border, \"color\", {initialValue: 'black'});\n    createProperty(\"int\", this.border, \"width\", {initialValue: 1});\n\n    const bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.position = 'absolute';\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = '0px';\n    bg.style.borderWidth ='0px';\n    bg.style.borderStyle = 'solid';\n    bg.style.borderColor = 'black';\n    bg.style.backgroundColor = 'white';\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, function(newVal) {\n        bg.style.backgroundColor = QMLColor(newVal);\n    });\n    this.radiusChanged.connect(this, function(newVal) {\n        bg.style.borderRadius = newVal + 'px';\n    });\n    this.border.colorChanged.connect(this, function(newVal) {\n        bg.style.borderColor = QMLColor(newVal);\n        if (bg.style.borderWidth == '0px') {\n            bg.style.borderWidth = this.border.width + 'px';\n        }\n        this.$updateBorder(this.border.width);\n    });\n    this.border.widthChanged.connect(this, function(newVal) {\n        // ignore negative border width\n        if (newVal >= 0) {\n            this.$updateBorder(newVal);\n        } else {\n            bg.style.borderWidth = \"0px\";\n        }\n    });\n    this.widthChanged.connect(this, function(newVal){\n       this.$updateBorder(this.border.width);\n    });\n    this.heightChanged.connect(this, function(newVal){\n       this.$updateBorder(this.border.width);\n    });\n}\n\nQMLRectangle.prototype.$updateBorder = function(newBorderWidth) {\n    const bg = this.dom.firstChild;\n\n    // ignore negative and 0px border width\n    if (newBorderWidth == \"0px\" || newBorderWidth < 0) {\n        return;\n    }\n    // no Rectangle border width was set yet\n    if ( (newBorderWidth == \"1\" && bg.style.borderWidth == \"0px\") || ( typeof newBorderWidth === \"undefined\" && bg.style.borderWidth == \"0px\") ) {\n        return;\n    }\n\n    var topBottom = typeof newBorderWidth === \"undefined\" ? bg.style.borderWidth : newBorderWidth + 'px';\n    var leftRight = topBottom;\n\n    bg.style.borderTopWidth = topBottom;\n    bg.style.borderBottomWidth = topBottom;\n    bg.style.borderLeftWidth = leftRight;\n    bg.style.borderRightWidth = leftRight;\n\n    // hide border if any of dimensions is less then one\n    if (this.width <= 0 || this.height <= 0 || typeof this.width === \"undefined\" || typeof this.height === \"undefined\") {\n        bg.style.borderWidth = '0px';\n    } else {\n        // check if border is not greater than Rectangle size\n        // react by change of width or height of div (in css)\n\n        if (2 * this.border.width > this.height) {\n            topBottom = this.height/2 + 'px';\n            bg.style.height = '0px';\n        } else {\n            if ( this.height - 2 * this.border.width < this.border.width) {\n                if (this.height > 2) {\n                    bg.style.height = (this.height%2 ? -1 : -2 + this.height + (this.height - (2*this.border.width))) + 'px';\n                }\n            }\n        }\n\n        if (2 * this.border.width > this.width) {\n            leftRight = this.width/2 + 'px';\n            bg.style.width = '0px';\n        } else {\n            if (this.width - 2 * this.border.width < this.border.width) {\n                if (this.width > 2) {\n                    bg.style.width = (this.width%2 ? -1 : -2 + this.width + ( this.width - (2*this.border.width))) + 'px';\n                }\n            }\n        }\n\n        bg.style.borderTopWidth = topBottom;\n        bg.style.borderBottomWidth = topBottom;\n        bg.style.borderLeftWidth = leftRight;\n        bg.style.borderRightWidth = leftRight;\n    }\n};\n","function QMLRepeater(meta) {\n    callSuper(this, meta);\n    var self = this;\n    var QMLListModel = getConstructor('QtQuick', '2.0', 'ListModel');\n\n    this.parent = meta.parent; // TODO: some (all ?) of the components including Repeater needs to know own parent at creation time. Please consider this major change.\n\n    createProperty(\"Component\", this, \"delegate\");\n    this.container = function() { return this.parent; }\n    this.$defaultProperty = \"delegate\";\n    createProperty(\"variant\", this, \"model\", {initialValue: 0});\n    createProperty(\"int\", this, \"count\");\n    this.$completed = false;\n    this.$items = []; // List of created items\n    this._childrenInserted = Signal();\n\n    this.modelChanged.connect(applyModel);\n    this.delegateChanged.connect(applyModel);\n    this.parentChanged.connect(applyModel);\n\n    this.itemAt = function(index) {\n        return this.$items[index];\n    }\n\n    function callOnCompleted(child) {\n        child.Component.completed();\n        for (var i = 0; i < child.$tidyupList.length; i++)\n            if (child.$tidyupList[i] instanceof QMLBaseObject)\n                callOnCompleted(child.$tidyupList[i]);\n    }\n    function insertChildren(startIndex, endIndex) {\n        if (endIndex <= 0) return;\n\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n\n        for (var index = startIndex; index < endIndex; index++) {\n            var newItem = self.delegate.createObject();\n            createProperty('int', newItem, 'index', {initialValue: index});\n            newItem.parent = self.parent;\n            self.delegate.finalizeImports(); // To properly import JavaScript in the context of a component\n\n            if ( typeof model == \"number\" || model instanceof Array ) {\n                 if (typeof newItem.$properties[\"modelData\"] == 'undefined'){\n                    createProperty(\"variant\", newItem, \"modelData\");\n                 }\n                 var value = model instanceof Array ? model[index] : typeof model == \"number\" ? index : \"undefined\";\n                 newItem.$properties[\"modelData\"].set(value, true, newItem, model.$context);\n            } else {\n                for (var i = 0; i < model.roleNames.length; i++) {\n                    var roleName = model.roleNames[i];\n                    if (typeof newItem.$properties[roleName] == 'undefined')\n                      createProperty(\"variant\", newItem, roleName);\n                    newItem.$properties[roleName].set(model.data(index, roleName), true, newItem, self.model.$context);\n                }\n            }\n\n            self.$items.splice(index, 0, newItem);\n\n            // TODO debug this. Without check to Init, Completed sometimes called twice.. But is this check correct?\n            if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n                // We don't call those on first creation, as they will be called\n                // by the regular creation-procedures at the right time.\n                callOnCompleted(newItem);\n            }\n        }\n        if (engine.operationState !== QMLOperationState.Init) {\n             // We don't call those on first creation, as they will be called\n             // by the regular creation-procedures at the right time.\n             engine.$initializePropertyBindings();\n        }\n\n        if (index > 0) {\n            self.container().childrenChanged();\n        }\n\n        for (var i = endIndex; i < self.$items.length; i++)\n            self.$items[i].index = i;\n\n        self.count = self.$items.length;\n    }\n\n    function onModelDataChanged(startIndex, endIndex, roles) {\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n\n        if (!roles)\n            roles = model.roleNames;\n        for (var index = startIndex; index <= endIndex; index++) {\n            for (var i in roles) {\n                self.$items[index].$properties[roles[i]].set(model.data(index, roles[i]), QMLProperty.ReasonInit, self.$items[index], self.model.$context);\n            }\n        }\n    }\n    function onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\n        var vals = self.$items.splice(sourceStartIndex, sourceEndIndex-sourceStartIndex);\n        for (var i = 0; i < vals.length; i++) {\n            self.$items.splice(destinationIndex + i, 0, vals[i]);\n        }\n        var smallestChangedIndex = sourceStartIndex < destinationIndex\n                                ? sourceStartIndex : destinationIndex;\n        for (var i = smallestChangedIndex; i < self.$items.length; i++) {\n            self.$items[i].index = i;\n        }\n    }\n    function onRowsRemoved(startIndex, endIndex) {\n        removeChildren(startIndex, endIndex);\n        for (var i = startIndex; i < self.$items.length; i++) {\n            self.$items[i].index = i;\n        }\n        self.count = self.$items.length;\n    }\n    function onModelReset() {\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n        removeChildren(0, self.$items.length);\n    }\n    function applyModel() {\n        if (!self.delegate || !self.parent)\n            return;\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n        if (model instanceof JSItemModel) {\n            if ( model.dataChanged.isConnected(onModelDataChanged) == false ) model.dataChanged.connect(onModelDataChanged);\n            if ( model.rowsInserted.isConnected(insertChildren) == false ) model.rowsInserted.connect(insertChildren);\n            if ( model.rowsMoved.isConnected(onRowsMoved) == false  ) model.rowsMoved.connect(onRowsMoved);\n            if ( model.rowsRemoved.isConnected(onRowsRemoved) == false  ) model.rowsRemoved.connect(onRowsRemoved);\n            if ( model.modelReset.isConnected(onModelReset) == false  ) model.modelReset.connect(onModelReset);\n\n            removeChildren(0, self.$items.length);\n            insertChildren(0, model.rowCount());\n        } else if (typeof model == \"number\") {\n            // must be more elegant here.. do not delete already created models..\n            //removeChildren(0, self.$items.length);\n            //insertChildren(0, model);\n\n            if (self.$items.length > model) {\n               // have more than we need\n               removeChildren(model,self.$items.length);\n            }\n            else\n            {\n               // need more\n               insertChildren(self.$items.length,model);\n            }\n\n        } else if (model instanceof Array) {\n            removeChildren(0, self.$items.length);\n            insertChildren(0, model.length);\n        }\n    }\n\n    function removeChildren(startIndex, endIndex) {\n        var removed = self.$items.splice(startIndex, endIndex - startIndex);\n        for (var index in removed) {\n            removed[index].$delete();\n            removeChildProperties(removed[index]);\n        }\n    }\n    function removeChildProperties(child) {\n        engine.completedSignals.splice(engine.completedSignals.indexOf(child.Component.completed), 1);\n        for (var i = 0; i < child.children.length; i++)\n            removeChildProperties(child.children[i])\n    }\n}\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'Repeater',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLRepeater\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Row',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLRow\n});\n\nfunction QMLRow(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLRow.prototype.layoutChildren = function() {\n    var curPos = 0,\n        maxHeight = 0,\n        // When layoutDirection is RightToLeft we need oposite order\n        i = this.layoutDirection == 1 ? this.children.length - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : this.children.length,\n        step = this.layoutDirection == 1 ? -1 : 1;\n    for (; i !== endPoint; i += step) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n        maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n        child.x = curPos;\n        curPos += child.width + this.spacing;\n    }\n    this.implicitHeight = maxHeight;\n    this.implicitWidth = curPos - this.spacing; // We want no spacing at the right side\n}\n","function QMLTextEdit(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    // Properties\n    createProperty('bool', this, 'activeFocusOnPress');\n    createProperty('url', this, 'baseUrl');\n    createProperty('bool', this, 'canPaste');\n    createProperty('bool', this, 'canRedo');\n    createProperty('bool', this, 'canUndo');\n    createProperty('color', this, 'color');\n    createProperty('real', this, 'contentHeight');\n    createProperty('real', this, 'contentWidth');\n    createProperty('Component', this, 'cursorDelegate');\n    createProperty('int', this, 'cursorPosition');\n    createProperty('rectangle', this, 'cursorRectangle');\n    createProperty('bool', this, 'cursorVisible');\n    createProperty('enum', this, 'effectiveHorizontalAlignment');\n    createProperty('enum', this, 'horizontalAlignment');\n    createProperty('string', this, 'hoveredLink');\n    createProperty('bool', this, 'inputMethodComposing');\n    createProperty('enum', this, 'inputMethodHints');\n    createProperty('int', this, 'length');\n    createProperty('int', this, 'lineCount');\n    createProperty('enum', this, 'mouseSelectionMode');\n    createProperty('bool', this, 'persistentSelection');\n    createProperty('bool', this, 'readOnly');\n    createProperty('enum', this, 'renderType');\n    createProperty('bool', this, 'selectByKeyboard');\n    createProperty('bool', this, 'selectByMouse');\n    createProperty('string', this, 'selectedText');\n    createProperty('color', this, 'selectedTextColor');\n    createProperty('color', this, 'selectionColor');\n    createProperty('int', this, 'selectionEnd');\n    createProperty('int', this, 'selectionStart');\n    createProperty('string', this, 'text');\n    createProperty('TextDocument', this, 'textDocument');\n    createProperty('enum', this, 'textFormat');\n    createProperty('real', this, 'textMargin');\n    createProperty('enum', this, 'verticalAlignment');\n    createProperty('enum', this, 'wrapMode');\n\n    const QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    this.activeFocusOnPress = true;\n    this.baseUrl = undefined;\n    this.canPaste = false;\n    this.canRedo = false;\n    this.canUndo = false;\n    this.color = 'white';\n    this.contentHeight = 0;\n    this.contentWidth = 0;\n    this.cursorDelegate = undefined;\n    this.cursorPosition = 0;\n    this.cursorRectangle = undefined;\n    this.cursorVisible = true;\n    this.effectiveHorizontalAlignment = undefined;\n    this.horizontalAlignment = undefined;\n    this.hoveredLink = undefined;\n    this.inputMethodComposing = undefined;\n    this.inputMethodHints = undefined;\n    this.length = 0;\n    this.lineCount = 0;\n    this.mouseSelectionMode = undefined;\n    this.persistentSelection = false;\n    this.readOnly = false;\n    this.renderType = undefined;\n    this.selectByKeyboard = true;\n    this.selectByMouse = false;\n    this.selectedText = undefined;\n    this.selectedTextColor = 'yellow';\n    this.selectionColor = 'pink';\n    this.selectionEnd = 0;\n    this.selectionStart = 0;\n    this.text = '';\n    this.textDocument = undefined;\n    this.textFormat = undefined;\n    this.textMargin = 0;\n    this.verticalAlignment = undefined;\n    this.wrapMode = undefined;\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    const textarea = this.impl = document.createElement('textarea');\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = 'border-box';\n    textarea.style.borderWidth = '0';\n    textarea.style.background = 'none';\n    textarea.style.outline = 'none';\n    textarea.style.resize = 'none';\n    textarea.style.padding = '0'; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = textarea.offsetWidth;\n        this.implicitHeight = textarea.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function(newVal) {\n        textarea.value = newVal;\n    });\n\n    // Signals\n    this.linkActivated = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n    this.linkHovered = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n\n    // Methods\n    this.append = function append(text) {\n        this.text += text;\n    };\n\n    this.copy = function copy() {\n        // TODO\n    };\n\n    this.cut = function cut() {\n        this.text =\n            this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);\n        // TODO\n    };\n\n    this.deselect = function deselect() {\n        //this.selectionStart = -1;\n        //this.selectionEnd = -1;\n        //this.selectedText = null;\n    };\n\n    this.getFormattedText = function getFormattedText(start, end) {\n        this.text = this.text.slice(start, end);\n        // TODO\n        // process text\n        return text;\n    };\n\n    this.getText = function getText(start, end) {\n        return this.text.slice(start, end);\n    };\n\n    this.insert = function getText(position, text) {\n        // TODO\n    };\n\n    this.isRightToLeft = function isRightToLeft(start, end) {\n        // TODO\n    };\n\n    this.linkAt = function linkAt(x, y) {\n        // TODO\n    };\n\n    this.moveCursorSelection = function moveCursorSelection(x, y) {\n        // TODO\n    };\n\n    this.paste = function paste() {\n        // TODO\n    };\n\n    this.positionAt = function positionAt(x, y) {\n        // TODO\n    };\n\n    this.positionToRectangle = function positionToRectangle(position) {\n        // TODO\n    };\n\n    this.redo = function redo() {\n        // TODO\n    };\n\n    this.remove = function remove(start, end) {\n        // TODO\n    };\n\n    this.select = function select(start, end) {\n        // TODO\n    };\n\n    this.selectAll = function selectAll() {\n        // TODO\n    };\n\n    this.selectWord = function selectWord() {\n        // TODO\n    };\n\n    this.undo = function undo() {\n        // TODO\n    };\n\n    var getLineCount = function(self) {\n        return self.text.split(/\\n/).length;\n    }\n\n    this.Component.completed.connect(this, function() {\n        this.selectByKeyboard = !this.readOnly;\n        updateValue();\n    });\n\n    // Transfer dom style to firstChild,\n    // then clear corresponding dom style\n    function updateCss(self) {\n        var supported = [\n            'border',\n            'borderRadius',\n            'borderWidth',\n            'borderColor',\n            'backgroundColor',\n        ];\n\n        var child_style = self.dom.firstChild.style;\n        for (n = 0; n < supported.length; n++) {\n            var o = supported[n];\n            var v = self.css[o];\n            if (v) {\n                child_style[o] = v;\n                self.css[o] = null;\n            }\n        }\n    }\n\n    function updateValue(e) {\n        if (self.text != self.dom.firstChild.value) {\n            self.text = self.dom.firstChild.value;\n        }\n        self.length = self.text.length;\n        self.lineCount = getLineCount(self);\n        updateCss(self);\n    }\n\n    textarea.oninput = updateValue;\n    textarea.onpropertychanged = updateValue;\n\n    this.colorChanged.connect(this, function(newVal) {\n        textarea.style.color = newVal;\n    });\n}\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'TextEdit',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLTextEdit\n});\n","class QMLBinding {\n/**\n * Create QML binding.\n * @param {Variant} val Sourcecode or function representing the binding\n * @param {Array} tree Parser tree of the binding\n * @return {Object} Object representing the binding\n */\n  constructor(val, tree) {\n    // this.isFunction states whether the binding is a simple js statement or a function containing\n    // a return statement. We decide this on whether it is a code block or not. If it is, we require\n    // a return statement. If it is a code block it could though also be a object definition, so we\n    // need to check that as well (it is, if the content is labels).\n    // need to check that as well (it is, if the content is labels).\n    this.isFunction = tree && tree[0] == \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\n    this.src = val;\n  }\n\n  toJSON() {\n    return {src: this.src,\n        deps: JSON.stringify(this.deps),\n        tree: JSON.stringify(this.tree) };\n  }\n\n/**\n * Compile binding. Afterwards you may call binding.eval to evaluate.\n */\n  compile() {\n    this.eval = new Function('__executionObject', '__executionContext', \"_executionContext = __executionContext; with(__executionContext) with(__executionObject) \" + ( this.isFunction ? \"\" : \"return \" ) + this.src);\n  }\n}\n\nglobal.QMLBinding = QMLBinding;\n","/* @license\n\nMIT License\n\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\n                                                         import implementation.\nCopyright (c) 2016 QmlWeb contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * Get URL contents. EXPORTED.\n * @param url {String} Url to fetch.\n * @param skipExceptions {bool} when turned on, ignore exeptions and return false. This feature is used by readQmlDir.\n * @private\n * @return {mixed} String of contents or false in errors.\n */\ngetUrlContents = function (url, skipExceptions) {\n    if (typeof urlContentCache[url] == 'undefined') {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, false);\n\n      if (skipExceptions)\n        { try { xhr.send(null); } catch (e) { return false; } } /* it is OK to not have logging here, because DeveloperTools already will have red log record */\n      else\n        xhr.send(null);\n\n      if (xhr.status != 200 && xhr.status != 0) { // 0 if accessing with file://\n          console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\n          return false;\n      }\n      urlContentCache[url] = xhr.responseText;\n    }\n    return urlContentCache[url];\n}\nif (typeof global.urlContentCache == 'undefined')\n  global.urlContentCache = {};\n\n/**\n * Read qmldir spec file at directory. EXPORTED.\n * @param url Url of the directory\n * @return {Object} Object, where .internals lists qmldir internal references\n *                          and .externals lists qmldir external references.\n */\n\n/*  Note on how importing works.\n\n   * parseQML gives us `tree.$imports` variable, which contains information from `import` statements.\n\n   * After each call to parseQML, we call engine.loadImports(tree.$imports).\n     It in turn invokes readQmlDir() calls for each import, with respect to current component base path and engine.importPathList().\n\n   * We keep all component names from all qmldir files in global variable `engine.qmldir`.\n   \n   * In construct() function, we use `engine.qmldir` for component url lookup.\n\n   Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html \n   Also please look at notes and TODO's in qtcore.js::loadImports() and qtcore.js::construct() methods.\n*/\n \nreadQmlDir = function (url) {\n    // in case 'url' is empty, do not attach \"/\"\n    // Q1: when this happen?\n    var qmldirFileUrl = url.length > 0 ? (url + \"/qmldir\") : \"qmldir\";\n\n    if (!qrc.hasOwnProperty(qmldirFileUrl))\n      qrc[qmldirFileUrl] = getUrlContents(qmldirFileUrl, true); // loading url contents with skipping errors\n    var qmldir = qrc[qmldirFileUrl],\n        lines,\n        line,\n        internals = {},\n        externals = {},\n        match,\n        i;\n\n    if (qmldir === false) {\n        return false;\n    }\n\n    // we have to check for \"://\" \n    // In that case, item path is meant to be absolute, and we have no need to prefix it with base url\n    function makeurl( path ) {\n       if (path.indexOf(\"://\") > 0) return path;\n       return url + \"/\" + path;\n    }\n\n    lines = qmldir.split(/\\r?\\n/);\n    for (i = 0; i < lines.length; i++) {\n        // trim\n        line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n        if (!line.length || line[0] == \"#\") {\n            // Empty line or comment\n            continue;\n        }\n        match = line.split(/\\s+/);\n        if (match.length == 2 || match.length == 3) {\n            if (match[0] == \"plugin\") {\n                console.log(url + \": qmldir plugins are not supported!\");\n            } else if (match[0] == \"internal\") {\n                internals[match[1]] = { url: makeurl( match[2] ) };\n            } else {\n                if (match.length == 2) {\n                    externals[match[0]] = { url: makeurl( match[1] ) };\n                } else {\n                    externals[match[0]] = { url: makeurl( match[2] ), version: match[1] };\n                }\n            }\n        } else {\n            console.log(url + \": unmatched: \" + line);\n        }\n    }\n    return {internals: internals, externals: externals};\n}\n","global.addEventListener('load', function() {\n  var metaTags = document.getElementsByTagName('BODY');\n\n  for (var i = 0 ; i < metaTags.length ; ++i) {\n    var metaTag = metaTags[i];\n    var source  = metaTag.getAttribute('data-qml');\n\n    if (source != null) {\n      global.qmlEngine = new QMLEngine();\n      qmlEngine.loadFile(source);\n      qmlEngine.start();\n      break ;\n    }\n  }\n});\n","  global.importJavascriptInContext = function (jsData, $context) {\n    /* Remove any \".pragma\" statements, as they are not valid JavaScript */\n    var source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\n    // TODO: pass more objects to the scope?\n    (new Function('jsData', '$context', `\n      with ($context) {\n        ${source}\n      }\n      ${jsData.exports.map(sym => `$context.${sym} = ${sym};`).join('')}\n    `))(jsData, $context);\n  }\n","/*\n * - QMLEngine(element, options) -- Returns new qml engine object, for which:\n *   - loadFile(file) -- Load file to the engine (.qml or .qml.js atm)\n *   - start() -- start the engine/application\n *   - stop() -- stop the engine/application. Restarting is experimental.\n *   element is HTMLCanvasElement and options are for debugging.\n *   For further reference, see testpad and qml viewer applications.\n */\n\n// There can only be one running QMLEngine. This variable points to the currently running engine.\nvar engine = null;\n\n// QML engine. EXPORTED.\nQMLEngine = function (element, options) {\n//----------Public Members----------\n    this.fps = 60;\n    this.$interval = Math.floor(1000 / this.fps); // Math.floor, causes bugs to timing?\n    this.running = false;\n\n    // List of available Components\n    this.components = {};\n\n    this.rootElement = element;\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n\n//----------Public Methods----------\n    // Start the engine\n    this.start = function()\n    {\n        engine = this;\n        var i;\n        if (this.operationState !== QMLOperationState.Running) {\n            this.operationState = QMLOperationState.Running;\n            tickerId = setInterval(tick, this.$interval);\n            for (i = 0; i < whenStart.length; i++) {\n                whenStart[i]();\n            }\n        }\n    }\n\n    // Stop the engine\n    this.stop = function()\n    {\n        var i;\n        if (this.operationState == QMLOperationState.Running) {\n            clearInterval(tickerId);\n            this.operationState = QMLOperationState.Idle;\n            for (i = 0; i < whenStop.length; i++) {\n                whenStop[i]();\n            }\n        }\n    }\n\n\n    this.ensureFileIsLoadedInQrc = function(file) {\n      if (!qrc.hasOwnProperty(file)) {\n        var src = getUrlContents(file);\n\n        if (src) {\n            loadParser();\n            console.log('Loading file [', file, ']');\n            qrc[file] = qmlweb_parse(src, qmlweb_parse.QMLDocument);\n        } else {\n            console.log('Can not load file [', file, ']');\n        }\n      }\n    }\n\n    this.extractBasePath = function( file ) {\n       var basePath = file.split(/[\\/\\\\]/); // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n       basePath[basePath.length - 1] = \"\";\n       basePath = basePath.join(\"/\");\n       return basePath;\n    }\n    // Load file, parse and construct (.qml or .qml.js)\n    this.loadFile = function(file, parentComponent = null) {\n        var tree;\n\n        this.$basePath = this.extractBasePath(file);\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        return this.loadQMLTree(tree, parentComponent, file);\n    }\n\n    // parse and construct qml\n    this.loadQML = function(src, parentComponent = null, file = undefined) { // file is not required; only for debug purposes\n        return this.loadQMLTree(parseQML(src, file), parentComponent, file);\n    }\n\n    this.loadQMLTree = function(tree, parentComponent = null, file = undefined) {\n        engine = this;\n        if (options.debugTree) {\n            options.debugTree(tree);\n        }\n\n        // Create and initialize objects\n        const QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        var component = new QMLComponent({ object: tree, parent: parentComponent });\n\n        this.loadImports( tree.$imports, undefined, component.importContextId );\n        component.$basePath = engine.$basePath;\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // just for debugging\n\n        this.rootObject = component.createObject(parentComponent);\n        component.finalizeImports(this.rootContext());\n        this.$initializePropertyBindings();\n\n        this.start();\n\n        this.callCompletedSignals();\n\n        return component;\n    }\n\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\n     *\n     * Removes dot segments in given path component, as described in\n     * RFC 3986, section 5.2.4.\n     *\n     * @param {string} path A non-empty path component.\n     * @return {string} Path component with removed dot segments.\n     */\n    this.removeDotSegments = function(path) {\n        var leadingSlash = (path && path[0] == \"/\");   // path.startsWith('/'); -- startsWith seems to be undefined in some browsers\n        var segments = path.split('/');\n        var out = [];\n\n        for (var pos = 0; pos < segments.length; ) {\n            var segment = segments[pos++];\n\n            if (segment == '.') {\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else if (segment == '..') {\n                if (out.length > 1 || out.length == 1 && out[0] != '') {\n                    out.pop();\n                }\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else {\n                out.push(segment);\n                leadingSlash = true;\n            }\n        }\n\n        return out.join('/');\n    };\n\n    /*\n      engine.loadImports( imports, currentDir ) : performs loading of qmldir files from given qml import records.\n\n      Input:\n      * parameter `importsArray` - import statements. It is in parser notation, e.g. [import1, import2, ...] where each importN is also array: [\"qmlimport\",\"name\",version,as,isQualifiedName]\n      * parameter `currentFileDir` - base dir for imports lookup. It will be used together with importPathList()\n\n      Implicit input:\n      * engine object function `importPathList()` - list of urls bases used for qmldir files lookup\n\n      Additional implicit input/output:\n      * engine object variable `qmldirsContents` - used for caching, e.g. memory for previously loaded qmldir files\n\n      Output: \n      * engine object variable `qmldirs` - new records will be added there\n\n      Return value: \n      * nothing\n\n      Details:\n\n      For each of given import statements, loadImports \n      1. computes qmldir file location according to http://doc.qt.io/qt-5/qtqml-syntax-imports.html\n      2. calls `readQmlDir` for actual reading and parsing of qmldir file content\n      3. gets `external` declarations of that qmldir file and pushes them to `engine.qmldirs` hash.\n\n      `engine.qmldirs` is a hash of form: { componentName => componentFileUrl }\n      This hash then used by `qml.js::construct` method for computing component urls.\n\n      Notes:\n      1. This method is not suited for loading js imports. This may be done probably after answering to Q1 (below).\n      2. Please look for additional notes at readQmlDir function.\n\n      QNA\n      Q1: How and where in engine component names might be prefixed? E.g. names with dot inside: SomeModule.Component1\n      A1: Seems it doesn't matter. Seems we may just save name with dot-inside right to qmldirs, and it may be used by construct() seamlessly. Check it..\n\n      Q2: How we may access component object from here, to store qmldirs info in components logical scope, and not at engine scope?\n      A2: Probably, answer is in Component.js and in global.loadImports\n\n      TODO \n      * We have to keep output in component scope, not in engine scope.\n      * We have to add module \"as\"-names to component's names (which is possible after keeping imports in component scope).\n      * Determine how this stuff is related to `global.loadImports`\n      * Check A1\n      * Make a complete picture of what going in with imports, including Component.js own imports loading\n      * Note importJs method in import.js \n    */\n\n    this.loadImports = function(importsArray, currentFileDir, importContextId) {\n        if (!this.qmldirsContents) {\n            this.qmldirsContents = {}; // cache\n\n            // putting initial keys in qmldirsContents - is a hack. We should find a way to explain to qmlweb, is this built-in module or qmldir-style module.\n            for (const module in modules) {\n                if (module !== 'Main') {\n                    this.qmldirsContents[module] = {};\n                }\n            }\n        }\n\n        if (!this.qmldirs) this.qmldirs = {};                 // resulting components lookup table\n\n        if (!importsArray || importsArray.length == 0) return;\n        if (!currentFileDir) currentFileDir = this.$basePath;     // use this.$basePath by default\n\n        for (var i=0; i<importsArray.length; i++) {\n            var entry = importsArray[i];\n\n            var name = entry[1];\n\n            var nameIsUrl = name.indexOf(\"//\") == 0 || name.indexOf(\"://\") >= 0;  // is it url to remote resource\n            var nameIsQualifiedModuleName = entry[4]; // e.g. QtQuick, QtQuick.Controls, etc\n            var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl; // local [relative] dir\n\n            if (nameIsDir) {\n                // resolve name from relative to full dir path\n                // we hope all dirs are relative\n                if (currentFileDir && currentFileDir.length > 0)\n                  name = this.removeDotSegments( currentFileDir + name );\n                if (name[ name.length-1 ] == \"/\")\n                    name = name.substr( 0, name.length-1 ); // remove trailing slash as it required for `readQmlDir`\n            }\n            // TODO if nameIsDir, we have also to add `name` to importPathList() for current component...\n\n            // check if we have already loaded that qmldir file\n            if (this.qmldirsContents[ name ]) continue;\n\n            var content = false;\n            if (nameIsQualifiedModuleName && this.userAddedModulePaths && this.userAddedModulePaths[ name ]) {\n                // 1. we have qualified module and user had configured path for that module with this.addModulePath\n                content = readQmlDir( this.userAddedModulePaths[ name ] );\n            }\n            else if (nameIsUrl || nameIsDir)\n            {\n                // 2. direct load\n                // nameIsUrl => url do not need dirs\n                // nameIsDir => already computed full path above\n                content = readQmlDir( name );\n            }\n            else\n            {\n                // 3. qt-style lookup for qualified module\n                var probableDirs = [currentFileDir].concat( this.importPathList() )\n                var diredName = name.replace( /\\./g,\"/\" );\n\n                for (var k=0; k<probableDirs.length; k++) {\n                    var file = probableDirs[k] + diredName;\n                    content = readQmlDir( file );\n                    if (content) break;\n                }\n            }\n\n            if (!content) {\n               // NEW\n               // add that dir to import path list\n               // that means, lookup qml files in that failed dir by trying to load them directly\n               // this is not the same behavior as in Qt for \"url\" schemes,\n               // but it is same as for ordirnal disk files. \n               // So, we do it for experimental purposes.\n               if (nameIsDir) {\n                 if (entry[3]) {\n                   /* Use entry[1] directly, as we don't want to include the\n                    * basePath, otherwise it gets prepended twice in\n                    * createComponent. */\n                   this.addQualifiedImportPath( importContextId, entry[3], entry[1] + \"/\" );\n                 } else {\n                   this.addImportPath( name + \"/\" );\n                 }\n               }\n\n               continue;\n            }\n\n            // copy founded externals to global var\n            // TODO actually we have to copy it to current component\n            for (var attrname in content.externals) { this.qmldirs[attrname] = content.externals[attrname]; }\n\n            // keep already loaded qmldir files\n            this.qmldirsContents[ name ] = content;\n        }\n\n    }\n\n    this.rootContext = function() {\n      return this.rootObject.$context;\n    }\n\n    this.focusedElement = (function() {\n      return this.rootContext().activeFocus;\n    }).bind(this);\n\n    // KEYBOARD MANAGEMENT\n    var keyboardSignals = {};\n    keyboardSignals[Qt.Key_Asterisk]   = 'asteriskPressed';\n    keyboardSignals[Qt.Key_Back]       = 'backPressed';\n    keyboardSignals[Qt.Key_Backtab]    = 'backtabPressed';\n    keyboardSignals[Qt.Key_Call]       = 'callPressed';\n    keyboardSignals[Qt.Key_Cancel]     = 'cancelPressed';\n    keyboardSignals[Qt.Key_Delete]     = 'deletePressed';\n    keyboardSignals[Qt.Key_0]          = 'digit0Pressed';\n    keyboardSignals[Qt.Key_1]          = 'digit1Pressed';\n    keyboardSignals[Qt.Key_2]          = 'digit2Pressed';\n    keyboardSignals[Qt.Key_3]          = 'digit3Pressed';\n    keyboardSignals[Qt.Key_4]          = 'digit4Pressed';\n    keyboardSignals[Qt.Key_5]          = 'digit5Pressed';\n    keyboardSignals[Qt.Key_6]          = 'digit6Pressed';\n    keyboardSignals[Qt.Key_7]          = 'digit7Pressed';\n    keyboardSignals[Qt.Key_8]          = 'digit8Pressed';\n    keyboardSignals[Qt.Key_9]          = 'digit9Pressed';\n    keyboardSignals[Qt.Key_Escape]     = 'escapePressed';\n    keyboardSignals[Qt.Key_Flip]       = 'flipPressed';\n    keyboardSignals[Qt.Key_Hangup]     = 'hangupPressed';\n    keyboardSignals[Qt.Key_Menu]       = 'menuPressed';\n    keyboardSignals[Qt.Key_No]         = 'noPressed';\n    keyboardSignals[Qt.Key_Return]     = 'returnPressed';\n    keyboardSignals[Qt.Key_Select]     = 'selectPressed';\n    keyboardSignals[Qt.Key_Space]      = 'spacePressed';\n    keyboardSignals[Qt.Key_Tab]        = 'tabPressed';\n    keyboardSignals[Qt.Key_VolumeDown] = 'volumeDownPressed';\n    keyboardSignals[Qt.Key_VolumeUp]   = 'volumeUpPressed';\n    keyboardSignals[Qt.Key_Yes]        = 'yesPressed';\n    keyboardSignals[Qt.Key_Up]         = 'upPressed';\n    keyboardSignals[Qt.Key_Right]      = 'rightPressed';\n    keyboardSignals[Qt.Key_Down]       = 'downPressed';\n    keyboardSignals[Qt.Key_Left]       = 'leftPressed';\n\n    function keyCodeToQt(e) {\n      e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n      if (e.keyCode == Qt.Key_Tab && e.shiftKey == true)\n        return Qt.Key_Backtab;\n      else if (e.keyCode >= 97 && e.keyCode <= 122)\n        return e.keyCode - (97 - Qt.Key_A);\n      return e.keyCode;\n    }\n\n    function eventToKeyboard(e) {\n        return {\n            accepted: false,\n            count: 1,\n            isAutoRepeat: false,\n            key: keyCodeToQt(e),\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\n                    | (e.altKey   * Qt.AltModifier)\n                    | (e.shiftKey * Qt.ShiftModifier)\n                    | (e.metaKey  * Qt.MetaModifier)\n                    | (e.keypad   * Qt.KeypadModifier),\n            text: String.fromCharCode(e.charCode)\n        };\n    }\n\n    document.onkeypress = (function(e) {\n      var focusedElement = this.focusedElement();\n      var event          = eventToKeyboard(e || window.event);\n      var eventName      = keyboardSignals[event.key];\n\n      while (event.accepted != true && focusedElement != null) {\n        var backup       = focusedElement.$context.event;\n\n        focusedElement.$context.event = event;\n        focusedElement.Keys.pressed(event);\n        if (eventName != null)\n          focusedElement.Keys[eventName](event);\n        focusedElement.$context.event = backup;\n        if (event.accepted == true)\n          e.preventDefault();\n        else\n          focusedElement = focusedElement.$parent;\n      }\n    }).bind(this);\n\n    document.onkeyup = (function(e) {\n      var focusedElement = this.focusedElement();\n      var event          = eventToKeyboard(e || window.event);\n\n      while (event.accepted != true && focusedElement != null) {\n        var backup       = focusedElement.$context.event;\n\n        focusedElement.$context.event = event;\n        focusedElement.Keys.released(event);\n        focusedElement.$context.event = backup;\n        if (event.accepted == true)\n          e.preventDefault();\n        else\n          focusedElement = focusedElement.$parent;\n      }\n    }).bind(this);\n    // END KEYBOARD MANAGEMENT\n\n    this.registerProperty = function(obj, propName)\n    {\n        var dependantProperties = [];\n        var value = obj[propName];\n\n        function getter() {\n            if (evaluatingProperty && dependantProperties.indexOf(evaluatingProperty) == -1)\n                dependantProperties.push(evaluatingProperty);\n\n            return value;\n        }\n\n        function setter(newVal) {\n            value = newVal;\n\n            for (i in dependantProperties)\n                dependantProperties[i].update();\n        }\n\n        setupGetterSetter(obj, propName, getter, setter);\n    }\n\n    // next 3 methods used in Qt.createComponent for qml files lookup\n    // please open qt site for documentation\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n    this.addImportPath = function( dirpath ) {\n        if (!this.userAddedImportPaths) this.userAddedImportPaths = [];\n        this.userAddedImportPaths.push( dirpath );\n    }\n\n    this.addQualifiedImportPath = function(\n        importContextId, moduleQualifier, dirpath )\n    {\n        if ( !this.qualifiedImportPaths ) this.qualifiedImportPaths = {};\n        if ( !this.qualifiedImportPaths[importContextId] ) {\n            this.qualifiedImportPaths[importContextId] = {};\n        }\n        this.qualifiedImportPaths[importContextId][moduleQualifier] = dirpath;\n    }\n\n    this.qualifiedImportPath = function(\n        importContextId, moduleQualifier )\n    {\n        if ( !this.qualifiedImportPaths ) return \"\";\n        var importPathsForContext = this.qualifiedImportPaths[importContextId];\n        if ( !importPathsForContext ) return \"\";\n        return importPathsForContext[moduleQualifier] || \"\";\n    }\n\n    this.setImportPathList = function( arrayOfDirs )\n    {\n        this.userAddedImportPaths = arrayOfDirs;\n    }\n\n    this.importPathList = function() {\n        return (this.userAddedImportPaths || []);\n    }\n\n    // `addModulePath` defines conrete path for module lookup\n    // e.g. addModulePath( \"QtQuick.Controls\",\"http://someserver.com/controls\" )\n    // will force system to `import QtQuick.Controls` module from `http://someserver.com/controls/qmldir`\n\n    this.addModulePath = function( moduleName, dirPath ) {\n\n        // remove trailing slash as it required for `readQmlDir`\n        if (dirPath[ dirPath.length-1 ] == \"/\")\n            dirPath = dirPath.substr( 0, dirPath.length-1 );\n\n        // keep the mapping. It will be used in loadImports() function .\n        if (!this.userAddedModulePaths) this.userAddedModulePaths = {};\n        this.userAddedModulePaths[ moduleName ] = dirPath;\n    }\n\n//Intern\n\n    // Load file, parse and construct as Component (.qml)\n    this.loadComponent = function(name)\n    {\n        if (name in this.components)\n            return this.components[name];\n\n        var file = engine.$basePath + name + \".qml\";\n\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        this.components[name] = tree;\n        return tree;\n    }\n\n    this.$initializePropertyBindings = function() {\n        // Initialize property bindings\n        // we use `while`, because $initializePropertyBindings may be called recursive (because of Loader and/or createQmlObject )\n        while (this.bindedProperties.length > 0) {\n            var property = this.bindedProperties.shift();\n            if (!property.binding)\n              continue; // Probably, the binding was overwritten by an explicit value. Ignore.\n            if (property.needsUpdate)\n                property.update();\n            else if ([\"width\",\"height\",\"fill\",\"x\",\"y\",\"left\",\"right\",\"top\",\"bottom\"].indexOf(property.name) >= 0) {\n              // It is possible that bindings with these names was already evaluated during eval of other bindings\n              // but in that case updateHGeometry and updateVGeometry could be blocked during their eval.\n              // So we call them explicitly, just in case.\n\n              if (property.changed.isConnected(property.obj, updateHGeometry))\n                updateHGeometry.apply( property.obj,[property.val, property.val, property.name] );\n              if (property.changed.isConnected(property.obj, updateVGeometry))\n                updateVGeometry.apply( property.obj,[property.val, property.val, property.name] );\n            }\n        }\n\n        this.$initializeAliasSignals();\n    }\n\n    this.$initializeAliasSignals = function() {\n        // Perform pending operations. Now we use it only to init alias's \"changed\" handlers, that's why we have such strange function name.\n        while (this.pendingOperations.length > 0) {\n            var op = this.pendingOperations.shift();\n            op[0]( op[1], op[2], op[3] );\n        }\n        this.pendingOperations = [];\n    }\n\n    // Return a path to load the file\n    this.$resolvePath = function(file)\n    {\n        // probably, replace :// with :/ ?\n        if (file == \"\" || file.indexOf(\"://\") != -1 || file.indexOf(\"/\") == 0 || file.indexOf(\"data:\") == 0 || file.indexOf(\"blob:\") == 0) {\n            return file;\n        }\n        return this.$basePath + file;\n    }\n\n    this.$registerStart = function(f)\n    {\n        whenStart.push(f);\n    }\n\n    this.$registerStop = function(f)\n    {\n        whenStop.push(f);\n    }\n\n    this.$addTicker = function(t)\n    {\n        tickers.push(t);\n    }\n\n    this.$removeTicker = function(t)\n    {\n        var index = tickers.indexOf(t);\n        if (index != -1) {\n            tickers.splice(index, 1);\n        }\n    }\n\n    this.size = function()\n    {\n        return { width: this.rootObject.getWidth(), height: this.rootObject.getHeight() };\n    }\n\n//----------Private Methods----------\n\n    function tick()\n    {\n        var i,\n            now = (new Date).getTime(),\n            elapsed = now - lastTick;\n        lastTick = now;\n        for (i = 0; i < tickers.length; i++) {\n            tickers[i](now, elapsed);\n        }\n    }\n\n\n//----------Private Members----------\n    // Target canvas\n    var // Callbacks for stopping or starting the engine\n        whenStop = [],\n        whenStart = [],\n        // Ticker resource id and ticker callbacks\n        tickerId,\n        tickers = [],\n        lastTick = new Date().getTime(),\n        i;\n\n\n//----------Construct----------\n\n    options = options || {};\n\n    if (options.debugConsole) {\n        // Replace QML-side console.log\n        console = {};\n        console.log = function() {\n            var args = Array.prototype.slice.call(arguments);\n            options.debugConsole.apply(undefined, args);\n        };\n    }\n\n    // TODO: Move to module initialization\n    for (i in constructors) {\n        if (constructors[i].getAttachedObject)\n            setupGetter(QMLBaseObject.prototype, i, constructors[i].getAttachedObject);\n    }\n}\n\nQMLEngine.prototype.callCompletedSignals = function() {\n  // the while loop is better than for..in loop, because completedSignals array might change dynamically when\n  // some completed signal handlers will create objects dynamically via createQmlObject or Loader\n  while (this.completedSignals.length > 0) {\n     var handler = this.completedSignals.shift();\n     handler();\n  }\n};\n","QMLOperationState = {\n    Idle: 1,\n    Init: 2,\n    Running: 3\n};\n","global.qrc = {};\n","/**\n * Creates and returns a signal with the parameters specified in @p params.\n *\n * @param params Array with the parameters of the signal. Each element has to be\n *               an object with the two properties \"type\" and \"name\" specifying\n *               the datatype of the parameter and its name. The type is\n *               currently ignored.\n * @param options Options that allow finetuning of the signal.\n */\nglobal.Signal = function Signal(params, options) {\n    options = options || {};\n    var connectedSlots = [];\n    var obj = options.obj\n\n    var signal = function() {\n        pushEvalStack();\n        for (var i in connectedSlots)\n            try {\n                connectedSlots[i].slot.apply(connectedSlots[i].thisObj, arguments);\n            } catch(err) {\n                console.log(err.message);\n            }\n        popEvalStack();\n    };\n    signal.parameters = params || [];\n    signal.connect = function() {\n        if (arguments.length == 1)\n            connectedSlots.push({thisObj: global, slot: arguments[0]});\n        else if (typeof arguments[1] == 'string' || arguments[1] instanceof String) {\n            if (arguments[0].$tidyupList && arguments[0] !== obj)\n                arguments[0].$tidyupList.push(this);\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[0][arguments[1]]});\n        } else {\n            if (arguments[0].$tidyupList && (!obj || (arguments[0] !== obj && arguments[0] !== obj.$parent)))\n                arguments[0].$tidyupList.push(this);\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[1]});\n        }\n\n        // Notify object of connect\n        if (options.obj && options.obj.$connectNotify) {\n            options.obj.$connectNotify(options);\n        }\n\n    }\n    signal.disconnect = function() {\n        // callType meaning: 1 = function  2 = string  3 = object with string method  4 = object with function\n\n        var callType = arguments.length == 1 ? (arguments[0] instanceof Function ? 1 : 2)\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 3 : 4;\n        for (var i = 0; i < connectedSlots.length; i++) {\n            var item = connectedSlots[i];\n            if ((callType == 1 && item.slot == arguments[0])\n                || (callType == 2 && item.thisObj == arguments[0])\n                || (callType == 3 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\n            ) {\n                if (item.thisObj)\n                    item.thisObj.$tidyupList.splice(item.thisObj.$tidyupList.indexOf(this), 1);\n                connectedSlots.splice(i, 1);\n                i--; // We have removed an item from the list so the indexes shifted one backwards\n            }\n        }\n\n        // Notify object of disconnect\n        if (options.obj && options.obj.$disconnectNotify) {\n            options.obj.$disconnectNotify(options);\n        }\n    }\n    signal.isConnected = function() {\n        var callType = arguments.length == 1 ? 1\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 2 : 3;\n        for (var i in connectedSlots) {\n            var item = connectedSlots[i];\n            if ((callType == 1 && item.slot == arguments[0])\n                || (callType == 2 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\n            )\n                return true;\n        }\n        return false;\n    }\n    return signal;\n}\n\n","registerQmlType({\n  module:   'QmlWeb',\n  name:     'RestModel',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLRestModel(meta) {\n    callSuper(this, meta);\n    var self = this;\n    var attributes = this.getAttributes();\n\n    createProperty(\"string\", this, \"url\");\n    createProperty(\"bool\",   this, \"isLoading\");\n    createProperty(\"string\", this, \"mimeType\");\n    createProperty(\"string\", this, \"queryMimeType\");\n\n    this.mimeType      = \"application/json\";\n    this.queryMimeType = \"application/x-www-urlencoded\";\n    this.isLoading     = false;\n    this.attributes    = attributes;\n\n    this.fetched = Signal();\n    this.saved   = Signal();\n\n    this.runningRequests = 0;\n\n    this.fetch = function() {\n      ajax({\n        method:   'GET',\n        mimeType: self.mimetype,\n        success: function(xhr) {\n          xhrReadResponse(xhr);\n          self.fetched();\n        }\n      });\n    };\n\n    this.create = function() {\n      sendToServer('POST');\n    };\n\n    this.save = function() {\n      sendToServer('PUT');\n    };\n\n    function sendToServer(method) {\n      var body = generateBodyForPostQuery();\n\n      ajax({\n        method:   method,\n        mimeType: self.queryMimeType,\n        body:     body,\n        success:  function(xhr) {\n          xhrReadResponse(xhr);\n          self.saved();\n        }\n      });\n    }\n\n    this.remove = function() {\n      ajax({\n        method: 'DELETE',\n        success: function(xhr) {\n          self.destroy();\n        }\n      });\n    };\n\n    function generateBodyForPostQuery() {\n      var object     = {};\n      var body;\n\n      for (var i = 0 ; i < self.attributes.length ; ++i)\n        object[self.attributes[i]] = self.$properties[self.attributes[i]].get();\n      console.log(object);\n      if (self.queryMimeType == 'application/json' || self.queryMimeType == 'text/json')\n        body = JSON.stringify(object);\n      else if (self.queryMimeType == 'application/x-www-urlencoded')\n        body = objectToUrlEncoded(object);\n      return body;\n    }\n\n    function myEncodeURIComponent(str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16);\n      });\n    }\n\n    function objectToUrlEncoded(object, prefix) {\n      var str = '';\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = object[key];\n          if (str != '')\n            str += '&';\n          if (typeof prefix != 'undefined')\n            key  = prefix + '[' + key + ']';\n          if (typeof value == 'object')\n            str += objectToUrlEncoded(value, key);\n          else\n            str += myEncodeURIComponent(key) + '=' + myEncodeURIComponent(value);\n        }\n      }\n      return str;\n    }\n\n    function ajax(options) {\n      var xhr = new XMLHttpRequest();\n\n      xhr.overrideMimeType(self.mimeType);\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState == XMLHttpRequest.DONE) {\n          if (xhr.status == 200)\n            options.success(xhr);\n          else\n            options.failure(xhr);\n          self.runningRequests -= 1;\n          if (self.runningRequests <= 0)\n            self.isLoading = false;\n        }\n      }\n      xhr.open(options.method, self.url, true);\n      if (typeof options.body != 'undefined') {\n        xhr.setRequestHeader('Content-Type', self.queryMimeType);\n        xhr.send(options.body);\n      }\n      else\n        xhr.send(null);\n      self.runningRequests += 1;\n      self.isLoading = true;\n    }\n\n    function xhrReadResponse(xhr) {\n      var responseObject;\n\n      if (self.mimeType == 'application/json' || self.mimeType == 'text/json') {\n        responseObject = JSON.parse(xhr.responseText);\n      }\n      updatePropertiesFromResponseObject(responseObject);\n    }\n\n    function updatePropertiesFromResponseObject(responseObject) {\n      for (var key in responseObject) {\n        if (responseObject.hasOwnProperty(key) && self.$hasProperty(key)) {\n          self.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n        }\n      }\n    }\n\n    this.$hasProperty = function(name) {\n      return (typeof self.$properties[name] != 'undefined');\n    }\n  }\n});\n","registerQmlType({\n  module: 'Qt.labs.settings',\n  name:   'Settings',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLSettings(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"string\", this, \"category\");\n\n    if (typeof window.localStorage == 'undefined')\n      return ;\n\n    var attributes;\n\n    var getKey = (function(attrName) {\n      return this.category + '/' + attrName;\n    }).bind(this);\n\n    var loadProperties = (function() {\n      for (var i = 0 ; i < attributes.length ; ++i) {\n        this[attributes[i]] = localStorage.getItem(getKey(attributes[i]));\n      }\n    }).bind(this);\n\n    var initializeProperties = (function() {\n      for (var i = 0 ; i < attributes.length ; ++i) {\n        var attrName   = attributes[i];\n        var signalName = attrName + 'Changed';\n        var emitter    = this;\n\n        if (this.$properties[attrName].type == 'alias') {\n          emitter    = this.$context[this.$properties[attrName].val.objectName];\n          signalName = this.$properties[attrName].val.propertyName + 'Changed';\n        }\n        emitter[signalName].connect(this, (function() {\n          localStorage.setItem(getKey(this.attrName), this.self[this.attrName]);\n        }).bind({ self: this, attrName: attrName }));\n      }\n    }).bind(this);\n\n    this.Component.completed.connect(this, (function() {\n      attributes = this.getAttributes();\n      loadProperties();\n      initializeProperties();\n    }).bind(this));\n  }\n});\n","registerQmlType({\n  module:   'QtGraphicalEffects',\n  name:     'FastBlur',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLFastBlur(meta) {\n    callSuper(this, meta);\n\n    var previousSource = null;\n    var filterObject;\n\n    createProperty(\"real\", this, \"radius\");\n    createProperty(\"var\",  this, \"source\");\n    this.radius = 0;\n    this.source = null;\n\n    var updateFilterObject = (function() {\n      filterObject = {\n        transformType: 'filter',\n        operation:     'blur',\n        parameters:    this.radius + 'px'\n      };\n    }).bind(this);\n\n    function stripEffectFromSource(source) {\n      if (previousSource != null) {\n        var index = previousSource.transform.indexOf(filterObject);\n\n        previousSource.transform.splice(index, 1);\n        previousSource.$updateTransform();\n      }\n    }\n\n    function updateEffect(source) {\n      console.log(\"updating effect\");\n      stripEffectFromSource(previousSource);\n      if (source != null && typeof source.transform != 'undefined') {\n        updateFilterObject();\n        console.log(\"updating effect:\", filterObject, source);\n        source.transform.push(filterObject);\n        source.$updateTransform();\n        previousSource = source;\n      } else {\n        previousSource = null;\n      }\n    }\n\n    this.radiusChanged.connect(this, (function(newVal) {\n      updateEffect(this.source);\n    }).bind(this));\n\n    this.sourceChanged.connect(this, (function(newVal) {\n      updateEffect(this.source);\n    }).bind(this));\n  }\n});\n","registerQmlType({\n  module:   'QtMobility',\n  name:     'GeoLocation',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLGeoLocation(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    createProperty(\"double\", this, \"accuracy\");\n    createProperty(\"double\", this, \"altitude\");\n    createProperty(\"double\", this, \"altitudeAccuracy\");\n    createProperty(\"double\", this, \"heading\");\n    createProperty(\"string\", this, \"label\");\n    createProperty(\"double\", this, \"latitude\");\n    createProperty(\"double\", this, \"longitude\");\n    createProperty(\"double\", this, \"speed\");\n    createProperty(\"date\",   this, \"timestamp\");\n\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition\n    }\n\n    var updatePosition = (function(position) {\n      this.accuracy         = position.coords.accuracy;\n      this.altitude         = position.coords.altitude;\n      this.altitudeAccuracy = position.coords.altitudeAccuracy;\n      this.heading          = position.coords.heading;\n      this.latitude         = position.coords.latitude;\n      this.longitude        = position.coords.longitude;\n      this.speed            = position.coords.speed;\n      this.timestamp        = position.timestamp;\n    }).bind(this);\n\n    navigator.geolocation.getCurrentPosition(updatePosition);\n    navigator.geolocation.watchPosition(updatePosition);\n  }\n});\n","global.MediaPlayer = {\n  NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4, AccessDenied: 8, ServiceMissing: 16,\n  StoppedState: 0, PlayingState: 1, PausedState: 2,\n  NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8, EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n};\n\nglobal.VideoOutput = {\n  PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2\n};\n\nregisterQmlType({\n  module: 'QtMultimedia',\n  name:   'Video',\n  versions: /^5\\./,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLVideo(meta) {\n    callSuper(this, meta);\n\n    var runningEventListener = 0;\n    var volumeBackup;\n\n    const domVideo = this.impl = document.createElement('video');\n    domVideo.style.width = domVideo.style.height = \"100%\";\n    domVideo.style.margin = \"0\";\n    this.dom.appendChild(domVideo);\n\n    createProperty(\"bool\",   this, \"autoPlay\");\n    createProperty(\"enum\",   this, \"fillMode\");\n    createProperty(\"int\",    this, \"duration\");\n    createProperty(\"int\",    this, \"position\");\n    createProperty(\"bool\",   this, \"muted\");\n    createProperty(\"real\",   this, \"playbackRate\");\n    createProperty(\"enum\",   this, \"playbackState\");\n    createProperty(\"string\", this, \"source\");\n    createProperty(\"real\",   this, \"volume\");\n    createProperty(\"enum\",   this, \"status\");\n    createProperty(\"enum\",   this, \"error\");\n    this.status = MediaPlayer.NoMedia;\n    this.error = MediaPlayer.NoError;\n    this.fillMode = VideoOutput.PreserveAspectFit;\n    this.volume = domVideo.volume;\n    this.duration = domVideo.duration;\n    this.playbackState = MediaPlayer.StoppedState;\n    this.muted = false;\n\n    this.paused  = Signal();\n    this.playing = Signal();\n    this.stopped = Signal();\n\n    this.autoPlayChanged.connect(this, (function(newVal) {\n      domVideo.autoplay = newVal;\n    }).bind(this));\n\n    domVideo.addEventListener(\"play\", (function() {\n      this.playing();\n      this.playbackState = MediaPlayer.PlayingState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"pause\", (function() {\n      this.paused();\n      this.playbackState = MediaPlayer.PausedState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"timeupdate\", (function() {\n      runningEventListener++;\n      this.position = domVideo.currentTime * 1000;\n      runningEventListener--;\n    }).bind(this));\n\n    domVideo.addEventListener(\"ended\", (function() {\n      this.stopped();\n      this.playbackState = MediaPlayer.StoppedState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"progress\", (function() {\n      if (domVideo.buffered.length > 0) {\n        this.progress = domVideo.buffered.end(0) / domVideo.duration;\n        this.status   = this.progress < 1 ? MediaPlayer.Buffering : MediaPlayer.Buffered;\n      }\n    }).bind(this));\n\n    domVideo.addEventListener(\"stalled\", (function() {\n      this.status = MediaPlayer.Stalled;\n    }).bind(this));\n\n    domVideo.addEventListener(\"canplaythrough\", (function() {\n      this.status = MediaPlayer.Buffered;\n    }).bind(this));\n\n    domVideo.addEventListener(\"loadstart\", (function() {\n      this.status = MediaPlayer.Loading;\n    }).bind(this));\n\n    domVideo.addEventListener(\"durationchanged\", (function() {\n      this.duration = domVideo.duration;\n    }).bind(this));\n\n    domVideo.addEventListener(\"volumechanged\", (function() {\n      runningEventListener++;\n      this.volume = demoVideo.volume;\n      runningEventListener--;\n    }).bind(this));\n\n    domVideo.addEventListener(\"suspend\", (function() {\n      this.error |= MediaPlayer.NetworkError;\n    }).bind(this));\n\n    domVideo.addEventListener(\"error\", (function() {\n      this.error |= MediaPlayer.ResourceError;\n    }).bind(this));\n\n    domVideo.addEventListener(\"ratechange\", (function() {\n      runningEventListener++;\n      this.playbackRate = domVideo.playbackRate;\n      runningEventListener--;\n    }).bind(this));\n\n    this.pause = (function() {\n      domVideo.pause();\n    }).bind(this);\n\n    this.play = (function() {\n      domVideo.play();\n    }).bind(this);\n\n    this.seek = (function(offset) {\n      domVideo.currentTime = offset * 1000;\n    }).bind(this);\n\n    this.stop = (function() {\n    }).bind(this);\n\n    this.mimetypeFromExtension = function(extension) {\n      var mimetypes = {\n        ogg: 'video/ogg',\n        ogv: 'video/ogg',\n        ogm: 'video/ogg',\n        mp4: 'video/mp4',\n        webm: 'video/webm'\n      };\n\n      if (typeof mimetypes[extension] == 'undefined')\n        return \"\";\n      return mimetypes[extension];\n    };\n\n    this.sourceChanged.connect(this, (function(source) {\n      var parts     = source.split('.');\n      var extension = parts[parts.length - 1];\n\n      domVideo.src = source;\n      if (domVideo.canPlayType(this.mimetypeFromExtension(extension.toLowerCase())) == \"\")\n        this.error |= MediaPlayer.FormatError;\n    }).bind(this));\n\n    this.positionChanged.connect(this, (function(currentTime) {\n      if (runningEventListener == 0)\n        domVideo.currentTime = currentTime / 1000;\n    }).bind(this));\n\n    this.volumeChanged.connect(this, (function(volume) {\n      if (runningEventListener == 0)\n        domVideo.volume = volume;\n    }).bind(this));\n\n    this.playbackRateChanged.connect(this, (function(playbackRate) {\n      if (runningEventListener == 0)\n        domVideo.playbackRate = playbackRate;\n    }).bind(this));\n\n    this.mutedChanged.connect(this, (function(newValue) {\n      if (newValue == true) {\n        volulmeBackup = domVideo.volume;\n        this.volume = 0;\n      } else {\n        this.volume = volumeBackup;\n      }\n    }).bind(this));\n\n    this.fillModeChanged.connect(this, (function(newValue) {\n      switch (newValue) {\n        case VideoOutput.Stretch:\n          domVideo.style.objectFit = 'fill';\n          break ;\n        case VideoOutput.PreserveAspectFit:\n          domVideo.style.objectFit = '';\n          break ;\n        case VideoOutput.PreserveAspectCrop:\n          domVideo.style.objectFit = 'cover';\n          break ;\n      }\n    }).bind(this));\n  }\n});\n","registerQmlType({\n  module: 'QtQml',\n  name: 'Connections',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  properties: {\n    target: 'QtObject',\n    ignoreUnknownSignals: 'bool'\n  }\n}, class {\n  constructor(meta) {\n    callSuper(this, meta);\n    this.target = this.$parent\n    this.$connections = {}\n\n    let old_target = this.target;\n    const reconnectTarget = () => {\n      for (var i in this.$connections) {\n        var c = this.$connections[i];\n        if (c._currentConnection && old_target && old_target[i] && typeof old_target[i].disconnect === 'function') {\n          old_target[i].disconnect(c._currentConnection);\n        }\n        c._currentConnection = connectSignal(this.target, i, c.value, c.objectScope, c.componentScope);\n      }\n      old_target = this.target;\n    };\n\n    this.targetChanged.connect(reconnectTarget);\n    this.Component.completed.connect(reconnectTarget);\n  }\n  $setCustomSlot(propName, value, objectScope, componentScope) {\n    this.$connections[propName] = { value, objectScope, componentScope };\n  }\n});\n","global.Qt = {\n  rgba: function(r,g,b,a) {\n    return \"rgba(\"\n      + Math.round(r * 255) + \",\"\n      + Math.round(g * 255) + \",\"\n      + Math.round(b * 255) + \",\"\n      + a + \")\";\n  },\n  hsla: function(h,s,l,a) {\n    return \"hsla(\"\n      + Math.round(h * 360) + \",\"\n      + Math.round(s * 100) + \"%,\"\n      + Math.round(l * 100) + \"%,\"\n      + a + \")\";\n  },\n  openUrlExternally: function(url) {\n    page = window.open(url, '_blank');\n    page.focus();\n  },\n  // Load file, parse and construct as Component (.qml)\n  createComponent: function(name) {\n    if (name in engine.components)\n        return engine.components[name];\n\n    var nameIsUrl = name.indexOf(\"//\") >= 0 || name.indexOf(\":/\") >= 0; // e.g. // in protocol, or :/ in disk urls (D:/)\n\n    // Do not perform path lookups if name starts with @ sign.\n    // This is used when we load components from qmldir files\n    // because in that case we do not need any lookups.\n    var origName = name;\n    if (name.length > 0 && name[0] == \"@\") {\n      nameIsUrl = true;\n      name = name.substr( 1,name.length-1 );\n    }\n\n    var file = nameIsUrl ? name : engine.$basePath + name;\n\n    var src = getUrlContents(file, true);\n    // if failed to load, and provided name is not direct url, try to load from dirs in importPathList()\n    if (src==false && !nameIsUrl) {\n      var moredirs = engine.importPathList();\n\n      for (var i=0; i<moredirs.length; i++) {\n        file = moredirs[i] + name;\n        src = getUrlContents(file, true);\n        if (src !== false) break;\n      }\n    }\n\n    // When createComponent failed to load content from all probable sources, it should return undefined.\n    if (src === false)\n      return undefined;\n\n    var tree = parseQML(src, file);\n\n    if (tree.$children.length !== 1)\n        console.error(\"A QML component must only contain one root element!\");\n\n    const QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n    var component = new QMLComponent({ object: tree, context: _executionContext });\n    component.$basePath = engine.extractBasePath( file );\n    component.$imports = tree.$imports;\n    component.$file = file; // just for debugging\n\n    engine.loadImports( tree.$imports, component.$basePath, component.importContextId );\n\n    engine.components[origName] = component;\n    return component;\n  },\n\n  createQmlObject: function(src, parent, file) {\n        var tree = parseQML(src, file);\n\n        // Create and initialize objects\n\n        const QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n        var component = new QMLComponent({ object: tree, parent: parent, context: _executionContext });\n\n        engine.loadImports( tree.$imports, undefined, component.importContextId );\n\n        if (!file) file = Qt.resolvedUrl(\"createQmlObject_function\");\n        component.$basePath = engine.extractBasePath(file);\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // not just for debugging, but for basepath too, see above\n\n        var obj = component.createObject(parent);\n        obj.parent = parent;\n        parent.childrenChanged();\n\n        if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n          // We don't call those on first creation, as they will be called\n          // by the regular creation-procedures at the right time.\n          engine.$initializePropertyBindings();\n\n          engine.callCompletedSignals();\n        }\n\n        return obj;\n  },\n\n    // Returns url resolved relative to the URL of the caller.\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n  resolvedUrl: function(url)\n  {\n    if (!url || !url.substr) // url is not a string object\n      return url;\n\n    // Must check for cases: D:/, file://, http://, or slash at the beginning. \n    // This means the url is absolute => we have to skip processing (except removing dot segments).\n    if (url == \"\" || url.indexOf(\":/\") != -1 || url.indexOf(\"/\") == 0)\n      return engine.removeDotSegments( url );\n\n    // we have $basePath variable placed in context of \"current\" document\n    // this is done in construct() function\n\n    // let's go to the callers and inspect their arguments\n    // The 2-nd argument of the callers we hope is context object\n    // e.g. see calling signature of bindings and signals\n\n    var detectedBasePath = \"\";\n    var currentCaller = Qt.resolvedUrl.caller;\n    var maxcount = 10;\n    while (maxcount-- > 0 && currentCaller) {\n      if (currentCaller.arguments[1] && currentCaller.arguments[1][\"$basePath\"])\n      {\n        detectedBasePath = currentCaller.arguments[1][\"$basePath\"];\n        break;\n      }\n      currentCaller = currentCaller.caller;\n    }\n\n    return engine.removeDotSegments( detectedBasePath + url )\n  },\n\n  // Buttons masks\n  LeftButton: 1,\n  RightButton: 2,\n  MiddleButton: 4,\n  // Modifiers masks\n  NoModifier: 0,\n  ShiftModifier: 1,\n  ControlModifier: 2,\n  AltModifier: 4,\n  MetaModifier: 8,\n  KeypadModifier: 16, // Note: Not available in web\n  // Layout directions\n  LeftToRight: 0,\n  RightToLeft: 1,\n  // Orientations\n  Vertical: 0,\n  Horizontal: 1,\n  // Keys\n  Key_Escape: 27,\n  Key_Tab: 9,\n  Key_Backtab: 245,\n  Key_Backspace: 8,\n  Key_Return: 13,\n  Key_Enter: 13,\n  Key_Insert: 45,\n  Key_Delete: 46,\n  Key_Pause: 19,\n  Key_Print: 42,\n  Key_SysReq: 0,\n  Key_Clear: 12,\n  Key_Home: 36,\n  Key_End: 35,\n  Key_Left: 37,\n  Key_Up: 38,\n  Key_Right: 39,\n  Key_Down: 40,\n  Key_PageUp: 33,\n  Key_PageDown: 34,\n  Key_Shift: 16,\n  Key_Control: 17,\n  Key_Meta: 91,\n  Key_Alt: 18,\n  Key_AltGr: 0,\n  Key_CapsLock: 20,\n  Key_NumLock: 144,\n  Key_ScrollLock: 145,\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117, Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122, Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127, Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132, Key_F22: 133, Key_F23: 134, Key_F24: 135, Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0, Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n  Key_Super_L: 0,\n  Key_Super_R: 0,\n  Key_Menu: 0,\n  Key_Hyper_L: 0,\n  Key_Hyper_R: 0,\n  Key_Help: 6,\n  Key_Direction_L: 0,\n  Key_Direction_R: 0,\n  Key_Space: 32,\n  Key_Any:   32,\n  Key_Exclam: 161,\n  Key_QuoteDbl: 162,\n  Key_NumberSign: 163,\n  Key_Dollar: 164,\n  Key_Percent: 165,\n  Key_Ampersant: 166,\n  Key_Apostrophe: 222,\n  Key_ParenLeft: 168,\n  Key_ParenRight: 169,\n  Key_Asterisk: 170,\n  Key_Plus: 171,\n  Key_Comma: 188,\n  Key_Minus: 173,\n  Key_Period: 190,\n  Key_Slash: 191,\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52, Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n  Key_Colon: 58,\n  Key_Semicolon: 59,\n  Key_Less: 60,\n  Key_Equal: 61,\n  Key_Greater: 62,\n  Key_Question: 63,\n  Key_At: 64,\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71, Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78, Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85, Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n  Key_BracketLeft: 219,\n  Key_Backslash: 220,\n  Key_BracketRight: 221,\n  Key_AsciiCircum: 160,\n  Key_Underscore: 167,\n  Key_QuoteLeft: 0,\n  Key_BraceLeft: 174,\n  Key_Bar: 172,\n  Key_BraceRight: 175,\n  Key_AsciiTilde: 176,\n  Key_Back: 0,\n  Key_Forward: 0,\n  Key_Stop: 0,\n  Key_VolumeDown: 182,\n  Key_VolumeUp: 183,\n  Key_VolumeMute: 181,\n  Key_multiply: 106,\n  Key_add: 107,\n  Key_substract: 109,\n  Key_divide: 111,\n  Key_News: 0,\n  Key_OfficeHome: 0,\n  Key_Option: 0,\n  Key_Paste: 0,\n  Key_Phone: 0,\n  Key_Calendar: 0,\n  Key_Reply: 0,\n  Key_Reload: 0,\n  Key_RotateWindows: 0,\n  Key_RotationPB: 0,\n  Key_RotationKB: 0,\n  Key_Save: 0,\n  Key_Send: 0,\n  Key_Spell: 0,\n  Key_SplitScreen: 0,\n  Key_Support: 0,\n  Key_TaskPane: 0,\n  Key_Terminal: 0,\n  Key_Tools: 0,\n  Key_Travel: 0,\n  Key_Video: 0,\n  Key_Word: 0,\n  Key_Xfer: 0,\n  Key_ZoomIn: 0,\n  Key_ZoomOut: 0,\n  Key_Away: 0,\n  Key_Messenger: 0,\n  Key_WebCam: 0,\n  Key_MailForward: 0,\n  Key_Pictures: 0,\n  Key_Music: 0,\n  Key_Battery: 0,\n  Key_Bluetooth: 0,\n  Key_WLAN: 0,\n  Key_UWB: 0,\n  Key_AudioForward: 0,\n  Key_AudioRepeat: 0,\n  Key_AudioRandomPlay: 0,\n  Key_Subtitle: 0,\n  Key_AudioCycleTrack: 0,\n  Key_Time: 0,\n  Key_Hibernate: 0,\n  Key_View: 0,\n  Key_TopMenu: 0,\n  Key_PowerDown: 0,\n  Key_Suspend: 0,\n  Key_ContrastAdjust: 0,\n  Key_MediaLast: 0,\n  Key_unknown: -1,\n  Key_Call: 0,\n  Key_Camera: 0,\n  Key_CameraFocus: 0,\n  Key_Context1: 0,\n  Key_Context2: 0,\n  Key_Context3: 0,\n  Key_Context4: 0,\n  Key_Flip: 0,\n  Key_Hangup: 0,\n  Key_No: 0,\n  Key_Select: 93,\n  Key_Yes: 0,\n  Key_ToggleCallHangup: 0,\n  Key_VoiceDial: 0,\n  Key_LastNumberRedial: 0,\n  Key_Execute: 43,\n  Key_Printer: 42,\n  Key_Play: 250,\n  Key_Sleep: 95,\n  Key_Zoom: 251,\n  Key_Cancel: 3,\n  // Align\n  AlignLeft: 0x0001,\n  AlignRight: 0x0002,\n  AlignHCenter: 0x0004,\n  AlignJustify: 0x0008,\n  AlignTop: 0x0020,\n  AlignBottom: 0x0040,\n  AlignVCenter: 0x0080,\n  AlignCenter: 0x0084,\n  AlignBaseline: 0x0100,\n  AlignAbsolute: 0x0010,\n  AlignLeading: 0x0001,\n  AlignTrailing: 0x0002,\n  AlignHorizontal_Mask: 0x001f,\n  AlignVertical_Mask: 0x01e0,\n  // Screen\n  PrimaryOrientation: 0,\n  PortraitOrientation: 1,\n  LandscapeOrientation: 2,\n  InvertedPortraitOrientation: 4,\n  InvertedLandscapeOrientation: 8,\n  // CursorShape\n  ArrowCursor: 0,\n  UpArrowCursor: 1,\n  CrossCursor: 2,\n  WaitCursor: 3,\n  IBeamCursor: 4,\n  SizeVerCursor: 5,\n  SizeHorCursor: 6,\n  SizeBDiagCursor: 7,\n  SizeFDiagCursor: 8,\n  SizeAllCursor: 9,\n  BlankCursor: 10,\n  SplitVCursor: 11,\n  SplitHCursor: 12,\n  PointingHandCursor: 13,\n  ForbiddenCursor: 14,\n  WhatsThisCursor: 15,\n  BusyCursor: 16,\n  OpenHandCursor: 17,\n  ClosedHandCursor: 18,\n  DragCopyCursor: 19,\n  DragMoveCursor: 20,\n  DragLinkCursor: 21,\n  LastCursor: 21, //DragLinkCursor,\n  BitmapCursor: 24,\n  CustomCursor: 25,\n  // ScrollBar Policy\n  ScrollBarAsNeeded: 0,\n  ScrollBarAlwaysOff: 1,\n  ScrollBarAlwaysOn: 2\n}\n","registerQmlType({\n  module:   'QtQml',\n  name:     'Timer',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLTimer(meta) {\n    callSuper(this, meta);\n    var prevTrigger,\n        self = this;\n\n    createProperty(\"int\", this, \"interval\", {initialValue: 1000});\n    createProperty(\"bool\", this, \"repeat\");\n    createProperty(\"bool\", this, \"running\");\n    createProperty(\"bool\", this, \"triggeredOnStart\");\n\n    // Create trigger as simple property. Reading the property triggers\n    // the function!\n    this.triggered = Signal();\n\n    engine.$addTicker(ticker);\n    function ticker(now, elapsed) {\n        if (self.running) {\n            if (now - prevTrigger >= self.interval) {\n                prevTrigger = now;\n                trigger();\n            }\n        }\n    }\n\n    /* This ensures that if the user toggles the \"running\" property manually,\n     * the timer will trigger. */\n    this.runningChanged.connect(this, function() {\n        if (this.running) {\n            prevTrigger = new Date().getTime();\n            if (this.triggeredOnStart) {\n                trigger();\n            }\n        }\n    })\n\n    this.start = function() {\n        this.running = true;\n    }\n    this.stop = function() {\n        this.running = false;\n    }\n    this.restart = function() {\n        this.stop();\n        this.start();\n    }\n\n    function trigger() {\n        if (!self.repeat)\n            // We set the value directly in order to be able to emit the runningChanged\n            // signal after triggered, like Qt does it.\n            self.$properties.running.val = false;\n\n        // Trigger this.\n        self.triggered();\n\n        if (!self.repeat)\n            // Emit changed signal manually after setting the value manually above.\n            self.runningChanged();\n    }\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by self.start();\n            self.start();\n        }\n    });\n\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick.Controls',\n  name:     'CheckBox',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLCheckbox(meta) {\n    callSuper(this, meta);\n\n    const label = this.impl = document.createElement('label');\n    label.style.pointerEvents = 'auto';\n\n    const checkbox = document.createElement('input');\n    checkbox.type = 'checkbox';\n    checkbox.style.verticalAlign = 'text-bottom';\n    label.appendChild(checkbox);\n\n    const span = document.createElement('span');\n    label.appendChild(span);\n\n    this.dom.appendChild(label);\n\n    var self = this;\n\n    const QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"bool\", this, \"checked\");\n    createProperty(\"color\", this, \"color\");\n\n    this.Component.completed.connect(this, function() {\n        this.implicitHeight = label.offsetHeight;\n        this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n    });\n    this.textChanged.connect(this, function(newVal) {\n        span.innerHTML = newVal;\n        this.implicitHeight = label.offsetHeight;\n        this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n    });\n    this.colorChanged.connect(this, function(newVal) {\n        span.style.color = QMLColor(newVal);\n    });\n\n    this.checkedChanged.connect(this, function(newVal) {\n        checkbox.checked = self.checked;\n    });\n\n    checkbox.onchange = function() {\n        self.checked = this.checked;\n    };\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'AnimatedImage',\n  versions: /.*/,\n  baseClass: 'Image',\n  constructor: function QMLAnimatedImage(meta) {\n    callSuper(this, meta);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name: 'Animation',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  enums: {\n    Animation: {\n      Infinite: -1\n    }\n  },\n  properties: {\n    alwaysRunToEnd: 'bool',\n    loops: { type: 'int', initialValue: 1 },\n    paused: 'bool',\n    running: 'bool'\n  }\n}, class {\n  constructor(meta) {\n    callSuper(this, meta);\n  }\n  restart() {\n    this.stop();\n    this.start();\n  }\n  start() {\n    this.running = true;\n  }\n  stop() {\n    this.running = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    this.paused = false;\n  }\n  complete() {\n    // To be overridden\n    console.log('Unbound method for', this);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Behavior',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLBehavior(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"Animation\", this, \"animation\");\n    this.$defaultProperty = \"animation\";\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n\n    this.animationChanged.connect(this, function(newVal) {\n        newVal.target = this.$parent;\n        newVal.property = meta.object.$on;\n        this.$parent.$properties[meta.object.$on].animation = newVal;\n    });\n    this.enabledChanged.connect(this, function(newVal) {\n        this.$parent.$properties[meta.object.$on].animation = newVal ? this.animation : null;\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'BorderImage',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLBorderImage(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.BorderImage = {\n        // tileMode\n        Stretch: \"stretch\",\n        Repeat: \"repeat\",\n        Round: \"round\",\n        // status\n        Null: 1,\n        Ready: 2,\n        Loading: 3,\n        Error: 4\n    }\n\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\", {initialValue: this.BorderImage.Null});\n    this.border = new QObject(this);\n    createProperty(\"int\", this.border, \"left\");\n    createProperty(\"int\", this.border, \"right\");\n    createProperty(\"int\", this.border, \"top\");\n    createProperty(\"int\", this.border, \"bottom\");\n    createProperty(\"enum\", this, \"horizontalTileMode\", {initialValue: this.BorderImage.Stretch});\n    createProperty(\"enum\", this, \"verticalTileMode\", {initialValue: this.BorderImage.Stretch});\n\n    this.sourceChanged.connect(this, function() {\n        this.dom.style.borderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n    });\n    this.border.leftChanged.connect(this, updateBorder);\n    this.border.rightChanged.connect(this, updateBorder);\n    this.border.topChanged.connect(this, updateBorder);\n    this.border.bottomChanged.connect(this, updateBorder);\n    this.horizontalTileModeChanged.connect(this, updateBorder);\n    this.verticalTileModeChanged.connect(this, updateBorder);\n\n    function updateBorder() {\n        this.dom.style.MozBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.MozBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.MozBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.MozBorderImageWidth = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left;\n\n        this.dom.style.webkitBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.webkitBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.webkitBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.webkitBorderImageWidth = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left;\n\n        this.dom.style.OBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.OBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.OBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.OBorderImageWidth = this.border.top + \"px \"\n                                                + this.border.right + \"px \"\n                                                + this.border.bottom + \"px \"\n                                                + this.border.left + \"px\";\n\n        this.dom.style.borderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.borderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.borderImageWidth = this.border.top + \"px \"\n                                                + this.border.right + \"px \"\n                                                + this.border.bottom + \"px \"\n                                                + this.border.left + \"px\";\n    }\n  }\n});\n","// TODO\n// Currently only a skeleton implementation\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Canvas',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function(meta) {\n        callSuper(this, meta);\n\n        var self = this;\n\n        createProperty('bool', this, 'available');\n        createProperty('var', this, 'canvasSize');\n        createProperty('var', this, 'canvasWindow');\n        createProperty('var', this, 'context');\n        createProperty('string', this, 'contextType');\n        createProperty('enum', this, 'renderStrategy');\n        createProperty('enum', this, 'renderTarget');\n        createProperty('var', this, 'tileSize');\n\n        this.available = true;\n        this.canvasSize = [0, 0];\n        this.canvasWindow = [0, 0, 0, 0];\n        this.context = {};\n        this.contextType = \"contextType\";\n        this.renderStrategy = 0;\n        this.renderTarget = 0;\n        this.tileSize = [0, 0];\n\n        this.imageLoaded = Signal();\n        this.paint = Signal([{type: \"var\", name: \"region\"}]);\n        this.painted = Signal();\n\n        this.cancelRequestAnimationFrame = function(handle) {\n            return false;\n        };\n\n        this.getContext = function(context_id) {\n            var args = arguments.slice(1, arguments.length);\n            return {};\n        };\n\n        this.isImageError = function(image) {\n            return true;\n        };\n\n        this.isImageLoaded = function(image) {\n            return false;\n        };\n\n        this.isImageLoading = function(image) {\n            return false;\n        };\n\n        this.loadImage = function(image) {\n            //loadImageAsync(image);\n            if (this.isImageLoaded(image))\n                this.imageLoaded();\n        };\n\n        this.markDirty = function(area) {\n            // if dirty\n            this.paint(area);\n        };\n\n        this.requestAnimationFrame = function(callback) {\n            return 0;\n        };\n\n        this.requestPaint = function() {\n        };\n\n        this.save = function(file_name) {\n            return false;\n        };\n\n        this.toDataURL = function(mime_type) {\n            return \"\";\n        };\n\n        this.unloadImage = function(image) {\n        };\n    }\n});\n","global.DoubleValidator = {\n  StandardNotation: 1, ScientificNotation: 2\n};\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'DoubleValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLDoubleValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"bottom\");\n    createProperty(\"real\", this, \"top\");\n    createProperty(\"int\",  this, \"decimals\");\n    createProperty(\"enum\", this, \"notation\");\n    this.bottom   = -Infinity;\n    this.top      = Infinity;\n    this.decimals = 1000;\n    this.notation = DoubleValidator.ScientificNotation;\n\n    var standardRegExp   = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n    var scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n\n    this.getRegExpForNotation = (function(notation) {\n      switch (notation) {\n        case DoubleValidator.ScientificNotation:\n          return scientificRegExp;\n          break ;\n        case DoubleValidator.StandardNotation:\n          return standardRegExp;\n          break ;\n      }\n      return null;\n    }).bind(this);\n\n    function getDecimalsForNumber(number) {\n      if (Math.round(number) != number) {\n        var str = '' + number;\n\n        return /\\d*$/.exec(str)[0].length;\n      }\n      return 0;\n    }\n\n    this.validate = (function(string) {\n      var regExp     = this.getRegExpForNotation(this.notation);\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value    = parseFloat(string);\n\n        acceptable   = this.bottom <= value && this.top >= value;\n        acceptable   = acceptable && getDecimalsForNumber(value) <= this.decimals;\n      }\n      return acceptable;\n    }).bind(this);\n  }\n});\n\n","global.Easing = {\n  Linear: 1,\n  InQuad: 2,          OutQuad: 3,     InOutQuad: 4,           OutInQuad: 5,\n  InCubic: 6,         OutCubic: 7,    InOutCubic: 8,          OutInCubic: 9,\n  InQuart: 10,        OutQuart: 11,   InOutQuart: 12,         OutInQuart: 13,\n  InQuint: 14,        OutQuint: 15,   InOutQuint: 16,         OutInQuint: 17,\n  InSine: 18,         OutSine: 19,    InOutSine: 20,          OutInSine: 21,\n  InExpo: 22,         OutExpo: 23,    InOutExpo: 24,          OutInExpo: 25,\n  InCirc: 26,         OutCirc: 27,    InOutCirc: 28,          OutInCirc: 29,\n  InElastic: 30,      OutElastic: 31, InOutElastic: 32,       OutInElastic: 33,\n  InBack: 34,         OutBack: 35,    InOutBack: 36,          OutInBack: 37,\n  InBounce: 38,       OutBounce: 39,  InOutBounce: 40,        OutInBounce: 41\n}\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Font',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLFont(parent) {\n    QObject.call(this);\n    createProperty(\"bool\", this, \"bold\");\n    createProperty(\"enum\", this, \"capitalization\", {initialValue: 0});\n    createProperty(\"string\", this, \"family\", {initialValue: 'sans-serif'});\n    createProperty(\"bool\", this, \"italic\");\n    createProperty(\"real\", this, \"letterSpacing\");\n    createProperty(\"int\", this, \"pixelSize\", {initialValue: 13});\n    createProperty(\"real\", this, \"pointSize\", {initialValue: 10});\n    createProperty(\"bool\", this, \"strikeout\");\n    createProperty(\"bool\", this, \"underline\");\n    createProperty(\"enum\", this, \"weight\");\n    createProperty(\"real\", this, \"wordSpacing\");\n    var sizeLock = false;\n\n        this.boldChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontWeight =\n                parent.font.weight !== undefined ? parent.font.weight :\n                newVal ? \"bold\" : \"normal\";\n        });\n        this.capitalizationChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontVariant =\n                newVal == \"smallcaps\" ? \"small-caps\" : \"normal\";\n            newVal = newVal == \"smallcaps\" ? \"none\" : newVal;\n            parent.dom.firstChild.style.textTransform = newVal;\n        });\n        this.familyChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontFamily = newVal;\n        });\n        this.italicChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontStyle = newVal ? \"italic\" : \"normal\";\n        });\n        this.letterSpacingChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.letterSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n        this.pixelSizeChanged.connect(newVal => {\n            if (!sizeLock) {\n              this.pointSize = newVal * 0.75;\n            }\n            const val = newVal + 'px';\n            parent.dom.style.fontSize = val;\n            parent.dom.firstChild.style.fontSize = val;\n        });\n        this.pointSizeChanged.connect(newVal => {\n            sizeLock = true;\n            this.pixelSize = Math.round(newVal / 0.75);\n            sizeLock = false;\n        });\n        this.strikeoutChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.textDecoration = newVal\n                ? \"line-through\"\n                : parent.font.underline\n                ? \"underline\"\n                : \"none\";\n        });\n        this.underlineChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.textDecoration = parent.font.strikeout\n                ? \"line-through\"\n                : newVal\n                ? \"underline\"\n                : \"none\";\n        });\n        this.weightChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontWeight =\n                newVal !== undefined ? newVal :\n                parent.font.bold ? \"bold\" : \"normal\";\n        });\n        this.wordSpacingChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.wordSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n  }\n});\n\n","global.Font = {\n  // Capitalization\n  MixedCase: \"none\",\n  AllUppercase: \"uppercase\",\n  AllLowercase: \"lowercase\",\n  SmallCaps: \"smallcaps\",\n  Capitalize: \"capitalize\",\n  // Weight\n  Light: \"lighter\",\n  Normal: \"normal\",\n  DemiBold: \"600\",\n  Bold: \"bold\",\n  Black: \"bolder\"\n}\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'FontLoader',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLFontLoader(meta) {\n    callSuper(this, meta);\n\n    // Exports.\n    this.FontLoader = {\n        // status\n        Null: 0,\n        Ready: 1,\n        Loading: 2,\n        Error: 3\n    }\n\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\");\n\n    this.status = this.FontLoader.Null;\n\n    var self = this,\n        domStyle = document.createElement('style'),\n        lastName = '',\n        inTouchName = false;\n\n    // Maximum timeout is the maximum time for a font to load. If font isn't loaded in this time, the status is set to Error.\n    // For both cases (with and without FontLoader.js) if the font takes more than the maximum timeout to load,\n    // dimensions recalculations for elements that are using this font will not be triggered or will have no effect.\n\n    // FontLoader.js uses only the last timeout. The state and name properties are set immediately when the font loads.\n    // If the font could not be loaded, the Error status will be set only when this timeout expires.\n    // If the font loading takes more than the timeout, the name property is set, but the status is set to Error.\n\n    // Fallback sets the font name immediately and touches it several times to trigger dimensions recalcuations.\n    // The status is set to Error and should not be used.\n    var timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000]; // 15 seconds maximum\n\n    function cycleTouchName(fontName, i) {\n        if (lastName !== fontName)\n            return;\n        if (i > 0) {\n            var name = self.name;\n            inTouchName = true;\n            // Calling self.nameChanged() is not enough, we have to actually change the value to flush the bindings.\n            self.name = 'sans-serif';\n            self.name = name;\n            inTouchName = false;\n        }\n        if (i < timeouts.length) {\n            setTimeout(function() {\n                cycleTouchName(fontName, i + 1);\n            }, timeouts[i] - (i > 0 ? timeouts[i - 1] : 0));\n        }\n    }\n\n    function loadFont(fontName) {\n        if ((lastName === fontName) || inTouchName)\n           return;\n        lastName = fontName;\n\n        if (!fontName) {\n            self.status = self.FontLoader.Null;\n            return;\n        }\n        self.status = self.FontLoader.Loading;\n        if (typeof FontLoader !== 'undefined') {\n            var fontLoader = new FontLoader([fontName], {\n                \"fontsLoaded\": function(error) {\n                    if (error !== null) {\n                        if ((lastName === fontName) && (error.notLoadedFontFamilies[0] === fontName)) {\n                            self.name = fontName; // Set the name for the case of font loading after the timeout.\n                            self.status = self.FontLoader.Error;\n                        }\n                    }\n                },\n                \"fontLoaded\": function(fontFamily) {\n                    if ((lastName === fontName) && (fontFamily == fontName)) {\n                        self.name = fontName;\n                        self.status = self.FontLoader.Ready;\n                    }\n                }\n            }, timeouts[timeouts.length - 1]);\n            FontLoader.testDiv = null; // Else I get problems loading multiple fonts (FontLoader.js bug?)\n            fontLoader.loadFonts();\n        } else {\n            console.warn('FontLoader.js library is not loaded.\\nYou should load https://github.com/smnh/FontLoader if you want to use QtQuick FontLoader elements.')\n            self.status = self.FontLoader.Error; // You should not rely on 'status' property without FontLoader.js.\n            self.name = fontName;\n            cycleTouchName(fontName, 0)\n        }\n    }\n\n    this.sourceChanged.connect(this, function(font_src) {\n        var fontName = 'font_' + ((new Date()).getTime()).toString(36) + '_' + (Math.round(Math.random() * 1e15)).toString(36);\n        domStyle.innerHTML = '@font-face { font-family: \\'' + fontName + '\\'; src: url(\\'' + engine.$resolvePath(font_src) + '\\'); }';\n        document.getElementsByTagName('head')[0].appendChild(domStyle);\n        loadFont(fontName);\n    });\n\n    this.nameChanged.connect(this, loadFont);\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'IntValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLIntValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"bottom\");\n    createProperty(\"int\", this, \"top\");\n    this.bottom = -2147483647;\n    this.top    = 2147483647;\n\n    this.validate = (function(string) {\n      var regExp     = /^(-|\\+)?\\s*[0-9]+$/;\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value    = parseInt(string);\n\n        acceptable   = this.bottom <= value && this.top >= value;\n      }\n      return acceptable;\n    }).bind(this);\n  }\n});\n\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'ListElement',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLListElement(meta) {\n    callSuper(this, meta);\n\n    for (var i in meta.object) {\n        if (i[0] != \"$\") {\n            createProperty(\"variant\", this, i);\n        }\n    }\n    applyProperties(meta.object, this, this, this.$context);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'ListModel',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLListModel(meta) {\n    callSuper(this, meta);\n    var self = this,\n    firstItem = true;\n    var QMLListElement = getConstructor('QtQuick', '2.0', 'ListElement');\n\n    createProperty(\"int\", this, \"count\");\n    createProperty(\"list\", this, \"$items\");\n    this.$defaultProperty = \"$items\";\n    this.$model = new JSItemModel();\n\n    this.$itemsChanged.connect(this, function(newVal) {\n        this.count = this.$items.length;\n        if (firstItem && newVal.length > 0 ) {\n            firstItem = false;\n            var roleNames = [];\n            var dict = newVal[0];\n            for (var i in (dict instanceof QMLListElement) ? dict.$properties : dict) {\n                if (i != \"index\")\n                    roleNames.push(i);\n            }\n            this.$model.setRoleNames(roleNames);\n        }\n    });\n\n    this.$model.data = function(index, role) {\n        return self.$items[index][role];\n    }\n    this.$model.rowCount = function() {\n        return self.$items.length;\n    }\n\n    this.append = function(dict) {\n        var index = this.$items.length;\n        var c = 0;\n\n        if (dict instanceof Array){\n            for (var key in dict) {\n                this.$items.push(dict[key]);\n                c++;\n            }\n        } else {\n            this.$items.push(dict);\n            c = 1;\n        }\n\n        this.$itemsChanged(this.$items);\n        this.$model.rowsInserted(index, index + c);\n    }\n    this.clear = function() {\n        this.$model.modelReset();\n        this.$items.length = 0;\n        this.count = 0;\n    }\n    this.get = function(index) {\n        return this.$items[index];\n    }\n    this.insert = function(index, dict) {\n        this.$items.splice(index, 0, dict);\n        this.$itemsChanged(this.$items);\n        this.$model.rowsInserted(index, index+1);\n    }\n    this.move = function(from, to, n) {\n        var vals = this.$items.splice(from, n);\n        for (var i = 0; i < vals.length; i++) {\n            this.$items.splice(to + i, 0, vals[i]);\n        }\n        this.$model.rowsMoved(from, from+n, to);\n    }\n    this.remove = function(index) {\n        this.$items.splice(index, 1);\n        this.$model.rowsRemoved(index, index+1);\n        this.count = this.$items.length;\n    }\n    this.set = function(index, dict) {\n        this.$items[index] = dict;\n        this.$model.dataChanged(index, index);\n    }\n    this.setProperty = function(index, property, value) {\n        this.$items[index][property] = value;\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'ListView',\n  versions: /.*/,\n  baseClass: 'Repeater',\n  constructor: function QMLListView(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    createProperty(\"enum\", this, \"orientation\");\n    createProperty(\"real\", this, \"spacing\");\n\n    this.container = function() { return self; }\n    this.modelChanged.connect(styleChanged);\n    this.delegateChanged.connect(styleChanged);\n    this.orientationChanged.connect(styleChanged);\n    this.spacingChanged.connect(styleChanged);\n\n    this._childrenInserted.connect(applyStyleOnItem)\n\n    function applyStyleOnItem($item) {\n      $item.dom.style.position = 'initial';\n      if (self.orientation == Qt.Horizontal) {\n        $item.dom.style.display = 'inline-block';\n        if ($item != self.$items[0])\n          $item.dom.style[\"margin-left\"] = self.spacing + \"px\";\n      }\n      else {\n        $item.dom.style.display = 'block';\n        if ($item != self.$items[0])\n          $item.dom.style[\"margin-top\"] = self.spacing + \"px\";\n      }\n    }\n\n    function styleChanged() {\n      for (var i = 0 ; i < self.$items.length ; ++i) {\n        applyStyleOnItem(self.$items[i]);\n      }\n    }\n  }\n});\n","registerQmlType({\n    module: 'QtQuick',\n    name: 'Loader',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function(meta) {\n        callSuper(this, meta);\n\n        createProperty('bool', this, 'active', {initialValue: true});\n        createProperty('bool', this, 'asynchronous');\n        createProperty('var', this, 'item');\n        createProperty('real', this, 'progress');\n        createProperty('url', this, 'source');\n        createProperty('Component', this, 'sourceComponent');\n        createProperty('enum', this, 'status', {initialValue: 1});\n\n        let sourceUrl = '';\n\n        this.loaded = Signal();\n\n        const QMLComponent = getConstructor('QtQml', '2.0', 'Component');\n\n        this.activeChanged.connect(() => {\n            if (!this.active) {\n                unload();\n                return;\n            }\n            if (this.source) {\n                sourceChanged();\n            } else if (this.sourceComponent) {\n                sourceComponentChanged();\n            }\n        });\n\n        this.sourceChanged.connect(newVal => {\n            // if (newVal == sourceUrl && this.item !== undefined) return // TODO\n            if (!this.active) {\n                return;\n            }\n\n            unload();\n\n            // TODO: we require '.qml' for now, that should be fixed\n            if (newVal.length <= 4) { // 0\n                return;\n            }\n            if (newVal.substr(newVal.length - 4, 4) !== '.qml') {\n                return;\n            }\n            var fileName = newVal.substring(0, newVal.length - 4);\n\n            var tree = engine.loadComponent(fileName);\n            var meta = { object: tree, context: this, parent: this };\n            var qmlComponent = new QMLComponent(meta);\n            var loadedComponent = createComponentObject(qmlComponent, this);\n            this.sourceComponent = loadedComponent;\n            sourceUrl = newVal;\n        });\n\n        this.sourceComponentChanged.connect(newItem => {\n            if (!this.active) {\n                return;\n            }\n\n            unload();\n\n            var qmlComponent = newItem;\n\n            if (newItem instanceof QMLComponent) {\n                  var meta = { object: newItem.$metaObject, context: this, parent: this };\n                  qmlComponent = construct(meta);\n            }\n\n            qmlComponent.parent = this;\n            this.item = qmlComponent;\n\n            updateGeometry();\n\n            if (this.item) {\n                this.loaded();\n            }\n        });\n\n        function createComponentObject(qmlComponent, parent) {\n            var newComponent = qmlComponent.createObject(parent);\n\n            newComponent.parent = parent;\n            qmlComponent.finalizeImports();\n\n             if (engine.operationState !== QMLOperationState.Init) {\n                // We don't call those on first creation, as they will be called\n                // by the regular creation-procedures at the right time.\n                engine.$initializePropertyBindings();\n                callOnCompleted(newComponent);\n             }\n\n            return newComponent;\n        }\n\n        const updateGeometry = () => {\n            // Loader size doesn't exist\n            if (!this.width) {\n                this.width = this.item ? this.item.width : 0;\n            } else if (this.item) {\n                // Loader size exists\n                this.item.width = this.width;\n            }\n\n            if (!this.height) {\n                this.height = this.item ? this.item.height : 0;\n            } else if (this.item) {\n                // Loader size exists\n                this.item.height = this.height;\n            }\n        }\n        this.widthChanged.connect(updateGeometry);\n        this.heightChanged.connect(updateGeometry);\n\n        const unload = () => {\n          if (this.item) {\n            this.item.$delete();\n            this.item.parent = undefined;\n            this.item = undefined;\n          }\n        }\n\n        function callOnCompleted(child) {\n            child.Component.completed();\n            child.children.forEach(callOnCompleted);\n        }\n\n        this.setSource = function(url, options) {\n            sourceUrl = url;\n            this.props = options;\n            this.source = url;\n        }\n    }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'MouseArea',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLMouseArea(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.dom.style.pointerEvents = \"all\";\n\n    // IE does not handle mouse clicks to transparent divs, so we have\n    // to set a background color and make it invisible using opacity\n    // as that doesn't affect the mouse handling.\n    this.dom.style.backgroundColor = \"white\";\n    this.dom.style.opacity = 0;\n\n    createProperty(\"variant\", this, \"acceptedButtons\", {initialValue: Qt.LeftButton});\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n    createProperty(\"bool\", this, \"hoverEnabled\");\n    createProperty(\"real\", this, \"mouseX\");\n    createProperty(\"real\", this, \"mouseY\");\n    createProperty(\"bool\", this, \"pressed\");\n    createProperty(\"bool\", this, \"containsMouse\");\n    createProperty(\"variant\", this, \"pressedButtons\", {initialValue: 0});\n    createProperty(\"enum\", this, \"cursorShape\", {initialValue: Qt.ArrowCursor});\n\n    this.clicked = Signal([{type: \"variant\", name: \"mouse\"}]);\n    this.entered = Signal();\n    this.exited = Signal();\n    this.positionChanged = Signal([{type: \"variant\", name: \"mouse\"}]);\n\n    function eventToMouse(e) {\n        return {\n            accepted: true,\n            button: e.button == 0 ? Qt.LeftButton :\n                    e.button == 1 ? Qt.MiddleButton :\n                    e.button == 2 ? Qt.RightButton :\n                    0,\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\n                    | (e.altKey * Qt.AltModifier)\n                    | (e.shiftKey * Qt.ShiftModifier)\n                    | (e.metaKey * Qt.MetaModifier),\n            x: (e.offsetX || e.layerX),\n            y: (e.offsetY || e.layerY)\n        };\n    }\n    function handleClick(e) {\n        var mouse = eventToMouse(e);\n\n        if (self.enabled && self.acceptedButtons & mouse.button) {\n            self.clicked(mouse);\n        }\n        // This decides whether to show the browser's context menu on right click or not\n        return !(self.acceptedButtons & Qt.RightButton);\n    }\n    this.dom.onclick = handleClick;\n    this.dom.oncontextmenu = handleClick;\n    this.dom.onmousedown = function(e) {\n        if (self.enabled) {\n            var mouse = eventToMouse(e);\n            self.mouseX = mouse.x;\n            self.mouseY = mouse.y;\n            self.pressed = true;\n        }\n        self.pressedButtons = mouse.button;\n    }\n    this.dom.onmouseup = function(e) {\n        self.pressed = false;\n        self.pressedButtons = 0;\n    }\n    this.dom.onmouseover = function(e) {\n        self.containsMouse = true;\n        self.entered();\n    }\n    this.dom.onmouseout = function(e) {\n        self.containsMouse = false;\n        self.exited();\n    }\n    this.dom.onmousemove = function(e) {\n        if (self.enabled && (self.hoverEnabled || self.pressed)) {\n            var mouse = eventToMouse(e);\n            self.positionChanged(mouse);\n            self.mouseX = mouse.x;\n            self.mouseY = mouse.y;\n        }\n    }\n\n    function cursorShapeToCSS(){\n        switch (self.cursorShape) {\n          case Qt.ArrowCursor: return 'default';\n          case Qt.UpArrowCursor: return 'n-resize';\n          case Qt.CrossCursor: return 'crosshair';\n          case Qt.WaitCursor: return 'wait';\n          case Qt.IBeamCursor: return 'text';\n          case Qt.SizeVerCursor: return 'ew-resize';\n          case Qt.SizeHorCursor: return 'ns-resize';\n          case Qt.SizeBDiagCursor: return 'nesw-resize';\n          case Qt.SizeFDiagCursor: return 'nwse-resize';\n          case Qt.SizeAllCursor: return 'all-scroll';\n          case Qt.BlankCursor: return 'none';\n          case Qt.SplitVCursor: return 'row-resize';\n          case Qt.SplitHCursor: return 'col-resize';\n          case Qt.PointingHandCursor: return 'pointer';\n          case Qt.ForbiddenCursor: return 'not-allowed';\n          case Qt.WhatsThisCursor: return 'help';\n          case Qt.BusyCursor: return 'progress';\n          case Qt.OpenHandCursor: return 'grab';\n          case Qt.ClosedHandCursor: return 'grabbing';\n          case Qt.DragCopyCursor: return 'copy';\n          case Qt.DragMoveCursor: return 'move';\n          case Qt.DragLinkCursor: return 'alias';\n          //case Qt.BitmapCursor: return 'auto';\n          //case Qt.CustomCursor: return 'auto';\n        }\n        return 'auto';\n    }\n\n    this.cursorShapeChanged.connect(function() {\n      self.dom.style.cursor = cursorShapeToCSS();\n    });\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'NumberAnimation',\n  versions: /.*/,\n  baseClass: 'PropertyAnimation',\n  constructor: function QMLNumberAnimation(meta) {\n    callSuper(this, meta);\n    var at = 0,\n        loop = 0,\n        self = this;\n\n    engine.$addTicker(ticker);\n\n    function ticker(now, elapsed) {\n        if ((self.running || loop === -1) && !self.paused) { // loop === -1 is a marker to just finish this run\n            if (at == 0 && loop == 0 && !self.$actions.length)\n                self.$redoActions();\n            at += elapsed / self.duration;\n            if (at >= 1)\n                self.complete();\n            else\n                for (var i in self.$actions) {\n                    var action = self.$actions[i],\n                        value = self.easing.$valueForProgress(at) * (action.to - action.from) + action.from;\n                    action.target.$properties[action.property].set(value, QMLProperty.ReasonAnimation);\n                }\n        }\n    }\n\n    function startLoop() {\n        for (var i in this.$actions) {\n            var action = this.$actions[i];\n            action.from = action.from !== undefined ? action.from : action.target[action.property];\n        }\n        at = 0;\n    }\n\n    this.runningChanged.connect(this, function(newVal) {\n        if (newVal) {\n            startLoop.call(this);\n            this.paused = false;\n        } else if (this.alwaysRunToEnd && at < 1) {\n            loop = -1; // -1 is used as a marker to stop\n        } else {\n            loop = 0;\n            this.$actions = [];\n        }\n    });\n\n    this.complete = function() {\n        for (var i in this.$actions) {\n            var action = this.$actions[i];\n            action.target.$properties[action.property].set(action.to, QMLProperty.ReasonAnimation);\n        }\n\n        if (++loop == this.loops)\n            this.running = false;\n        else if (!this.running)\n            this.$actions = [];\n        else\n            startLoop.call(this);\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'ParallelAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLParallelAnimation(meta) {\n    callSuper(this, meta);\n    var curIndex,\n        passedLoops,\n        i;\n\n    this.Animation = { Infinite: Math.Infinite }\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n    this.$runningAnimations = 0;\n\n    this.animationsChanged.connect(this, function() {\n        for (i = 0; i < this.animations.length; i++) {\n            if (!this.animations[i].runningChanged.isConnected(this, animationFinished))\n                this.animations[i].runningChanged.connect(this, animationFinished);\n        }\n    });\n\n    function animationFinished(newVal) {\n        this.$runningAnimations += newVal ? 1 : -1;\n        if (this.$runningAnimations === 0)\n            this.running = false;\n    }\n\n    this.start = function() {\n        if (!this.running) {\n            this.running = true;\n            for (i = 0; i < this.animations.length; i++)\n                this.animations[i].start();\n        }\n    }\n    this.stop = function() {\n        if (this.running) {\n            for (i = 0; i < this.animations.length; i++)\n                this.animations[i].stop();\n            this.running = false;\n        }\n    }\n    this.complete = this.stop;\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by start();\n            self.start();\n        }\n    });\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'PropertyAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLPropertyAnimation(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"duration\", {initialValue: 250});\n    createProperty(\"real\", this, \"from\");\n    createProperty(\"string\", this, \"properties\");\n    createProperty(\"string\", this, \"property\");\n    createProperty(\"QtObject\", this, \"target\");\n    createProperty(\"list\", this, \"targets\");\n    createProperty(\"real\", this, \"to\");\n\n    this.easing = new QObject(this);\n    createProperty(\"enum\", this.easing, \"type\", {initialValue: Easing.Linear});\n    createProperty(\"real\", this.easing, \"amplitude\", {initialValue: 1});\n    createProperty(\"real\", this.easing, \"overshoot\", {initialValue: 0.3});\n    createProperty(\"real\", this.easing, \"period\", {initialValue: 1.70158});\n\n    this.easing.$valueForProgress = function(t) {\n        switch(this.type) {\n            // Quad\n            case Easing.InQuad: return Math.pow(t, 2);\n            case Easing.OutQuad: return -Math.pow(t - 1, 2) + 1;\n            case Easing.InOutQuad:\n                if (t < 0.5)\n                    return 2 * Math.pow(t, 2);\n                return -2 * Math.pow(t - 1, 2) + 1;\n            case Easing.OutInQuad:\n                if (t < 0.5)\n                    return -2 * Math.pow(t - 0.5, 2) + 0.5;\n                return 2 * Math.pow(t - 0.5, 2) + 0.5;\n            // Cubic\n            case Easing.InCubic: return Math.pow(t, 3);\n            case Easing.OutCubic: return Math.pow(t - 1, 3) + 1;\n            case Easing.InOutCubic:\n                if (t < 0.5)\n                    return 4 * Math.pow(t, 3);\n                return 4 * Math.pow(t - 1, 3) + 1;\n            case Easing.OutInCubic:\n                return 4 * Math.pow(t - 0.5, 3) + 0.5;\n            // Quart\n            case Easing.InQuart: return Math.pow(t, 4);\n            case Easing.OutQuart: return -Math.pow(t - 1, 4) + 1;\n            case Easing.InOutQuart:\n                if (t < 0.5)\n                    return 8 * Math.pow(t, 4);\n                return -8 * Math.pow(t - 1, 4) + 1;\n            case Easing.OutInQuart:\n                if (t < 0.5)\n                    return -8 * Math.pow(t - 0.5, 4) + 0.5;\n                return 8 * Math.pow(t - 0.5, 4) + 0.5;\n            // Quint\n            case Easing.InQuint: return Math.pow(t, 5);\n            case Easing.OutQuint: return Math.pow(t - 1, 5) + 1;\n            case Easing.InOutQuint:\n                if (t < 0.5)\n                    return 16 * Math.pow(t, 5);\n                return 16 * Math.pow(t - 1, 5) + 1;\n            case Easing.OutInQuint:\n                if (t < 0.5)\n                    return 16 * Math.pow(t - 0.5, 5) + 0.5;\n                return 16 * Math.pow(t - 0.5, 5) + 0.5;\n            // Sine\n            case Easing.InSine: return -Math.cos(0.5 * Math.PI * t) + 1;\n            case Easing.OutSine: return Math.sin(0.5 * Math.PI * t);\n            case Easing.InOutSine: return -0.5 * Math.cos(Math.PI * t) + 0.5;\n            case Easing.OutInSine:\n                if (t < 0.5)\n                    return 0.5 * Math.sin(Math.PI * t);\n                return -0.5 * Math.sin(Math.PI * t) + 1;\n            // Expo\n            case Easing.InExpo: return (1/1023) * (Math.pow(2, 10*t) - 1);\n            case Easing.OutExpo: return -(1024/1023) * (Math.pow(2, -10*t) - 1);\n            case Easing.InOutExpo:\n                if (t < 0.5)\n                    return (1/62) * (Math.pow(2, 10*t) - 1);\n                return -(512/31) * Math.pow(2, -10*t) + (63/62);\n            case Easing.OutInExpo:\n                if (t < 0.5)\n                    return -(16/31) * (Math.pow(2, -10*t) - 1);\n                return (1/1984) * Math.pow(2, 10*t) + (15/31);\n            // Circ\n            case Easing.InCirc: return 1 - Math.sqrt(1 - t*t);\n            case Easing.OutCirc: return Math.sqrt(1 - Math.pow(t - 1, 2));\n            case Easing.InOutCirc:\n                if (t < 0.5)\n                    return 0.5 * (1 - Math.sqrt(1 - 4*t*t));\n                return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n            case Easing.OutInCirc:\n                if (t < 0.5)\n                    return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n                return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n            // Elastic\n            case Easing.InElastic:\n                return -this.amplitude * Math.pow(2, 10 * t - 10)\n                        * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n            case Easing.OutElastic:\n                return this.amplitude * Math.pow(2, -10 * t)\n                        * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                        + 1;\n            case Easing.InOutElastic:\n                if (t < 0.5)\n                    return -0.5 * this.amplitude * Math.pow(2, 20 * t - 10)\n                            * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n                return -0.5 * this.amplitude * Math.pow(2, -20 * t + 10)\n                        * Math.sin(4 * t * Math.PI / this.period + Math.asin(1 / this.amplitude))\n                        + 1;\n            case Easing.OutInElastic:\n                if (t < 0.5)\n                    return 0.5 * this.amplitude * Math.pow(2, -20 * t)\n                            * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                            + 0.5;\n                return -0.5 * this.amplitude * Math.pow(2, 20 * t - 20)\n                        * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                        + 0.5;\n            // Back\n            case Easing.InBack: return (this.overshoot + 1) * Math.pow(t, 3) - this.overshoot * Math.pow(t, 2);\n            case Easing.OutBack: return (this.overshoot + 1) * Math.pow(t - 1, 3) + this.overshoot * Math.pow(t - 1, 2) + 1;\n            case Easing.InOutBack:\n                if (t < 0.5)\n                    return 4 * (this.overshoot + 1) * Math.pow(t, 3) - 2 * this.overshoot * Math.pow(t, 2);\n                return 0.5 * (this.overshoot + 1) * Math.pow(2 * t - 2, 3) + this.overshoot/2 * Math.pow(2 * t - 2, 2) + 1;\n            case Easing.OutInBack:\n                if (t < 0.5)\n                    return 0.5 * ((this.overshoot + 1) * Math.pow(2 * t - 1, 3) + this.overshoot * Math.pow(2 * t - 1, 2) + 1);\n                return 4 * (this.overshoot + 1) * Math.pow( t - 0.5, 3) - 2 * this.overshoot * Math.pow(t - 0.5, 2) + 0.5;\n            // Bounce\n            case Easing.InBounce:\n                if (t < 1/11) return -this.amplitude * (121/16) * (t*t - (1/11)*t);\n                if (t < 3/11) return -this.amplitude * (121/16) * (t*t - (4/11)*t + (3/121));\n                if (t < 7/11) return -this.amplitude * (121/16) * (t*t - (10/11)*t + (21/121));\n                return -(121/16) * (t*t - 2*t + 1) + 1;\n            case Easing.OutBounce:\n                if (t < 4/11) return (121/16) * t*t;\n                if (t < 8/11) return this.amplitude * (121/16) * (t*t - (12/11)*t + (32/121)) + 1;\n                if (t < 10/11) return this.amplitude * (121/16) * (t*t - (18/11)*t + (80/121)) + 1;\n                return this.amplitude * (121/16) * (t*t - (21/11)*t + (10/11)) + 1;\n            case Easing.InOutBounce:\n                if (t < 1/22) return -this.amplitude * (121/8) * (t*t - (1/22)*t);\n                if (t < 3/22) return -this.amplitude * (121/8) * (t*t - (2/11)*t + (3/484));\n                if (t < 7/22) return -this.amplitude * (121/8) * (t*t - (5/11)*t + (21/484));\n                if (t < 11/22) return -(121/8) * (t*t - t + 0.25) + 0.5;\n                if (t < 15/22) return (121/8) * (t*t - t) + (137/32);\n                if (t < 19/22) return this.amplitude * (121/8) * (t*t - (17/11)*t + (285/484)) + 1;\n                if (t < 21/22) return this.amplitude * (121/8) * (t*t - (20/11)*t + (399/484)) + 1;\n                return this.amplitude * (121/8) * (t*t - (43/22)*t + (21/22)) + 1;\n            case Easing.OutInBounce:\n                if (t < 4/22) return (121/8) * t*t;\n                if (t < 8/22) return -this.amplitude * (121/8) * (t*t - (6/11)*t + (8/121)) + 0.5;\n                if (t < 10/22) return -this.amplitude * (121/8) * (t*t - (9/11)*t + (20/121)) + 0.5;\n                if (t < 11/22) return -this.amplitude * (121/8) * (t*t - (21/22)*t + (5/22)) + 0.5;\n                if (t < 12/22) return this.amplitude * (121/8) * (t*t - (23/22)*t + (3/11)) + 0.5;\n                if (t < 14/22) return this.amplitude * (121/8) * (t*t - (13/11)*t + (42/121)) + 0.5;\n                if (t < 18/22) return this.amplitude * (121/8) * (t*t - (16/11)*t + (63/121)) + 0.5;\n                return -(121/8) * (t*t - 2*t + (117/121)) + 0.5;\n            // Default\n            default:\n                console.log(\"Unsupported animation type: \", this.type);\n            // Linear\n            case Easing.Linear:\n                return t;\n        }\n    }\n\n    this.$redoActions = function() {\n        this.$actions = [];\n        for (var i = 0; i < this.$targets.length; i++) {\n            for (var j in this.$props) {\n                this.$actions.push({\n                    target: this.$targets[i],\n                    property: this.$props[j],\n                    from: this.from,\n                    to: this.to\n                });\n            }\n        }\n    }\n    function redoProperties() {\n        this.$props = this.properties.split(\",\");\n\n        // Remove whitespaces\n        for (var i = 0; i < this.$props.length; i++) {\n            var matches = this.$props[i].match(/\\w+/);\n            if (matches) {\n                this.$props[i] = matches[0];\n            } else {\n                this.$props.splice(i, 1);\n                i--;\n            }\n        }\n        // Merge properties and property\n        if (this.property && this.$props.indexOf(this.property) === -1)\n            this.$props.push(this.property);\n    }\n    function redoTargets() {\n        this.$targets = this.targets.slice();\n\n        if (this.target && this.$targets.indexOf(this.target) === -1)\n            this.$targets.push(this.target);\n    }\n\n    this.duration = 250;\n    this.easing.type = Easing.Linear;\n    this.easing.amplitude = 1;\n    this.easing.period = 0.3;\n    this.easing.overshoot = 1.70158;\n    this.$props = [];\n    this.$targets = [];\n    this.$actions = [];\n    this.properties = \"\";\n    this.targets = [];\n\n    this.targetChanged.connect(this, redoTargets);\n    this.targetsChanged.connect(this, redoTargets);\n    this.propertyChanged.connect(this, redoProperties);\n    this.propertiesChanged.connect(this, redoProperties);\n\n    if (meta.object.$on !== undefined) {\n        this.property = meta.object.$on;\n        this.target = this.$parent;\n    }\n  }\n});\n\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'RegExpValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLRegExpValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"var\", this, \"regExp\");\n\n    this.validate = (function(string) {\n      if (typeof this.regExp == 'undefined' || this.regExp == null)\n        return true;\n      return this.regExp.test(string);\n    }).bind(this);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Rotation',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLRotation(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"angle\");\n\n    this.axis = new QObject(this);\n    createProperty(\"real\", this.axis, \"x\");\n    createProperty(\"real\", this.axis, \"y\");\n    createProperty(\"real\", this.axis, \"z\", {initialValue: 1});\n\n    this.origin = new QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    function updateOrigin() {\n        this.$parent.dom.style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n        this.$parent.dom.style.MozTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";    // Firefox\n        this.$parent.dom.style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Chrome, Safari and Opera\n    }\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, updateOrigin);\n    this.origin.yChanged.connect(this, updateOrigin);\n    this.$parent.$updateTransform();\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Scale',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLScale(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"xScale\");\n    createProperty(\"real\", this, \"yScale\");\n\n    this.origin = new QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    const updateOrigin = () => {\n        this.$parent.dom.style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n        this.$parent.dom.style.MozTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";    // Firefox\n        this.$parent.dom.style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Chrome, Safari and Opera\n    }\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, updateOrigin);\n    this.origin.yChanged.connect(this, updateOrigin);\n\n    this.xScale = 0;\n    this.yScale = 0;\n    this.origin.x = 0;\n    this.origin.y = 0;\n\n    /* QML default origin is top-left, while CSS default origin is centre, so\n     * updateOrigin must be called to set the initial transformOrigin. */\n    updateOrigin();\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'SequentialAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLSequentialAnimation(meta) {\n    callSuper(this, meta);\n    var curIndex,\n        passedLoops,\n        i,\n        self = this;\n\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n\n    function nextAnimation(proceed) {\n        var anim;\n        if (self.running && !proceed) {\n            curIndex++;\n            if (curIndex < self.animations.length) {\n                anim = self.animations[curIndex];\n                console.log(\"nextAnimation\", self, curIndex, anim);\n                anim.start();\n            } else {\n                passedLoops++;\n                if (passedLoops >= self.loops) {\n                    self.complete();\n                } else {\n                    curIndex = -1;\n                    nextAnimation();\n                }\n            }\n        }\n    }\n\n    this.animationsChanged.connect(this, function() {\n        for (i = 0; i < this.animations.length; i++) {\n            if (!this.animations[i].runningChanged.isConnected(nextAnimation))\n                this.animations[i].runningChanged.connect(nextAnimation);\n        }\n    });\n\n    this.start = function() {\n        if (!this.running) {\n            this.running = true;\n            curIndex = -1;\n            passedLoops = 0;\n            nextAnimation();\n        }\n    }\n    this.stop = function() {\n        if (this.running) {\n            this.running = false;\n            if (curIndex < this.animations.length) {\n                this.animations[curIndex].stop();\n            }\n        }\n    }\n\n    this.complete = function() {\n        if (this.running) {\n            if (curIndex < this.animations.length) {\n                // Stop current animation\n                this.animations[curIndex].stop();\n            }\n            this.running = false;\n        }\n    }\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by start();\n            self.start();\n        }\n    });\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'State',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLState(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"list\", this, \"changes\");\n    this.$defaultProperty = \"changes\";\n    createProperty(\"string\", this, \"extend\");\n    createProperty(\"bool\", this, \"when\");\n    this.$item = this.$parent;\n\n    this.whenChanged.connect(this, function(newVal) {\n        if (newVal)\n            this.$item.state = this.name;\n        else if (this.$item.state == this.name)\n            this.$item.state = \"\";\n    });\n\n    this.$getAllChanges = function() {\n        if (this.extend) {\n            for (var i = 0; i < this.$item.states.length; i++)\n                if (this.$item.states[i].name == this.extend)\n                    return this.$item.states[i].$getAllChanges().concat(this.changes);\n        } else\n            return this.changes;\n    }\n  }\n});\n","window.SystemPalette = {\n  Active:   \"active\",\n  Inactive: \"inactive\",\n  Disabled: \"disabled\"\n};\n\nwindow.platformsDetectors = [\n  //{ name: 'W8',      regexp: /Windows NT 6\\.2/ },\n  //{ name: 'W7',      regexp: /Windows NT 6\\.1/ },\n  //{ name: 'Windows', regexp: /Windows NT/ },\n  { name: 'OSX',     regexp: /Macintosh/ }\n];\n\nwindow.systemPalettes = {};\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'SystemPalette',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLSystemPalette(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"enum\", this, \"colorGroup\");\n\n    var attrs    = [ 'alternateBase', 'base', 'button', 'buttonText', 'dark', 'highlight', 'highlightedText', 'light', 'mid', 'midlight', 'shadow', 'text', 'window', 'windowText' ];\n    var platform = 'OSX';\n\n    for (var i = 0 ; i < attrs.length ; ++i)\n      createProperty(\"color\", this, attrs[i], { readOnly: true });\n    createProperty(\"enum\", this, \"colorGroup\");\n\n    this.colorGroupChanged.connect(this, (function (newVal) {\n      this.$canEditReadOnlyProperties = true;\n      for (var i = 0 ; i < attrs.length ; ++i) {\n        this[attrs[i]] = systemPalettes[platform][newVal][attrs[i]];\n      }\n      delete this.$canEditReadOnlyProperties;\n    }).bind(this));\n\n    // Detect OS\n    for (var i = 0 ; i < platformsDetectors.length ; ++i) {\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n        platforms = platformsDetectors[i].name;\n        break ;\n      }\n    }\n  }\n});\n\nwindow.systemPalettes['OSX'] = {\n        'active': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ffffff',\n          'button':        '#ededed',\n          'buttonText':    '#000000',\n          'dark':          '#bfbfbf',\n          'highlight':     '#fbed73',\n          'highlightText': '#000000',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#000000',\n          'window':        '#ededed',\n          'windowText':    '#000000'\n        },\n        'inactive': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ffffff',\n          'button':        '#ededed',\n          'buttonText':    '#000000',\n          'dark':          '#bfbfbf',\n          'highlight':     '#d0d0d0',\n          'highlightText': '#000000',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#000000',\n          'window':        '#ededed',\n          'windowText':    '#000000'\n        },\n        'disabled': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ededed',\n          'button':        '#ededed',\n          'buttonText':    '#949494',\n          'dark':          '#bfbfbf',\n          'highlight':     '#d0d0d0',\n          'highlightText': '#7f7f7f',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#7f7f7f',\n          'window':        '#ededed',\n          'windowText':    '#7f7f7f'\n        }\n};\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Text',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLText(meta) {\n    callSuper(this, meta);\n\n    const fc = this.impl = document.createElement('span');\n    fc.style.pointerEvents = 'none';\n    fc.style.width = '100%';\n    fc.style.height = '100%';\n    this.dom.appendChild(fc);\n\n    this.Text = {\n        // Wrap Mode\n        NoWrap: 0,\n        WordWrap: 1,\n        WrapAnywhere: 2,\n        Wrap: 3,\n        WrapAtWordBoundaryOrAnywhere: 3, // COMPAT\n        // Horizontal-Alignment\n        AlignLeft: \"left\",\n        AlignRight: \"right\",\n        AlignHCenter: \"center\",\n        AlignJustify: \"justify\",\n        // Style\n        Normal: 0,\n        Outline: 1,\n        Raised: 2,\n        Sunken: 3\n    }\n\n    const QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font   = new QMLFont(this);\n\n    createProperty(\"color\", this, \"color\");\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"real\", this, \"lineHeight\");\n    createProperty(\"enum\", this, \"wrapMode\");\n    createProperty(\"enum\", this, \"horizontalAlignment\");\n    createProperty(\"enum\", this, \"style\");\n    createProperty(\"color\", this, \"styleColor\");\n\n    this.colorChanged.connect(this, function(newVal) {\n        fc.style.color = QMLColor(newVal);\n    });\n    this.textChanged.connect(this, function(newVal) {\n        fc.innerHTML = newVal;\n    });\n    this.lineHeightChanged.connect(this, function(newVal) {\n        fc.style.lineHeight = newVal + \"px\";\n    });\n    this.wrapModeChanged.connect(this, function(newVal) {\n        switch (newVal) {\n            case 0:\n                fc.style.whiteSpace = \"pre\";\n                break;\n            case 1:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordWrap = \"normal\";\n                break;\n            case 2:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordBreak = \"break-all\";\n                break;\n            case 3:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordWrap = \"break-word\";\n        };\n        // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n        // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n        if (this.horizontalAlignment == \"justify\")\n            fc.style.whiteSpace = \"normal\";\n    });\n    this.horizontalAlignmentChanged.connect(this, function(newVal) {\n        this.dom.style.textAlign = newVal;\n        // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n        // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n        if (newVal == \"justify\")\n            fc.style.whiteSpace = \"normal\";\n    });\n    this.styleChanged.connect(this, function(newVal) {\n        switch (newVal) {\n            case 0:\n                fc.style.textShadow = \"none\";\n                break;\n            case 1:\n                var color = this.styleColor;\n                fc.style.textShadow = \"1px 0 0 \" + color\n                    + \", -1px 0 0 \" + color\n                    + \", 0 1px 0 \" + color\n                    + \", 0 -1px 0 \" + color;\n                break;\n            case 2:\n                fc.style.textShadow = \"1px 1px 0 \" + this.styleColor;\n                break;\n            case 3:\n                fc.style.textShadow = \"-1px -1px 0 \" + this.styleColor;\n        };\n    });\n    this.styleColorChanged.connect(this, function(newVal) {\n        newVal = QMLColor(newVal);\n        switch (this.style) {\n            case 0:\n                fc.style.textShadow = \"none\";\n                break;\n            case 1:\n                fc.style.textShadow = \"1px 0 0 \" + newVal\n                    + \", -1px 0 0 \" + newVal\n                    + \", 0 1px 0 \" + newVal\n                    + \", 0 -1px 0 \" + newVal;\n                break;\n            case 2:\n                fc.style.textShadow = \"1px 1px 0 \" + newVal;\n                break;\n            case 3:\n                fc.style.textShadow = \"-1px -1px 0 \" + newVal;\n        };\n    });\n\n    this.font.family = \"sans-serif\";\n    this.font.pointSize = 10;\n    this.wrapMode = this.Text.NoWrap;\n    this.color = \"black\";\n    this.text = \"\";\n\n    this.textChanged.connect(this, updateImplicit);\n    this.font.boldChanged.connect(this, updateImplicit);\n    this.font.pixelSizeChanged.connect(this, updateImplicit);\n    this.font.pointSizeChanged.connect(this, updateImplicit);\n    this.font.familyChanged.connect(this, updateImplicit);\n    this.font.letterSpacingChanged.connect(this, updateImplicit);\n    this.font.wordSpacingChanged.connect(this, updateImplicit);\n\n    this.Component.completed.connect(this, updateImplicit);\n\n    function updateImplicit() {\n        if (typeof this.text == undefined || this.text === \"\" || !this.dom) {\n             this.implicitHeigh = this.implicitWidth = 0;\n        } else {\n            this.implicitHeight = fc.offsetHeight;\n            this.implicitWidth = fc.offsetWidth;\n        }\n    }\n  }\n});\n","global.TextInput = {\n  Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3\n};\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'TextInput',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLTextInput(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    const QMLFont = getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    const input = this.impl = document.createElement('input');\n    input.type = 'text';\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    // In some browsers text-inputs have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    input.style.margin = \"0\";\n    input.style.padding = \"0\";\n    input.style.width = \"100%\";\n    input.style.height = \"100%\";\n    this.dom.appendChild(input);\n\n    this.setupFocusOnDom(input);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"int\", this, \"maximumLength\", {initialValue: -1});\n    createProperty(\"bool\",   this, \"readOnly\");\n    createProperty(\"var\",    this, \"validator\");\n    createProperty(\"enum\",   this, \"echoMode\");\n    this.accepted = Signal();\n    input.disabled = false;\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = input.offsetWidth;\n        this.implicitHeight = input.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function(newVal) {\n        // We have to check if value actually changes.\n        // If we do not have this check, then after user updates text input following occurs:\n        // user update gui text -> updateValue called -> textChanged called -> gui value updates again -> caret position moves to the right!\n        if (input.value != newVal)\n            input.value = newVal;\n    });\n\n    this.echoModeChanged.connect(this, (function(newVal) {\n        switch (newVal) {\n          case TextInput.Normal:\n            input.type = \"text\";\n            break ;\n          case TextInput.Password:\n            input.type = \"password\";\n            break ;\n          case TextInput.NoEcho:\n            // Not supported, use password, that's nearest\n            input.type = \"password\";\n            break;\n          case TextInput.PasswordEchoOnEdit:\n            // Not supported, use password, that's nearest\n            input.type = \"password\";\n            break;\n        }\n    }).bind(this));\n\n    this.maximumLengthChanged.connect(this, function(newVal) {\n        if (newVal < 0)\n          newVal = null;\n        input.maxLength = newVal;\n    });\n\n    this.readOnlyChanged.connect(this, function(newVal) {\n        input.disabled = newVal;\n    });\n\n    this.Keys.pressed.connect(this, (function(e) {\n      if ((e.key == Qt.Key_Return || e.key == Qt.Key_Enter) &&\n          testValidator()) {\n        self.accepted();\n        e.accepted = true;\n      }\n    }).bind(this));\n\n    function testValidator() {\n      if (typeof self.validator != 'undefined' && self.validator != null)\n        return self.validator.validate(self.text);\n      return true;\n    }\n\n    function updateValue(e) {\n        if (self.text != self.dom.firstChild.value) {\n          self.$canEditReadOnlyProperties = true;\n          self.text = self.dom.firstChild.value;\n          self.$canEditReadOnlyProperties = false;\n        }\n    }\n\n    input.oninput = updateValue;\n    input.onpropertychanged = updateValue;\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Transition',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLTransition(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n    createProperty(\"string\", this, \"from\", {initialValue: '*'});\n    createProperty(\"string\", this, \"to\", {initialValue: '*'});\n    createProperty(\"bool\", this, \"reversible\");\n    this.$item = this.$parent;\n\n    this.$start = function(actions) {\n        for (var i = 0; i < this.animations.length; i++) {\n            var animation = this.animations[i];\n            animation.$actions = [];\n            for (var j in actions) {\n                var action = actions[j];\n                if ((animation.$targets.length === 0 || animation.$targets.indexOf(action.target) !== -1)\n                    && (animation.$props.length === 0 || animation.$props.indexOf(action.property) !== -1))\n                    animation.$actions.push(action);\n            }\n            animation.start();\n        }\n    }\n    this.$stop = function() {\n        for (var i = 0; i < this.animations.length; i++)\n            this.animations[i].stop();\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Translate',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLTranslate(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"x\");\n    createProperty(\"real\", this, \"y\");\n\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n\n    this.x = 0;\n    this.y = 0;\n  }\n});\n","// WARNING: Can have wrong behavior if url is changed while the socket is in Connecting state.\n// TODO: Recheck everything.\n\nregisterQmlType({\n  module:   'QtWebSockets',\n  name:     'WebSocket',\n  versions: /.*/,\n  baseClass: 'QtQml.QtObject',\n  constructor: function QMLWebSocket(meta) {\n    callSuper(this, meta);\n\n    // Exports.\n    this.WebSocket = {\n        // status\n        Connecting: 0,\n        Open: 1,\n        Closing: 2,\n        Closed: 3,\n        Error: 4\n    }\n\n    createProperty(\"bool\", this, \"active\");\n    createProperty(\"enum\", this, \"status\");\n    createProperty(\"string\", this, \"errorString\");\n    createProperty(\"url\", this, \"url\");\n\n    this.textMessageReceived = Signal([{type: \"string\", name: \"message\"}]);\n\n    this.status = this.WebSocket.Closed;\n\n    var self = this,\n        socket,\n        reconnect = false;\n\n    this.sendTextMessage = function(message) {\n        if (this.status == this.WebSocket.Open)\n            socket.send(message);\n    }\n\n    function connectSocket() {\n        reconnect = false;\n\n        if (!self.url || !self.active)\n            return;\n\n        self.status = self.WebSocket.Connecting;\n        socket = new WebSocket(self.url);\n        socket.onopen = function() {\n            self.status = self.WebSocket.Open;\n        }\n        socket.onclose = function() {\n            self.status = self.WebSocket.Closed;\n            if (reconnect)\n                connectSocket();\n        }\n        socket.onerror = function(error) {\n            self.errorString = error.message;\n            self.status = self.WebSocket.Error;\n        }\n        socket.onmessage = function(message) {\n            self.textMessageReceived(message.data);\n        }\n    };\n\n    function reconnectSocket() {\n        reconnect = true;\n        if (self.status == self.WebSocket.Open) {\n            self.status = self.WebSocket.Closing;\n            socket.close()\n        } else if (self.status != self.WebSocket.Closing) {\n            connectSocket();\n        }\n    };\n\n    this.statusChanged.connect(this, function(status) {\n        if (status != self.WebSocket.Error)\n            self.errorString = \"\";\n    });\n    this.activeChanged.connect(this, reconnectSocket);\n    this.urlChanged.connect(this, reconnectSocket);\n  }\n});\n"],"sourceRoot":"/source/"}